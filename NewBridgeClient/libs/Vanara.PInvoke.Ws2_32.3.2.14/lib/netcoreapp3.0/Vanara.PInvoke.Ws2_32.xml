<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Vanara.PInvoke.Ws2_32</name>
    </assembly>
    <members>
        <member name="T:Vanara.PInvoke.Ws2_32">
            <summary>Functions, structures and constants from ws2_32.h.</summary>
            <summary>Functions, structures and constants from ws2_32.h.</summary>
            <summary>Functions, structures and constants from ws2_32.h.</summary>
            <summary>Functions, structures and constants from ws2_32.h.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SERVICETYPE">
            <summary>Specifies the level of service to negotiate for the flow.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SERVICETYPE.SERVICETYPE_NOTRAFFIC">
            <summary>
            Indicates that no traffic will be transmitted in the specified direction. On duplex-capable media, this value signals
            underlying software to set up unidirectional connections only. This service type is not valid for the TC API.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SERVICETYPE.SERVICETYPE_BESTEFFORT">
            <summary>
            Results in no action taken by the RSVP SP. Traffic control does create a BESTEFFORT flow, however, and traffic on the flow
            will be handled by traffic control similarly to other BESTEFFORT traffic.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SERVICETYPE.SERVICETYPE_CONTROLLEDLOAD">
            <summary>
            Provides an end-to-end QOS that closely approximates transmission quality provided by best-effort service, as expected under
            unloaded conditions from the associated network components along the data path.
            <para>Applications that use SERVICETYPE_CONTROLLEDLOAD may therefore assume the following:</para>
            <list type="bullet">
            <item>
            The network will deliver a very high percentage of transmitted packets to its intended receivers. In other words, packet loss
            will closely approximate the basic packet error rate of the transmission medium.
            </item>
            <item>
            Transmission delay for a very high percentage of the delivered packets will not greatly exceed the minimum transit delay
            experienced by any successfully delivered packet.
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SERVICETYPE.SERVICETYPE_GUARANTEED">
            <summary>
            Guarantees that datagrams will arrive within the guaranteed delivery time and will not be discarded due to queue overflows,
            provided the flow's traffic stays within its specified traffic parameters. This service is intended for applications that
            need a firm guarantee that a datagram will arrive no later than a certain time after it was transmitted by its source.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SERVICETYPE.SERVICETYPE_NETWORK_UNAVAILABLE">
            <summary>Used to notify network changes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SERVICETYPE.SERVICETYPE_GENERAL_INFORMATION">
            <summary>Specifies that all service types are supported for a flow. Can be used on sender side only.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SERVICETYPE.SERVICETYPE_NOCHANGE">
            <summary>
            Indicates that the quality of service in the transmission using this ServiceType value is not changed. SERVICETYPE_NOCHANGE
            can be used when requesting a change in the quality of service for one direction only, or when requesting a change only
            within the ProviderSpecific parameters of a QOS specification, and not in the SendingFlowspec or ReceivingFlowspec.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SERVICETYPE.SERVICETYPE_NONCONFORMING">
            <summary>Used to indicate nonconforming traffic.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SERVICETYPE.SERVICETYPE_NETWORK_CONTROL">
            <summary>
            Used only for transmission of control packets (such as RSVP signaling messages). This ServiceType has the highest priority.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SERVICETYPE.SERVICETYPE_QUALITATIVE">
            <summary>
            Indicates that the application requires better than BESTEFFORT transmission, but cannot quantify its transmission
            requirements. Applications that use SERVICETYPE_QUALITATIVE can supply an application identifier policy object. The
            application identification policy object enables policy servers on the network to identify the application, and accordingly,
            assign an appropriate quality of service to the request. For more information on application identification, consult the IETF
            Internet Draft draft-ietf-rap-rsvp-appid-00.txt, or the Microsoft white paper on Application Identification. Traffic control
            treats flows of this type with the same priority as BESTEFFORT traffic on the local computer. However, application
            programmers can get boosted priority for such flows by modifying the Layer 2 settings on the associated flow using the
            QOS_TRAFFIC_CLASS QOS object.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SERVICETYPE.SERVICE_NO_TRAFFIC_CONTROL">
            <summary>Indicates that traffic control should not be invoked in the specified direction.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SERVICETYPE.SERVICE_NO_QOS_SIGNALING">
            <summary>Suppresses RSVP signaling in the specified direction.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.FLOWSPEC">
            <summary>
            <para>
            The <c>FLOWSPEC</c> structure provides quality of service parameters to the RSVP SP. This allows QOS-aware applications to
            invoke, modify, or remove QOS settings for a given flow. Some members of <c>FLOWSPEC</c> can be set to default values. See
            Remarks for more information.
            </para>
            </summary>
            <remarks>
            <para>
            Many members of the <c>FLOWSPEC</c> structure can be set to default values by setting the member to QOS_NOT_SPECIFIED. Note that
            the members that can be set to default values differ depending on whether the <c>FLOWSPEC</c> is a receiving <c>FLOWSPEC</c> or a
            sending <c>FLOWSPEC</c>.
            </para>
            <para>There are a handful of considerations you should keep in mind when using <c>FLOWSPEC</c> with traffic control:</para>
            <list type="bullet">
            <item>
            <term>
            <c>TokenRate</c> can be QOS_NOT_SPECIFIED for SERVICETYPE_NETWORKCONTROL, SERVICETYPE_QUALITATIVE, and SERVICETYPE_BESTEFFORT.
            <c>TokenRate</c> must be valid for all other <c>ServiceType</c> values.
            </term>
            </item>
            <item>
            <term>If <c>PeakBandwidth</c> is specified, it must be greater than or equal to <c>TokenRate</c>.</term>
            </item>
            </list>
            <para>Many settings can be defaulted in a receiving <c>FLOWSPEC</c> except <c>ServiceType</c>, with the following considerations:</para>
            <list type="bullet">
            <item>
            <term>For a Controlled Load Service receiver, the default values are derived from the sender <c>TSPEC</c>.</term>
            </item>
            <item>
            <term>For a Guaranteed Service receiver, <c>ServiceType</c> and <c>TokenRate</c> must be specified.</term>
            </item>
            </list>
            <para>
            The following list specifies the values that are applied when a receiving <c>FLOWSPEC</c> sets the corresponding values to default:
            </para>
            <para>When the value of the <c>ServiceType</c> is set to SERVICETYPE_GUARANTEED, the following also applies:</para>
            <list type="bullet">
            <item>
            <term>The RATE value in <c>RSPEC</c> is set to the value of TokenRate.</term>
            </item>
            <item>
            <term>The DELAYSLACKTERM value in <c>RSPEC</c> is set to DelayVariation, which is set to zero if DelayVariation is set to QOS_NOT_SPECIFIED.</term>
            </item>
            <item>
            <term>
            For receivers requesting SERVICETYPE_GUARANTEED, the receiving TokenRate must be specified. This contrasts with a
            SERVICETYPE_CONTROLLEDLOAD receiver, for which TokenRate may be set to QOS_NOT_SPECIFIED.
            </term>
            </item>
            </list>
            <para>
            In a sending <c>FLOWSPEC</c>, everything can be defaulted except <c>ServiceType</c> and <c>TokenRate</c>. The following list
            specifies the values that are applied when a sending <c>FLOWSPEC</c> sets the corresponding values to default:
            </para>
            <para>
            <c>Traffic Control:</c> The following <c>ServiceType</c> s are invalid when specifically working with Traffic Control. If you are
            unsure whether you are working directly with Traffic Control (and thereby need to be concerned about whether the following
            <c>ServiceType</c> s are applicable in your situation), you probably are not:
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.FLOWSPEC.TokenRate">
            <summary>
            <para>
            Specifies the permitted rate at which data can be transmitted over the life of the flow. The <c>TokenRate</c> member is
            similar to other token bucket models seen in such WAN technologies as Frame Relay, in which the token is analogous to a
            credit. If such tokens are not used immediately, they accrue to allow data transmission up to a certain periodic limit (
            <c>PeakBandwidth</c>, in the case of Windows 2000 quality of service). Accrual of credits is limited, however, to a specified
            amount ( <c>TokenBucketSize</c>). Limiting total credits (tokens) avoids situations where, for example, flows that are
            inactive for some time flood the available bandwidth with their large amount of accrued tokens. Because flows may accrue
            transmission credits over time (at their <c>TokenRate</c> value) only up to the maximum of their <c>TokenBucketSize</c>, and
            because they are limited in burst transmissions to their <c>PeakBandwidth</c>, traffic control and network-device resource
            integrity are maintained. Traffic control is maintained because flows cannot send too much data at once, and network-device
            resource integrity is maintained because such devices are spared high traffic bursts.
            </para>
            <para>
            With this model, applications can transmit data only when sufficient credits are available. If sufficient credits are not
            available, the application must either wait or discard the traffic (based on the value of QOS_SD_MODE). Therefore, it is
            important that applications base their <c>TokenRate</c> requests on reasonable expectations for transmission requirements.
            For example, in video applications, <c>TokenRate</c> is typically set to the average bit rate from peak to peak.
            </para>
            <para>
            If <c>TokenRate</c> is set to QOS_NOT_SPECIFIED on the receiver only, the maximum transmission unit (MTU) is used for
            <c>TokenRate</c>, and limits on the transmission rate (the token bucket model) will not be put into effect. Thus,
            <c>TokenRate</c> is expressed in bytes per second.
            </para>
            <para>
            The <c>TokenRate</c> member cannot be set to zero. Nor can it be set as a default (that is, set to QOS_NOT_SPECIFIED) in a
            sending <c>FLOWSPEC</c>.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.FLOWSPEC.TokenBucketSize">
            <summary>
            <para>
            The maximum amount of credits a given direction of a flow can accrue, regardless of time, in bytes. In video applications,
            <c>TokenBucketSize</c> will likely be the largest average frame size. In constant rate applications, <c>TokenBucketSize</c>
            should be set to allow for small variations.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.FLOWSPEC.PeakBandwidth">
            <summary>
            <para>
            The upper limit on time-based transmission permission for a given flow, in bytes per second. The <c>PeakBandwidth</c> member
            restricts flows that may have accrued a significant amount of transmission credits, or tokens from overburdening network
            resources with one-time or cyclical data bursts, by enforcing a per-second data transmission ceiling. Some intermediate
            systems can take advantage of this information, resulting in more efficient resource allocation.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.FLOWSPEC.Latency">
            <summary>
            <para>
            Maximum acceptable delay between transmission of a bit by the sender and its receipt by one or more intended receivers, in
            microseconds. The precise interpretation of this number depends on the level of guarantee specified in the QOS request.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.FLOWSPEC.DelayVariation">
            <summary>
            <para>
            Difference between the maximum and minimum possible delay a packet will experience, in microseconds. Applications use
            <c>DelayVariation</c> to determine the amount of buffer space needed at the receiving end of the flow. This buffer space
            information can be used to restore the original data transmission pattern.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.FLOWSPEC.ServiceType">
            <summary>
            <para>
            Specifies the level of service to negotiate for the flow. The <c>ServiceType</c> member can be one of the following defined
            service types.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SERVICETYPE_NOTRAFFIC</term>
            <term>
            Indicates that no traffic will be transmitted in the specified direction. On duplex-capable media, this value signals
            underlying software to set up unidirectional connections only. This service type is not valid for the TC API.
            </term>
            </item>
            <item>
            <term>SERVICETYPE_BESTEFFORT</term>
            <term>
            Results in no action taken by the RSVP SP. Traffic control does create a BESTEFFORT flow, however, and traffic on the flow
            will be handled by traffic control similarly to other BESTEFFORT traffic.
            </term>
            </item>
            <item>
            <term>SERVICETYPE_CONTROLLEDLOAD</term>
            <term>
            Provides an end-to-end QOS that closely approximates transmission quality provided by best-effort service, as expected under
            unloaded conditions from the associated network components along the data path. Applications that use
            SERVICETYPE_CONTROLLEDLOAD may therefore assume the following:
            </term>
            </item>
            <item>
            <term>SERVICETYPE_GUARANTEED</term>
            <term>
            Guarantees that datagrams will arrive within the guaranteed delivery time and will not be discarded due to queue overflows,
            provided the flow's traffic stays within its specified traffic parameters. This service is intended for applications that
            need a firm guarantee that a datagram will arrive no later than a certain time after it was transmitted by its source.
            </term>
            </item>
            <item>
            <term>SERVICETYPE_QUALITATIVE</term>
            <term>
            Indicates that the application requires better than BESTEFFORT transmission, but cannot quantify its transmission
            requirements. Applications that use SERVICETYPE_QUALITATIVE can supply an application identifier policy object. The
            application identification policy object enables policy servers on the network to identify the application, and accordingly,
            assign an appropriate quality of service to the request. For more information on application identification, consult the IETF
            Internet Draft draft-ietf-rap-rsvp-appid-00.txt, or the Microsoft white paper on Application Identification. Traffic control
            treats flows of this type with the same priority as BESTEFFORT traffic on the local computer. However, application
            programmers can get boosted priority for such flows by modifying the Layer 2 settings on the associated flow using the
            QOS_TRAFFIC_CLASS QOS object.
            </term>
            </item>
            <item>
            <term>SERVICETYPE_NETWORK_UNAVAILBLE</term>
            <term>Used to notify network changes.</term>
            </item>
            <item>
            <term>SERVICETYPE_NETWORK_CONTROL</term>
            <term>
            Used only for transmission of control packets (such as RSVP signaling messages). This ServiceType has the highest priority.
            </term>
            </item>
            <item>
            <term>SERVICETYPE_GENERAL_INFORMATION</term>
            <term>Specifies that all service types are supported for a flow. Can be used on sender side only.</term>
            </item>
            <item>
            <term>SERVICETYPE_NOCHANGE</term>
            <term>
            Indicates that the quality of service in the transmission using this ServiceType value is not changed. SERVICETYPE_NOCHANGE
            can be used when requesting a change in the quality of service for one direction only, or when requesting a change only
            within the ProviderSpecific parameters of a QOS specification, and not in the SendingFlowspec or ReceivingFlowspec.
            </term>
            </item>
            <item>
            <term>SERVICETYPE_NONCONFORMING</term>
            <term>Used to indicate nonconforming traffic.</term>
            </item>
            <item>
            <term>SERVICE_NO_TRAFFIC_CONTROL</term>
            <term>Indicates that traffic control should not be invoked in the specified direction.</term>
            </item>
            <item>
            <term>SERVICE_NO_QOS_SIGNALING</term>
            <term>Suppresses RSVP signaling in the specified direction.</term>
            </item>
            </list>
            <para>The following list identifies the relative priority of <c>ServiceType</c> settings:</para>
            <para>SERVICETYPE_NETWORK_CONTROL</para>
            <para>SERVICETYPE_GUARANTEED</para>
            <para>SERVICETYPE_CONTROLLED_LOAD</para>
            <para>SERVICETYPE_BESTEFFORT</para>
            <para>SERVICETYPE_QUALITATIVE</para>
            <para>Non-conforming traffic</para>
            <para>
            For a simple example, if a given network device were resource-bounded and had to choose among transmitting a packet from one
            of the above <c>ServiceType</c> settings, it would first send a packet of SERVICETYPE_NETWORKCONTROL, and if there were no
            packets of that <c>ServiceType</c> requiring transmission it would send a packet of <c>ServiceType</c>
            SERVICETYPE_GUARANTEED, and so on.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.FLOWSPEC.MaxSduSize">
            <summary>
            <para>Specifies the maximum packet size permitted or used in the traffic flow, in bytes.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.FLOWSPEC.MinimumPolicedSize">
            <summary>
            <para>
            Specifies the minimum packet size for which the requested quality of service will be provided, in bytes. Packets smaller than
            this size are treated by traffic control as <c>MinimumPolicedSize</c>. When using the <c>FLOWSPEC</c> structure in
            association with RSVP, the value of <c>MinimumPolicedSize</c> cannot be zero; however, if you are using the <c>FLOWSPEC</c>
            structure specifically with the TC API, you can set <c>MinimumPolicedSize</c> to zero.
            </para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCWriteNameSpaceOrder(System.Guid[],System.UInt32)">
            <summary>
            The <c>WSCWriteNameSpaceOrder</c> function changes the order of available Windows Sockets (Winsock) 2 namespace providers. The
            order of the namespace providers determines the priority of the namespace when enumerated or queried for name resolution.
            </summary>
            <param name="lpProviderId">
            An array of <c>NSProviderId</c> elements as found in the WSANAMESPACE_INFOstructure. The order of the <c>NSProviderId</c>
            elements is the new priority ordering for the namespace providers.
            </param>
            <param name="dwNumberOfEntries">The number of elements in the <c>NSProviderId</c> array.</param>
            <returns>
            <para>
            The function returns <c>ERROR_SUCCESS</c> (zero) if the routine is successful. Otherwise, it returns a specific error code.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>The NSProviderId array is not fully contained within process address space.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more of the arguments are input parameters were invalid, no action was taken.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the
            administrative privileges required to write to the Winsock registry or another application is currently writing to the namespace
            provider catalog.
            </term>
            </item>
            <item>
            <term>WSASYSCALLFAILURE</term>
            <term>A system call that should never fail has failed.</term>
            </item>
            <item>
            <term>WSATRY_AGAIN</term>
            <term>The function is called by another thread or process.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>Insufficient memory was available to perform the operation.</term>
            </item>
            <item>
            <term>(other)</term>
            <term>The function may return any registry error code.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Namespace providers are installed using the WSCInstallNameSpace function. The order in which namespace providers are initially
            installed governs the default order in which they are enumerated through WSAEnumNameSpaceProviders. More importantly, this order
            also governs the order in which namespace providers are considered when a client requests name resolution. The order of
            namespace providers can be changed using the <c>WSCWriteNameSpaceOrder</c> function. On 64-bit platforms, the
            WSCWriteNameSpaceOrder32 function is provided to allow 64-bit processes to change the order of namespace providers in the 32-bit
            namespace provider catalog. On 64-bit platforms, namespace providers are installed in the 32-bit namespace provider catalog
            using the WSCInstallNameSpace32 function.
            </para>
            <para>
            The current namespace provider catalog is stored in the registry under the following registry key:
            <c>HKEY_LOCAL_MACHINE</c>&lt;b&gt;SYSTEM&lt;b&gt;Current Control Set&lt;b&gt;Services&lt;b&gt;Winsock2&lt;b&gt;Parameters&lt;b&gt;NameSpace_Catalog5
            </para>
            <para>
            A client request for name resolution uses the WSALookupServiceBegin, WSALookupServiceNext, and WSALookupServiceEnd routines. The
            <c>dwNameSpace</c> member of the WSAQUERYSET structure passed to <c>WSALookupServiceBegin</c> is set to the identifier of a
            single namespace (NS_DNS, for example) in which to constrain the search, or <c>NS_ALL</c> to include all namespaces. If multiple
            namespace providers support a specific namespace ( <c>NS_DNS</c>, for example), then the results from all namespace providers
            that match the requested <c>dwNameSpace</c> are returned unless the <c>lpNSProviderId</c> member is set to a specific namespace
            provider. The results from all namespace providers is returned if NS_ALL is specified for the <c>dwNameSpace</c> member. The
            order that the results are returned is dependent on the namespace provider order in the catalog.
            </para>
            <para>
            The Windows SDK includes an application called SpOrder.exe that allows the catalog of installed namespace providers to be
            displayed. Windows Sockets 2 includes the ws2_32.dll that exports the <c>WSCWriteNameSpaceOrder</c> function for reordering
            namespace providers in the catalog. This interface can be imported by linking with WS2_32.lib. For computers running on Windows
            XP with Service Pack 2 (SP2) and Windows Server 2003 with Service Pack 1 (SP1) and later, the <c>netsh.exe winsock show
            catalog</c> command will display both the protocol and namespace providers installed on the system.
            </para>
            <para>
            <c>WSCWriteNameSpaceOrder</c> can only be called by a user logged on as a member of the Administrators group. If
            <c>WSCWriteNameSpaceOrder</c> is called by a user that is not a member of the Administrators group, the function call will fail
            and <c>WSANO_RECOVERY</c> is returned in the lpErrno parameter.
            </para>
            <para>
            For computers running on Windows Vista and Windows Vista, this function can also fail because of user account control (UAC). If
            an application that contains this function is executed by a user logged on as a member of the Administrators group other than
            the Administrator, this call will fail unless the application has been marked in the manifest file with a
            <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If the application on Windows Vista and Windows Vista lacks
            this setting in the manifest file used to build the executable file, a user logged on as a member of the Administrators group
            other than the Administrator must then be executing the application in an enhanced shell as the Administrator ( <c>RunAs
            administrator</c>) for this function to succeed.
            </para>
            <para>The following list describes scenarios in which the <c>WSCWriteNameSpaceOrder</c> function could fail:</para>
            <list type="bullet">
            <item>
            <term>The dwNumberOfEntries parameter is not equal to the number of registered namespace providers.</term>
            </item>
            <item>
            <term>The <c>NSProviderId</c> array contains an invalid namespace provider identifier.</term>
            </item>
            <item>
            <term>The <c>NSProviderId</c> array does not contain all valid namespace provider identifiers exactly one time.</term>
            </item>
            <item>
            <term>The function cannot access the registry (for example, insufficient user permissions).</term>
            </item>
            <item>
            <term>Another process (or thread) is currently calling the function.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCWriteNameSpaceOrder32(System.Guid[],System.UInt32)">
            <summary>
            The <c>WSCWriteNameSpaceOrder32</c> function changes the order of available Windows Sockets (Winsock) 2 namespace providers in a
            32-bit catalog. The order of the namespace providers determines the priority of the namespace when enumerated or queried for
            name resolution.
            </summary>
            <param name="lpProviderId">
            An array of <c>NSProviderId</c> elements as found in the WSANAMESPACE_INFOstructure. The order of the <c>NSProviderId</c>
            elements is the new priority ordering for the namespace providers.
            </param>
            <param name="dwNumberOfEntries">The number of elements in the <c>NSProviderId</c> array.</param>
            <returns>
            <para>
            The function returns <c>ERROR_SUCCESS</c> (zero) if the routine is successful. Otherwise, it returns a specific error code.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>The NSProviderId array is not fully contained within process address space.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>Input parameters were invalid, no action was taken.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred. This error is returned under several conditions including the following: the Winsock registry
            could not be opened, the user lacks the administrative privileges required to write to the Winsock registry, or another
            application is currently writing to the namespace provider catalog.
            </term>
            </item>
            <item>
            <term>WSASYSCALLFAILURE</term>
            <term>A system call that should never fail has failed.</term>
            </item>
            <item>
            <term>WSATRY_AGAIN</term>
            <term>The function is called by another thread or process.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>Insufficient memory was available to perform the operation.</term>
            </item>
            <item>
            <term>(other)</term>
            <term>The function may return any registry error code.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            Namespace providers are installed on 64-bit platforms in a 32-bit namespace provider catalog using the WSCInstallNameSpace32
            function. The order in which namespace providers in a 32-bit catalog are initially installed governs the default order in which
            they are enumerated through WSCEnumNameSpaceProviders32. More importantly, this order also governs the order in which namespace
            providers are considered when a client requests name resolution. On 64-bit platforms, the <c>WSCWriteNameSpaceOrder32</c>
            function is provided to allow 64-bit processes to change the order of namespace providers in the 32-bit namespace provider
            catalog. The order of namespace providers in the native catalog can be changed using the WSCWriteNameSpaceOrder function.
            </para>
            <para>
            The current namespace provider catalog is stored in the registry under the following registry key:
            <c>HKEY_LOCAL_MACHINE</c>&lt;b&gt;SYSTEM&lt;b&gt;Current Control Set&lt;b&gt;Services&lt;b&gt;Winsock2&lt;b&gt;Parameters&lt;b&gt;NameSpace_Catalog5
            </para>
            <para>
            A client request for name resolution uses the WSALookupServiceBegin, WSALookupServiceNext, and WSALookupServiceEnd routines. The
            <c>dwNameSpace</c> member of the WSAQUERYSET structure passed to <c>WSALookupServiceBegin</c> is set to the identifier of a
            single namespace ( <c>NS_DNS</c>, for example) in which to constrain the search, or <c>NS_ALL</c> to include all namespaces. If
            multiple namespace providers support a specific namespace (for example, <c>NS_DNS</c>), then the results from all namespace
            providers that match the requested <c>dwNameSpace</c> are returned unless the <c>lpNSProviderId</c> member is set to a specific
            namespace provider. The results from all namespace providers is returned if <c>NS_ALL</c> is specified for the
            <c>dwNameSpace</c> member. The order that the results are returned depends on the namespace provider order in the catalog.
            </para>
            <para>
            The Windows SDK includes an application called SpOrder.exe that allows the catalog of installed namespace providers to be
            displayed. Winsock 2 includes the ws2_32.DLL on 64-bit platforms that exports the <c>WSCWriteNameSpaceOrder32</c> function for
            reordering namespace providers in the 32-bit namespace provider catalog. This interface can be imported by linking with
            WS2_32.lib. For computers running on Windows XP with Service Pack 2 (SP2) and Windows Server 2003 with Service Pack 1 (SP1) and
            later, the <c>netsh.exe winsock show catalog</c> command will display both the protocol and namespace providers installed. The
            native 64-bit catalog is displayed first followed by the 32-bit provider catalogs (denoted with a 32 after their name).
            </para>
            <para>
            <c>WSCWriteNameSpaceOrder32</c> can only be called by a user logged on as a member of the Administrators group. If
            <c>WSCWriteNameSpaceOrder32</c> is called by a user that is not a member of the Administrators group, the function call will
            fail and <c>WSANO_RECOVERY</c> is returned in the lpErrno parameter.
            </para>
            <para>
            For computers running on Windows Vista and Windows Vista, this function can also fail because of user account control (UAC). If
            an application that contains this function is executed by a user logged on as a member of the Administrators group other than
            the Administrator, this call will fail unless the application has been marked in the manifest file with a
            <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If the application on Windows Vista and Windows Vista lacks
            this setting in the manifest file used to build the executable file, a user logged on as a member of the Administrators group
            other than the Administrator must then be executing the application in an enhanced shell as the Administrator ( <c>RunAs
            administrator</c>) for this function to succeed.
            </para>
            <para>The following list describes scenarios in which the <c>WSCWriteNameSpaceOrder32</c> function could fail:</para>
            <list type="bullet">
            <item>
            <term>The dwNumberOfEntries parameter is not equal to the number of registered namespace providers.</term>
            </item>
            <item>
            <term>The <c>NSProviderId</c> array contains an invalid namespace provider identifier.</term>
            </item>
            <item>
            <term>The <c>NSProviderId</c> array does not contain all valid namespace provider identifiers exactly one time.</term>
            </item>
            <item>
            <term>The function is not able to access the registry for some reason (insufficient user permissions, for example).</term>
            </item>
            <item>
            <term>Another process, or thread, is currently calling the function.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCWriteProviderOrder(System.UInt32[],System.UInt32)">
            <summary>
            The <c>WSCWriteProviderOrder</c> function is used to reorder the available transport providers. The order of the protocols
            determines the priority of a protocol when being enumerated or selected for use.
            </summary>
            <param name="lpwdCatalogEntryId">
            A pointer to an array of <c>CatalogEntryId</c> elements found in the WSAPROTOCOL_INFO structure. The order of the
            <c>CatalogEntryId</c> elements is the new priority ordering for the protocols.
            </param>
            <param name="dwNumberOfEntries">The number of elements in the lpwdCatalogEntryId array.</param>
            <returns>
            <para>
            The function returns <c>ERROR_SUCCESS</c> (zero) if the routine is successful. Otherwise, it returns a specific error code.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more of the arguments are invalid, no action was taken.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the
            administrative privileges required to write to the Winsock registry, or a failure occurred when opening or writing a catalog entry.
            </term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>
            Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
            </term>
            </item>
            <item>
            <term>(other)</term>
            <term>The routine may return any registry error code.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The order in which transport service providers are initially installed governs the order in which they are enumerated through
            WSCEnumProtocols at the service provider interface, or through WSAEnumProtocols at the application interface. More importantly,
            this order also governs the order in which protocols and service providers are considered when a client requests creation of a
            socket based on its address family, type, and protocol identifier.
            </para>
            <para>
            Windows Sockets 2 includes an application called Sporder.exe that allows the catalog of installed protocols to be reordered
            interactively after protocols have already been installed. Windows Sockets 2 also includes an auxiliary DLL, Sporder.dll that
            exports this procedural interface for reordering protocols. This interface can be imported by linking with Sporder.lib.
            </para>
            <para>The following are scenarios in which the <c>WSCWriteProviderOrder</c> function could fail:</para>
            <list type="bullet">
            <item>
            <term>The dwNumberOfEntries parameter is not equal to the number of registered service providers.</term>
            </item>
            <item>
            <term>The lpwdCatalogEntryId contains an invalid catalog identifier.</term>
            </item>
            <item>
            <term>The lpwdCatalogEntryId does not contain all valid catalog identifiers exactly one time.</term>
            </item>
            <item>
            <term>The routine is not able to access the registry for some reason (for example, inadequate user permissions).</term>
            </item>
            <item>
            <term>Another process (or thread) is currently calling the function.</term>
            </item>
            </list>
            <para>
            On success, <c>WSCWriteProviderOrder</c> will attempt to alert all interested applications that have registered for notification
            of the change by calling WSAProviderConfigChange.
            </para>
            <para>
            The <c>WSCWriteProviderOrder</c> function can only be called by a user logged on as a member of the Administrators group. If
            <c>WSCWriteProviderOrder</c> is called by a user that is not a member of the Administrators group, the function call will fail
            and WSANO_RECOVERY is returned. For computers running on Windows Vista or Windows Server 2008, this function can also fail
            because of user account control (UAC). If an application that contains this function is executed by a user logged on as a member
            of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in
            the manifest file with a <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If the application on Windows Vista
            or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the
            built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator ( <c>RunAs
            administrator</c>) for this function to succeed.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCWriteProviderOrder32(System.UInt32[],System.UInt32)">
            <summary>
            <para>
            The <c>WSCWriteProviderOrder32</c> function is used to reorder the available 32-bit transport providers. The order of the
            protocols determines the priority of a protocol when being enumerated or selected for use.
            </para>
            <para>
            <c>Note</c> This call is a strictly 32-bit version of WSCWriteProviderOrder for use on 64-bit platforms. It is provided to allow
            64-bit processes to modify the 32-bit catalogs.
            </para>
            </summary>
            <param name="lpwdCatalogEntryId">
            A pointer to an array of <c>CatalogEntryId</c> elements found in the WSAPROTOCOL_INFO structure. The order of the
            <c>CatalogEntryId</c> elements is the new priority ordering for the protocols.
            </param>
            <param name="dwNumberOfEntries">The number of elements in the lpwdCatalogEntryId array.</param>
            <returns>
            <para>
            The function returns <c>ERROR_SUCCESS</c> (zero) if the routine is successful. Otherwise, it returns a specific error code.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more of the arguments are invalid, no action was taken.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the
            administrative privileges required to write to the Winsock registry, or a failure occurred when opening or writing a catalog entry.
            </term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>
            Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
            </term>
            </item>
            <item>
            <term>(other)</term>
            <term>The routine may return any registry error code.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSCWriteProviderOrder32</c> function is a strictly 32-bit version of the WSCWriteProviderOrder function. On a 64-bit
            computer, all calls not specifically 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit
            catalog. Processes that execute on a 64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit
            catalog and preserve compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
            </para>
            <para>
            The order in which transport service providers are initially installed governs the order in which they are enumerated through
            WSCEnumProtocols32 at the service provider interface, or through WSAEnumProtocols at the application interface. More
            importantly, this order also governs the order in which protocols and service providers are considered when a client requests
            creation of a socket based on its address family, type, and protocol identifier.
            </para>
            <para>
            Windows Sockets 2 includes an application called Sporder.exe that allows the catalog of installed protocols to be reordered
            interactively after protocols have already been installed. Windows Sockets 2 also includes an auxiliary DLL, Sporder.dll that
            exports this procedural interface for reordering protocols. This interface can be imported by linking with Sporder.lib.
            </para>
            <para>The following are scenarios in which the <c>WSCWriteProviderOrder32</c> function could fail:</para>
            <list type="bullet">
            <item>
            <term>The dwNumberOfEntries parameter is not equal to the number of registered service providers.</term>
            </item>
            <item>
            <term>The lpwdCatalogEntryId contains an invalid catalog identifier.</term>
            </item>
            <item>
            <term>The lpwdCatalogEntryId does not contain all valid catalog identifiers exactly one time.</term>
            </item>
            <item>
            <term>The routine is not able to access the registry for some reason (for example, inadequate user permissions).</term>
            </item>
            <item>
            <term>Another process (or thread) is currently calling the function.</term>
            </item>
            </list>
            <para>
            On success, <c>WSCWriteProviderOrder32</c> will attempt to alert all interested applications that have registered for
            notification of the change by calling WSAProviderConfigChange.
            </para>
            <para>
            The <c>WSCWriteProviderOrder32</c> function can only be called by a user logged on as a member of the Administrators group. If
            <c>WSCWriteProviderOrder32</c> is called by a user that is not a member of the Administrators group, the function call will fail
            and WSANO_RECOVERY is returned. For computers running on Windows Vista or Windows Server 2008, this function can also fail
            because of user account control (UAC). If an application that contains this function is executed by a user logged on as a member
            of the Administrators group other than the built-in Administrator, this call will fail unless the application has been marked in
            the manifest file with a <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If the application on Windows Vista
            or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other than the
            built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator ( <c>RunAs
            administrator</c>) for this function to succeed.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.PVD_CONFIG">
            <summary>
            An opaque data structure object from the service provider associated with socket s. This object stores the current configuration
            information of the service provider. The exact format of this data structure is service provider specific.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_ACCEPTCONN">
            <summary>The socket is listening.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_BROADCAST">
            <summary>The socket is configured for the transmission and receipt of broadcast messages.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_BSP_STATE">
            <summary>Returns the local address, local port, remote address, remote port, socket type, and protocol used by a socket.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_CONDITIONAL_ACCEPT">
            <summary>Returns current socket state, either from a previous call to setsockopt or the system default.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_CONNDATA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_CONNDATALEN">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_CONNECT_TIME">
            <summary>
            Returns the number of seconds a socket has been connected. This socket option is valid for connection oriented protocols only.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_CONNOPT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_CONNOPTLEN">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_DEBUG">
            <summary>Debugging is enabled.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_DISCDATA">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_DISCDATALEN">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_DISCOPT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_DISCOPTLEN">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_DONTLINGER">
            <summary>If TRUE, the SO_LINGER option is disabled.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_DONTROUTE">
            <summary>
            Routing is disabled. Setting this succeeds but is ignored on AF_INET sockets; fails on AF_INET6 sockets with WSAENOPROTOOPT.
            This option is not supported on ATM sockets.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_ERROR">
            <summary>Retrieves error status and clear.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_EXCLUSIVEADDRUSE">
            <summary>
            Prevents any other socket from binding to the same address and port. This option must be set before calling the bind function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_GROUP_ID">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_GROUP_PRIORITY">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_KEEPALIVE">
            <summary>Keep-alives are being sent. Not supported on ATM sockets.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_LINGER">
            <summary>Returns the current linger options.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_MAX_MSG_SIZE">
            <summary>
            The maximum size of a message for message-oriented socket types (for example, SOCK_DGRAM). Has no meaning for stream oriented sockets.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_MAXDG">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_MAXPATHDG">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_OOBINLINE">
            <summary>
            OOB data is being received in the normal data stream. (See section Windows Sockets 1.1 Blocking Routines and EINPROGRESS for a
            discussion of this topic.)
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_PROTOCOL_INFO">
            <summary>A description of the protocol information for the protocol that is bound to this socket.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_PROTOCOL_INFOA">
            <summary>A description of the protocol information for the protocol that is bound to this socket.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_PROTOCOL_INFOW">
            <summary>A description of the protocol information for the protocol that is bound to this socket.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_RCVBUF">
            <summary>
            The total per-socket buffer space reserved for receives. This is unrelated to SO_MAX_MSG_SIZE and does not necessarily
            correspond to the size of the TCP receive window.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_RCVLOWAT">
            <summary>Receives low watermark.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_RCVTIMEO">
            <summary>Receives time-out.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_REUSEADDR">
            <summary>The socket can be bound to an address which is already in use. Not applicable for ATM sockets.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_SNDBUF">
            <summary>
            The total per-socket buffer space reserved for sends. This is unrelated to SO_MAX_MSG_SIZE and does not necessarily correspond
            to the size of a TCP send window.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_SNDLOWAT">
            <summary>Sends low watermark.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_SNDTIMEO">
            <summary>Sends time-out.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_TYPE">
            <summary>The type of the socket (for example, SOCK_STREAM).</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_UPDATE_ACCEPT_CONTEXT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SO_USELOOPBACK">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKET_ERROR">
            <summary>A value that indicates a function failure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOL_SOCKET">
            <summary>The socket option level.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOMAXCONN">
            <summary>Maximum queue length specifiable by listen.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.TCP_BSDURGENT">
            <summary></summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.TCP_NODELAY">
            <summary>Disables the Nagle algorithm for send coalescing.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.ConditionFunc">
            <summary>The application-specified callback function for <see cref="M:Vanara.PInvoke.Ws2_32.WSAAccept(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.SOCKADDR,System.Int32@,Vanara.PInvoke.Ws2_32.ConditionFunc,System.IntPtr)"/>.</summary>
            <param name="lpCallerId">
            A WSABUF structure that contains the address of the connecting entity, where its len parameter is the length of the buffer in
            bytes, and its buf parameter is a pointer to the buffer..
            </param>
            <param name="lpCallerData">
            A value parameter that contains any user data. The information in these parameters is sent along with the connection request. If
            no caller identification or caller data is available, the corresponding parameters will be NULL. Many network protocols do not
            support connect-time caller data. Most conventional network protocols can be expected to support caller identifier information
            at connection-request time. The buf portion of the WSABUF pointed to by lpCallerId points to a sockaddr. The sockaddr structure
            is interpreted according to its address family (typically by casting the sockaddr to some type specific to the address family).
            </param>
            <param name="lpSQOS">
            References the FLOWSPEC structures for socket s specified by the caller, one for each direction, followed by any additional
            provider-specific parameters. The sending or receiving flow specification values will be ignored as appropriate for any
            unidirectional sockets. A NULL value indicates that there is no caller-supplied quality of service and that no negotiation is
            possible. A non-NULL lpSQOS pointer indicates that a quality of service negotiation is to occur or that the provider is prepared
            to accept the quality of service request without negotiation.
            </param>
            <param name="lpGQOS">
            Reserved, and should be NULL. (reserved for future use with socket groups) references the FLOWSPEC structure for the socket
            group the caller is to create, one for each direction, followed by any additional provider-specific parameters. A NULL value for
            lpGQOS indicates no caller-specified group quality of service. Quality of service information can be returned if negotiation is
            to occur.
            </param>
            <param name="lpCalleeId">
            Contains the local address of the connected entity. The buf portion of the WSABUF pointed to by lpCalleeId points to a sockaddr
            structure. The sockaddr structure is interpreted according to its address family (typically by casting the sockaddr to some type
            specific to the address family such as struct sockaddr_in).
            </param>
            <param name="lpCalleeData">
            A result parameter used by the condition function to supply user data back to the connecting entity. The lpCalleeData-&gt;len
            initially contains the length of the buffer allocated by the service provider and pointed to by lpCalleeData-&gt;buf. A value of
            zero means passing user data back to the caller is not supported. The condition function should copy up to lpCalleeData-&gt;len
            bytes of data into lpCalleeData-&gt;buf, and then update lpCalleeData-&gt;len to indicate the actual number of bytes
            transferred. If no user data is to be passed back to the caller, the condition function should set lpCalleeData-&gt;len to zero.
            The format of all address and user data is specific to the address family to which the socket belongs.
            </param>
            <param name="g">
            <para>Assigned within the condition function to indicate any of the following actions:</para>
            <list type="bullet">
            <item>
            If g is an existing socket group identifier, add s to this group, provided all the requirements set by this group are met.
            </item>
            <item>If g = SG_UNCONSTRAINED_GROUP, create an unconstrained socket group and have s as the first member.</item>
            <item>If g = SG_CONSTRAINED_GROUP, create a constrained socket group and have s as the first member.</item>
            <item>If g = zero, no group operation is performed.</item>
            </list>
            <para>
            For unconstrained groups, any set of sockets can be grouped together as long as they are supported by a single service provider.
            A constrained socket group can consist only of connection-oriented sockets, and requires that connections on all grouped sockets
            be to the same address on the same host.For newly created socket groups, the new group identifier can be retrieved by using
            getsockopt function with level parameter set to SOL_SOCKET and the optname parameter set to SO_GROUP_ID.A socket group and its
            associated socket group ID remain valid until the last socket belonging to this socket group is closed.Socket group IDs are
            unique across all processes for a given service provider. A socket group and its associated identifier remain valid until the
            last socket belonging to this socket group is closed.Socket group identifiers are unique across all processes for a given
            service provider. For more information on socket groups, see the Remarks for the WSASocket functions.
            </para>
            </param>
            <param name="dwCallbackData">
            Value passed to the condition function is the value passed as the dwCallbackData parameter in the original WSAAccept call. This
            value is interpreted only by the Windows Socket version 2 client. This allows a client to pass some context information from the
            WSAAccept call site through to the condition function. This also provides the condition function with any additional information
            required to determine whether to accept the connection or not. A typical usage is to pass a (suitably cast) pointer to a data
            structure containing references to application-defined objects with which this socket is associated.
            </param>
            <returns></returns>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY">
            <summary>The address family specification.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_UNSPEC">
            <summary>Unspecified address family.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_UNIX">
            <summary>Unix local to host address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_INET">
            <summary>Address for IP version 4.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_IMPLINK">
            <summary>ARPANET IMP address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_PUP">
            <summary>Address for PUP protocols.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_CHAOS">
            <summary>Address for MIT CHAOS protocols.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_NS">
            <summary>Address for Xerox NS protocols.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_IPX">
            <summary>IPX or SPX address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_ISO">
            <summary>Address for ISO protocols.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_OSI">
            <summary>Address for OSI protocols.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_ECMA">
            <summary>European Computer Manufacturers Association (ECMA) address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_DATAKIT">
            <summary>Address for Datakit protocols.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_CCITT">
            <summary>Addresses for CCITT protocols, such as X.25.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_SNA">
            <summary>IBM SNA address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_DECnet">
            <summary>DECnet address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_DLI">
            <summary>Direct data-link interface address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_LAT">
            <summary>LAT address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_HYLINK">
            <summary>NSC Hyperchannel address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_APPLETALK">
            <summary>AppleTalk address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_NETBIOS">
            <summary>NetBios address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_VOICEVIEW">
            <summary>VoiceView address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_FIREFOX">
            <summary>FireFox address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_UNKNOWN1">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_BAN">
            <summary>Banyan address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_ATM">
            <summary>Native ATM services address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_INET6">
            <summary>Address for IP version 6.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_CLUSTER">
            <summary>Address for Microsoft cluster products.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_12844">
            <summary>IEEE 1284.4 workgroup address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_IRDA">
            <summary>IrDA address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_NETDES">
            <summary>Address for Network Designers OSI gateway-enabled protocols.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_TCNPROCESS">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_TCNMESSAGE">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_ICLFXBM">
            <summary>Undocumented.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_BTH">
            <summary>Bluetooth RFCOMM/L2CAP protocols.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_LINK">
            <summary>Link layer interface.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY.AF_HYPERV">
            <summary>Windows Hyper-V.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.CF">
            <summary>Possible return values to WSAAccept from the LPCONDITIONPROC.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.CF.CF_ACCEPT">
            <summary>
            WSAAccept creates a new socket. The newly created socket has the same properties as socket s including asynchronous events
            registered with WSAAsyncSelect or with WSAEventSelect.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.CF.CF_REJECT">
            <summary>
            WSAAccept rejects the connection request. The condition function runs in the same thread as this function does, and should
            return as soon as possible.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.CF.CF_DEFER">
            <summary>
            If the decision cannot be made immediately, the condition function should return CF_DEFER to indicate that no decision has
            been made, and no action about this connection request should be taken by the service provider. When the application is
            ready to take action on the connection request, it will invoke WSAAccept again and return either CF_ACCEPT or CF_REJECT as a
            return value from the condition function.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.GROUP">
            <summary>Socket group flags.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.GROUP.SG_UNCONSTRAINED_GROUP">
            <summary>
            Create an unconstrained socket group and have the new socket be the first member. For an unconstrained group, Winsock does
            not constrain all sockets in the socket group to have been created with the same value for the type and protocol parameters.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.GROUP.SG_CONSTRAINED_GROUP">
            <summary>
            Create a constrained socket group and have the new socket be the first member. For a contrained socket group, Winsock
            constrains all sockets in the socket group to have been created with the same value for the type and protocol parameters. A
            constrained socket group may consist only of connection-oriented sockets, and requires that connections on all grouped
            sockets be to the same address on the same host.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.IPPROTO">
            <summary>Protocols. The IPv6 defines are specified in RFC 2292.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_HOPOPTS">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_ICMP">
            <summary>
            The Internet Control Message Protocol (ICMP). This is a possible value when the af parameter is AF_UNSPEC, AF_INET, or
            AF_INET6 and the type parameter is SOCK_RAW or unspecified.
            <para>This protocol value is supported on Windows XP and later.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_IGMP">
            <summary>
            The Internet Group Management Protocol (IGMP). This is a possible value when the af parameter is AF_UNSPEC, AF_INET, or
            AF_INET6 and the type parameter is SOCK_RAW or unspecified.
            <para>This protocol value is supported on Windows XP and later.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_GGP">
            <summary>
            The Bluetooth Radio Frequency Communications (Bluetooth RFCOMM) protocol. This is a possible value when the af parameter is
            AF_BTH and the type parameter is SOCK_STREAM.
            <para>This protocol value is supported on Windows XP with SP2 or later.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_IPV4">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_ST">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_TCP">
            <summary>
            The Transmission Control Protocol (TCP). This is a possible value when the af parameter is AF_INET or AF_INET6 and the type
            parameter is SOCK_STREAM.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_CBT">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_EGP">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_IGP">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_PUP">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_UDP">
            <summary>
            The User Datagram Protocol (UDP). This is a possible value when the af parameter is AF_INET or AF_INET6 and the type
            parameter is SOCK_DGRAM.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_IDP">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_RDP">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_IPV6">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_ROUTING">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_FRAGMENT">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_ESP">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_AH">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_ICMPV6">
            <summary>
            The Internet Control Message Protocol Version 6 (ICMPv6). This is a possible value when the af parameter is AF_UNSPEC,
            AF_INET, or AF_INET6 and the type parameter is SOCK_RAW or unspecified.
            <para>This protocol value is supported on Windows XP and later.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_NONE">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_DSTOPTS">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_ND">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_ICLFXBM">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_PIM">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_PGM">
            <summary>
            The PGM protocol for reliable multicast. This is a possible value when the af parameter is AF_INET and the type parameter is
            SOCK_RDM. On the Windows SDK released for Windows Vista and later, this protocol is also called IPPROTO_PGM.
            <para>This protocol value is only supported if the Reliable Multicast Protocol is installed.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_L2TP">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_SCTP">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_RAW">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_MAX">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_RESERVED_RAW">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_RESERVED_IPSEC">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_RESERVED_IPSECOFFLOAD">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_RESERVED_WNV">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IPPROTO.IPPROTO_RESERVED_MAX">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.NetworkByteOrder">
            <summary>Indicate either big-endian or little-endian with the values 0 and 1 respectively.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NetworkByteOrder.BIGENDIAN">
            <summary>The bigendian</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NetworkByteOrder.LITTLEENDIAN">
            <summary>The littleendian</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.NS">
            <summary>Namespace identifier.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_ALL">
            <summary>All installed and active namespaces.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_SAP">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_NDS">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_PEER_BROWSE">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_SLP">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_DHCP">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_TCPIP_LOCAL">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_TCPIP_HOSTS">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_DNS">
            <summary>The domain name system (DNS) namespace.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_NETBT">
            <summary>The NetBIOS over TCP/IP (NETBT) namespace.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_WINS">
            <summary>The Windows Internet Naming Service (NS_WINS) namespace.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_NLA">
            <summary>
            The network location awareness (NLA) namespace.
            <para>This namespace identifier is supported on Windows XP and later.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_BTH">
            <summary>
            The Bluetooth namespace.
            <para>This namespace identifier is supported on Windows Vista and later.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_LOCALNAME">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_NBP">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_MS">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_STDA">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_NTDS">
            <summary>The Windows NT Directory Services (NS_NTDS) namespace.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_EMAIL">
            <summary>
            The email namespace.
            <para>This namespace identifier is supported on Windows Vista and later.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_PNRPNAME">
            <summary>
            The peer-to-peer namespace for a specific peer name.
            <para>This namespace identifier is supported on Windows Vista and later.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_PNRPCLOUD">
            <summary>
            The peer-to-peer namespace for a collection of peer names.
            <para>This namespace identifier is supported on Windows Vista and later.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_X500">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_NIS">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_NISPLUS">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_WRQ">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NS.NS_NETDES">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.PFL">
            <summary>A set of flags that provides information on how this protocol is represented in the Winsock catalog.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.PFL.PFL_MULTIPLE_PROTO_ENTRIES">
            <summary>
            Indicates that this is one of two or more entries for a single protocol (from a given provider) which is capable of
            implementing multiple behaviors. An example of this is SPX which, on the receiving side, can behave either as a
            message-oriented or a stream-oriented protocol.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.PFL.PFL_RECOMMENDED_PROTO_ENTRY">
            <summary>
            Indicates that this is the recommended or most frequently used entry for a protocol that is capable of implementing multiple behaviors.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.PFL.PFL_HIDDEN">
            <summary>
            Set by a provider to indicate to the Ws2_32.dll that this protocol should not be returned in the result buffer generated by
            WSAEnumProtocols. Obviously, a Windows Sockets 2 application should never see an entry with this bit set.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.PFL.PFL_MATCHES_PROTOCOL_ZERO">
            <summary>Indicates that a value of zero in the protocol parameter of socket or WSASocket matches this protocol entry.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.PFL.PFL_NETWORKDIRECT_PROVIDER">
            <summary>
            Set by a provider to indicate support for network direct access.
            <para>This value is supported on Windows 7 and Windows Server 2008 R2.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SOCK">
            <summary>The type specification for the new socket.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCK.SOCK_STREAM">
            <summary>
            A socket type that provides sequenced, reliable, two-way, connection-based byte streams with an OOB data transmission
            mechanism. This socket type uses the Transmission Control Protocol (TCP) for the Internet address family (AF_INET or AF_INET6).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCK.SOCK_DGRAM">
            <summary>
            A socket type that supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum
            length. This socket type uses the User Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCK.SOCK_RAW">
            <summary>
            A socket type that provides a raw socket that allows an application to manipulate the next upper-layer protocol header. To
            manipulate the IPv4 header, the IP_HDRINCL socket option must be set on the socket. To manipulate the IPv6 header, the
            IPV6_HDRINCL socket option must be set on the socket.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCK.SOCK_RDM">
            <summary>
            A socket type that provides a reliable message datagram. An example of this type is the Pragmatic General Multicast (PGM)
            multicast protocol implementation in Windows, often referred to as reliable multicast programming.
            <para>This type value is only supported if the Reliable Multicast Protocol is installed.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCK.SOCK_SEQPACKET">
            <summary>A socket type that provides a pseudo-stream packet based on datagrams.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WSAECOMPARATOR">
            <summary>
            The Windows Sockets <c>WSAECOMPARATOR</c> enumeration type is used for version-comparison semantics in Windows Sockets 2.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAECOMPARATOR.COMP_EQUAL">
            <summary>Used for determining whether version values are equal.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAECOMPARATOR.COMP_NOTLESS">
            <summary>Used for determining whether a version value is no less than a specified value.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WSAESETSERVICEOP">
            <summary>A value that determines that operation requested.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAESETSERVICEOP.RNRSERVICE_REGISTER">
            <summary>
            Register the service. For SAP, this means sending out a periodic broadcast. This is an NOP for the DNS namespace. For
            persistent data stores, this means updating the address information.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAESETSERVICEOP.RNRSERVICE_DEREGISTER">
            <summary>
            Remove the service from the registry. For SAP, this means stop sending out the periodic broadcast. This is an NOP for the
            DNS namespace. For persistent data stores this means deleting address information.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAESETSERVICEOP.RNRSERVICE_DELETE">
            <summary>
            Delete the service from dynamic name and persistent spaces. For services represented by multiple CSADDR_INFO structures
            (using the SERVICE_MULTIPLE flag), only the specified address will be deleted, and this must match exactly the corresponding
            CSADDR_INFO structure that was specified when the service was registered.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.XP1">
            <summary>A bitmask that describes the services provided by the protocol.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.XP1.XP1_CONNECTIONLESS">
            <summary>Provides connectionless (datagram) service. If not set, the protocol supports connection-oriented data transfer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.XP1.XP1_GUARANTEED_DELIVERY">
            <summary>Guarantees that all data sent will reach the intended destination.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.XP1.XP1_GUARANTEED_ORDER">
            <summary>
            Guarantees that data only arrives in the order in which it was sent and that it is not duplicated. This characteristic does
            not necessarily mean that the data is always delivered, but that any data that is delivered is delivered in the order in
            which it was sent.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.XP1.XP1_MESSAGE_ORIENTED">
            <summary>Honors message boundariesas opposed to a stream-oriented protocol where there is no concept of message boundaries.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.XP1.XP1_PSEUDO_STREAM">
            <summary>
            A message-oriented protocol, but message boundaries are ignored for all receipts. This is convenient when an application
            does not desire message framing to be done by the protocol.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.XP1.XP1_GRACEFUL_CLOSE">
            <summary>Supports two-phase (graceful) close. If not set, only abortive closes are performed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.XP1.XP1_EXPEDITED_DATA">
            <summary>Supports expedited (urgent) data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.XP1.XP1_CONNECT_DATA">
            <summary>Supports connect data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.XP1.XP1_DISCONNECT_DATA">
            <summary>Supports disconnect data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.XP1.XP1_SUPPORT_BROADCAST">
            <summary>Supports a broadcast mechanism.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.XP1.XP1_SUPPORT_MULTIPOINT">
            <summary>Supports a multipoint or multicast mechanism. Control and data plane attributes are indicated below.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.XP1.XP1_MULTIPOINT_CONTROL_PLANE">
            <summary>Indicates whether the control plane is rooted (value = 1) or nonrooted (value = 0).</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.XP1.XP1_MULTIPOINT_DATA_PLANE">
            <summary>Indicates whether the data plane is rooted (value = 1) or nonrooted (value = 0).</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.XP1.XP1_QOS_SUPPORTED">
            <summary>Supports quality of service requests.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.XP1.XP1_INTERRUPT">
            <summary>Bit is reserved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.XP1.XP1_UNI_SEND">
            <summary>Protocol is unidirectional in the send direction.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.XP1.XP1_UNI_RECV">
            <summary>Protocol is unidirectional in the recv direction.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.XP1.XP1_IFS_HANDLES">
            <summary>Socket descriptors returned by the provider are operating system Installable File System (IFS) handles.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.XP1.XP1_PARTIAL_MESSAGE">
            <summary>The MSG_PARTIAL flag is supported in WSASend and WSASendTo.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.XP1.XP1_SAN_SUPPORT_SDP">
            <summary>
            The protocol provides support for SAN.
            <para>This value is supported on Windows 7 and Windows Server 2008 R2.</para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOMAXCONN_HINT(System.Int32)">
            <summary/>
            <param name="b"/>
            <returns/>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.CSADDR_INFO">
            <summary>
            The <c>CSADDR_INFO</c> structure contains Windows Sockets address information for a socket, network service, or namespace provider.
            </summary>
            <remarks>
            <para>The GetAddressByName function obtains Windows Sockets address information using <c>CSADDR_INFO</c> structures.</para>
            <para>
            The getsockopt function called with the SO_BSP_STATE socket option retrieves a <c>CSADDR_INFO</c> structure for the specified socket.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.CSADDR_INFO.LocalAddr">
            <summary>
            <para>Type: <c>SOCKET_ADDRESS</c></para>
            <para>The Windows Sockets local address.</para>
            <para>In a client application, pass this address to the <c>bind</c> function to obtain access to a network service.</para>
            <para>
            In a network service, pass this address to the <c>bind</c> function so that the service is bound to the appropriate local address.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.CSADDR_INFO.RemoteAddr">
            <summary>
            <para>Type: <c>SOCKET_ADDRESS</c></para>
            <para>Windows Sockets remote address.</para>
            <para>There are several uses for this remote address:</para>
            <list type="bullet">
            <item>
            <term>
            You can use this remote address to connect to the service through the connect function. This is useful if an application
            performs send/receive operations that involve connection-oriented protocols.
            </term>
            </item>
            <item>
            <term>
            You can use this remote address with the sendto function when you are communicating over a connectionless (datagram)
            protocol. If you are using a connectionless protocol, such as UDP, <c>sendto</c> is typically the way you pass data to the
            remote system.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.CSADDR_INFO.iSocketType">
            <summary>
            <para>Type: <c>INT</c></para>
            <para>The type of Windows socket. Possible values for the socket type are defined in the Winsock2.h header file.</para>
            <para>The following table lists the possible values supported for Windows Sockets 2:</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SOCK_STREAM</term>
            <term>
            A stream socket. This is a protocol that sends data as a stream of bytes, with no message boundaries. This socket type
            provides sequenced, reliable, two-way, connection-based byte streams with an OOB data transmission mechanism. This socket
            type uses the Transmission Control Protocol (TCP) for the Internet address family (AF_INET or AF_INET6).
            </term>
            </item>
            <item>
            <term>SOCK_DGRAM</term>
            <term>
            A datagram socket. This socket type supports datagrams, which are connectionless, unreliable buffers of a fixed (typically
            small) maximum length. This socket type uses the User Datagram Protocol (UDP) for the Internet address family (AF_INET or
            AF_INET6). Services use recvfrom function to obtain datagrams. The listen and accept functions do not work with datagrams.
            </term>
            </item>
            <item>
            <term>SOCK_RDM</term>
            <term>
            A reliable message datagram socket. This socket type preserves message boundaries in data. An example of this type is the
            Pragmatic General Multicast (PGM) multicast protocol implementation in Windows, often referred to as reliable multicast programming.
            </term>
            </item>
            <item>
            <term>SOCK_SEQPACKET</term>
            <term>A sequenced packet stream socket. This socket type provides a pseudo-stream packet based on datagrams.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.CSADDR_INFO.iProtocol">
            <summary>
            <para>Type: <c>INT</c></para>
            <para>
            The protocol used. The possible options for the protocol parameter are specific to the address family and socket type
            specified. Possible values are defined in the Winsock2.h and Wsrm.h header files.
            </para>
            <para>
            On the Windows SDK released for Windows Vista and later, the organization of header files has changed and this parameter can
            be one of the values from the <c>IPPROTO</c> enumeration type defined in the Ws2def.h header file. Note that the Ws2def.h
            header file is automatically included in Winsock2.h, and should never be used directly.
            </para>
            <para>The table below lists common values for the protocol although many other values are possible.</para>
            <list type="table">
            <listheader>
            <term>protocol</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>IPPROTO_TCP 6</term>
            <term>
            The Transmission Control Protocol (TCP). This is a possible value when the address family is AF_INET or AF_INET6 and the
            iSocketType member is SOCK_STREAM.
            </term>
            </item>
            <item>
            <term>IPPROTO_UDP 17</term>
            <term>
            The User Datagram Protocol (UDP). This is a possible value when the address family is AF_INET or AF_INET6 and the
            iSocketType member is SOCK_DGRAM.
            </term>
            </item>
            <item>
            <term>IPPROTO_RM 113</term>
            <term>
            The PGM protocol for reliable multicast. This is a possible value when the address family is AF_INET and the iSocketType
            member is SOCK_RDM. On the Windows SDK released for Windows Vista and later, this value is also called IPPROTO_PGM.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.IN_ADDR">
            <summary>The IN_ADDR structure represents an IPv4 address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IN_ADDR.S_addr">
            <summary>An IPv4 address formatted as a u_long.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN_ADDR.#ctor(System.UInt32)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.IN_ADDR"/> struct.</summary>
            <param name="v4addr">An IPv4 address.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN_ADDR.#ctor(System.Byte[])">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.IN_ADDR"/> struct.</summary>
            <param name="v4addr">An IPv4 address</param>
            <exception cref="T:System.ArgumentException">Byte array must have 4 items. - v4addr</exception>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN_ADDR.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.IN_ADDR"/> struct.</summary>
            <param name="b1">The first byte.</param>
            <param name="b2">The second byte.</param>
            <param name="b3">The third byte.</param>
            <param name="b4">The fourth byte.</param>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.IN_ADDR.S_un_b">
            <summary>Gets the address represented as four bytes.</summary>
            <value>An IPv4 address formatted as four u_chars.</value>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IN_ADDR.INADDR_ANY">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IN_ADDR.INADDR_LOOPBACK">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IN_ADDR.INADDR_BROADCAST">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IN_ADDR.INADDR_NONE">
            <summary/>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN_ADDR.op_Equality(Vanara.PInvoke.Ws2_32.IN_ADDR,Vanara.PInvoke.Ws2_32.IN_ADDR)">
            <summary>Implements the operator ==.</summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN_ADDR.op_Inequality(Vanara.PInvoke.Ws2_32.IN_ADDR,Vanara.PInvoke.Ws2_32.IN_ADDR)">
            <summary>Implements the operator !=.</summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN_ADDR.op_Implicit(Vanara.PInvoke.Ws2_32.IN_ADDR)~System.UInt32">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.IN_ADDR"/> to <see cref="T:System.UInt32"/>.</summary>
            <param name="a">An IN_ADDR value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN_ADDR.op_Implicit(Vanara.PInvoke.Ws2_32.IN_ADDR)~System.Int64">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.IN_ADDR"/> to <see cref="T:System.Int64"/>.</summary>
            <param name="a">An IN_ADDR value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN_ADDR.op_Implicit(Vanara.PInvoke.Ws2_32.IN_ADDR)~System.Byte[]">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.IN_ADDR"/> to <see cref="T:byte[]"/>.</summary>
            <param name="a">An IN_ADDR value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN_ADDR.op_Implicit(System.UInt32)~Vanara.PInvoke.Ws2_32.IN_ADDR">
            <summary>Performs an implicit conversion from <see cref="T:System.UInt32"/> to <see cref="T:Vanara.PInvoke.Ws2_32.IN_ADDR"/>.</summary>
            <param name="a">A UInt32 value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN_ADDR.op_Implicit(System.Int64)~Vanara.PInvoke.Ws2_32.IN_ADDR">
            <summary>Performs an implicit conversion from <see cref="T:System.Int64"/> to <see cref="T:Vanara.PInvoke.Ws2_32.IN_ADDR"/>.</summary>
            <param name="a">An Int64 value.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN_ADDR.Equals(Vanara.PInvoke.Ws2_32.IN_ADDR)">
            <summary>Determines equality between this instance and <paramref name="other"/>.</summary>
            <param name="other">The other value to compare.</param>
            <returns><see langword="true"/> if <paramref name="other"/> is equal to this instance.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN_ADDR.Equals(System.Object)">
            <summary>Determines whether the specified <see cref="T:System.Object"/>, is equal to this instance.</summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns><see langword="true"/> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN_ADDR.GetHashCode">
            <summary>Returns a hash code for this instance.</summary>
            <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN_ADDR.ToString">
            <summary>Returns a <see cref="T:System.String"/> that represents this instance.</summary>
            <returns>A <see cref="T:System.String"/> that represents this instance.</returns>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.IN6_ADDR">
            <summary>The IN6_ADDR structure represents an IPv6 address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IN6_ADDR.Loopback">
            <summary>The IPv6 standard loopback address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IN6_ADDR.Unspecified">
            <summary>The IPv6 standard unspecified address.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN6_ADDR.#ctor(System.Byte[])">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.IN6_ADDR"/> struct.</summary>
            <param name="v6addr">The IPv6 address as an array of bytes.</param>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.IN6_ADDR.bytes">
            <summary>Gets or sets the byte array representing the IPv6 address.</summary>
            <value>The bytes.</value>
            <exception cref="T:System.ArgumentException">Byte array must have 16 items. - value</exception>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.IN6_ADDR.words">
            <summary>Gets or sets the array of WORD (ushort) values representing the IPv6 address.</summary>
            <value>The array of WORD values.</value>
            <exception cref="T:System.ArgumentException">UInt16 array must have 8 items. - value</exception>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN6_ADDR.op_Equality(Vanara.PInvoke.Ws2_32.IN6_ADDR,Vanara.PInvoke.Ws2_32.IN6_ADDR)">
            <summary>Implements the operator ==.</summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN6_ADDR.op_Inequality(Vanara.PInvoke.Ws2_32.IN6_ADDR,Vanara.PInvoke.Ws2_32.IN6_ADDR)">
            <summary>Implements the operator !=.</summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN6_ADDR.op_Implicit(System.Byte[])~Vanara.PInvoke.Ws2_32.IN6_ADDR">
            <summary>Performs an implicit conversion from <see cref="T:System.Byte"/>[] to <see cref="T:Vanara.PInvoke.Ws2_32.IN6_ADDR"/>.</summary>
            <param name="a">The byte array.</param>
            <returns>The resulting <see cref="T:Vanara.PInvoke.Ws2_32.IN6_ADDR"/> instance from the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN6_ADDR.op_Implicit(Vanara.PInvoke.Ws2_32.IN6_ADDR)~System.Byte[]">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.IN6_ADDR"/> to <see cref="T:System.Byte"/>[].</summary>
            <param name="a">The <see cref="T:Vanara.PInvoke.Ws2_32.IN6_ADDR"/> instance.</param>
            <returns>The resulting <see cref="T:System.Byte"/>[] instance from the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN6_ADDR.Equals(System.Object)">
            <summary>Determines whether the specified <see cref="T:System.Object"/>, is equal to this instance.</summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns><see langword="true"/> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN6_ADDR.GetHashCode">
            <summary>Returns a hash code for this instance.</summary>
            <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN6_ADDR.ToString">
            <summary>Converts to string.</summary>
            <returns>A <see cref="T:System.String"/> that represents this instance.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IN6_ADDR.Equals(Vanara.PInvoke.Ws2_32.IN6_ADDR)">
            <summary>Determines whether the specified <paramref name="other"/> value is equal to this instance.</summary>
            <param name="other">The value to compare with this instance.</param>
            <returns><see langword="true"/> if the specified value is equal to this instance; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.LINGER">
            <summary>
            The <c>linger</c> structure maintains information about a specific socket that specifies how that socket should behave when data
            is queued to be sent and the closesocket function is called on the socket.
            </summary>
            <remarks>
            <para>
            The <c>l_onoff</c> member of the <c>linger</c> structure determines whether a socket should remain open for a specified amount
            of time after a closesocket function call to enable queued data to be sent. Somewhat confusing is that this member can be
            modified in two ways:
            </para>
            <list type="bullet">
            <item>
            <term>
            Call the setsockopt function with the optname parameter set to <c>SO_DONTLINGER</c>. The optval parameter determines how the
            <c>l_onoff</c> member is modified.
            </term>
            </item>
            <item>
            <term>
            Call the setsockopt function with the optname parameter set to <c>SO_LINGER</c>. The optval parameter specifies how both the
            <c>l_onoff</c> and <c>l_linger</c> members are modified.
            </term>
            </item>
            </list>
            <para>
            The <c>l_linger</c> member of the <c>linger</c> structure determines the amount of time, in seconds, a socket should remain
            open. This member is only applicable if the <c>l_onoff</c> member of the <c>linger</c> structure is nonzero.
            </para>
            <para>
            To enable a socket to remain open, an application should set the <c>l_onoff</c> member to a nonzero value and set the
            <c>l_linger</c> member to the desired time-out in seconds. To disable a socket from remaining open, an application only needs to
            set the <c>l_onoff</c> member of the <c>linger</c> structure to zero.
            </para>
            <para>
            If an application calls the setsockopt function with the optname parameter set to <c>SO_DONTLINGER</c> to set the <c>l_onoff</c>
            member to a nonzero value, the value for the <c>l_linger</c> member is not specified. In this case, the time-out used is
            implementation dependent. If a previous time-out has been established for a socket (by enabling SO_LINGER), this time-out value
            should be reinstated by the service provider.
            </para>
            <para>Note that enabling a nonzero timeout on a nonblocking socket is not recommended.</para>
            <para>
            The getsockopt function can be called with the optname parameter set to <c>SO_LINGER</c> to retrieve the current value of the
            <c>linger</c> structure associated with a socket.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LINGER.l_onoff">
            <summary>
            <para>Type: <c>u_short</c></para>
            <para>
            Specifies whether a socket should remain open for a specified amount of time after a closesocket function call to enable
            queued data to be sent. This member can have one of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>
            The socket will not remain open. This is the value set if the setsockopt function is called with the optname parameter set
            to SO_DONTLINGER and the optval parameter is zero. This value is also set if the setsockopt function is called with the
            optname parameter set to SO_LINGER and the linger structure passed in the optval parameter has the l_onoff member set to 0.
            </term>
            </item>
            <item>
            <term>nonzero</term>
            <term>
            The socket will remain open for a specified amount of time. This value is set if the setsockopt function is called with the
            optname parameter set to SO_DONTLINGER and the optval parameter is nonzero. This value is also set if the setsockopt
            function is called with the optname parameter set to SO_LINGER and the linger structure passed in the optval parameter has
            the l_onoff member set to a nonzero value.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LINGER.l_linger">
            <summary>
            <para>Type: <c>u_short</c></para>
            <para>
            The linger time in seconds. This member specifies how long to remain open after a closesocket function call to enable queued
            data to be sent. This member is only applicable if the <c>l_onoff</c> member of the <c>linger</c> structure is set to a
            nonzero value.
            </para>
            <para>
            This value is set if the setsockopt function is called with the optname parameter set to <c>SO_LINGER</c>. The optval
            parameter passed to the <c>setsockopt</c> function must contain a <c>linger</c> structure that is copied to the internal
            <c>linger</c> structure maintained for the socket.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.QOS">
            <summary>
            The <c>QOS</c> structure provides the means by which QOS-enabled applications can specify quality of service parameters for sent
            and received traffic on a particular flow.
            </summary>
            <remarks>
            Most applications can fulfill their quality of service requirements without using the ProviderSpecific buffer. However, if the
            application must provide information not available with standard Windows 2000 QOS parameters, the ProviderSpecific buffer allows
            the application to provide additional parameters for RSVP and/or traffic control.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.QOS.SendingFlowspec">
            <summary>
            Specifies QOS parameters for the sending direction of a particular flow. SendingFlowspec is sent in the form of a FLOWSPEC structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.QOS.ReceivingFlowspec">
            <summary>
            Specifies QOS parameters for the receiving direction of a particular flow. ReceivingFlowspec is sent in the form of a
            FLOWSPEC structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.QOS.ProviderSpecific">
            <summary>
            Pointer to a structure of type WSABUF that can provide additional provider-specific quality of service parameters to the
            RSVP SP for a given flow.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SOCKET">
            <summary>Provides a handle to a socket.</summary>
            <seealso cref="T:Vanara.PInvoke.IHandle"/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKET.handle">
            <summary>The handle</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKET.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.SOCKET"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.SOCKET.INVALID_SOCKET">
            <summary>Represents an invalid socket which is different than a null socket.</summary>
            <value>The invalid socket.</value>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.SOCKET.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.Ws2_32.SOCKET"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
            <value>Returns a <see cref="T:Vanara.PInvoke.Ws2_32.SOCKET"/> value.</value>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.SOCKET.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
            <value><see langword="true"/> if this instance is null; otherwise, <see langword="false"/>.</value>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKET.op_Explicit(Vanara.PInvoke.Ws2_32.SOCKET)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.SOCKET"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKET.op_Implicit(System.IntPtr)~Vanara.PInvoke.Ws2_32.SOCKET">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.Ws2_32.SOCKET"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKET.op_Inequality(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.SOCKET)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKET.op_Equality(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.SOCKET)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKET.Equals(System.Object)">
            <summary>Determines whether the specified <see cref="T:System.Object"/>, is equal to this instance.</summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <see langword="true"/> if the specified <see cref="T:System.Object"/> is equal to this instance; otherwise, <see langword="false"/>.
            </returns>
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKET.GetHashCode">
            <summary>Returns a hash code for this instance.</summary>
            <returns>A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table.</returns>
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKET.DangerousGetHandle">
            <summary>Returns the value of the handle field.</summary>
            <returns>An IntPtr representing the value of the handle field.</returns>
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKET.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.TIMEVAL">
            <summary>
            The <c>timeval</c> structure is used to specify a time interval. It is associated with the Berkeley Software Distribution (BSD)
            Time.h header file.
            </summary>
            <remarks>
            <para>
            The <c>timeval</c> structure is used in Windows Sockets by the select function to specify the maximum time the function can take
            to complete. The time interval is a combination of the values in <c>tv_sec</c> and <c>tv_usec</c> members.
            </para>
            <para>
            Several functions are added on Windows Vista and later that use the <c>timeval</c> structure. These functions include
            GetAddrInfoEx, SetAddrInfoEx, WSAConnectByList, and WSAConnectByName.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.TIMEVAL.tv_sec">
            <summary>Time interval, in seconds.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.TIMEVAL.tv_usec">
            <summary>
            Time interval, in microseconds. This value is used in combination with the <c>tv_sec</c> member to represent time interval
            values that are not a multiple of seconds.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.TIMEVAL.op_Explicit(System.TimeSpan)~Vanara.PInvoke.Ws2_32.TIMEVAL">
            <summary>Performs an explicit conversion from <see cref="T:System.TimeSpan"/> to <see cref="T:Vanara.PInvoke.Ws2_32.TIMEVAL"/>.</summary>
            <param name="timeSpan">The time span.</param>
            <returns>The resulting <see cref="T:Vanara.PInvoke.Ws2_32.TIMEVAL"/> instance from the conversion.</returns>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WSADATA">
            <summary>The <c>WSADATA</c> structure contains information about the Windows Sockets implementation.</summary>
            <remarks>
            <para>
            The WSAStartup function initiates the use of the Windows Sockets DLL by a process. The <c>WSAStartup</c> function returns a
            pointer to the <c>WSADATA</c> structure in the lpWSADataparameter.
            </para>
            <para>The current version of the Windows Sockets specification returned in the <c>wHighVersion</c> member of the</para>
            <para>
            <c>WSADATA</c> structure is version 2.2 encoded with the major version number in the low-byte and the minor version number in
            the high-byte. This version of the current Winsock DLL, Ws2_32.dll, supports applications that request any of the following
            versions of the Windows Sockets specification:
            </para>
            <list type="bullet">
            <item>
            <term>1.0</term>
            </item>
            <item>
            <term>1.1</term>
            </item>
            <item>
            <term>2.0</term>
            </item>
            <item>
            <term>2.1</term>
            </item>
            <item>
            <term>2.2</term>
            </item>
            </list>
            <para>
            Depending on the version requested by the application, one of the above version numbers is the value encoded as the major
            version number in the low-byte and the minor version number in the high-byte that is returned in the <c>wVersion</c> member of
            the <c>WSADATA</c> structure.
            </para>
            <para>
            <c>Note</c> An application should ignore the <c>iMaxsockets</c>, <c>iMaxUdpDg</c>, and <c>lpVendorInfo</c> members in
            <c>WSADATA</c> if the value in <c>wVersion</c> after a successful call to WSAStartup is at least 2. This is because the
            architecture of Windows Sockets changed in version 2 to support multiple providers, and <c>WSADATA</c> no longer applies to a
            single vendor's stack. Two new socket options are introduced to supply provider-specific information: SO_MAX_MSG_SIZE (replaces
            the <c>iMaxUdpDg</c> member) and PVD_CONFIG (allows any other provider-specific configuration to occur).
            </para>
            <para>Examples</para>
            <para>The following example demonstrates the use of the <c>WSADATA</c> structure.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSADATA.wVersion">
            <summary>
            <para>Type: <c>WORD</c></para>
            <para>
            The version of the Windows Sockets specification that the Ws2_32.dll expects the caller to use. The high-order byte
            specifies the minor version number; the low-order byte specifies the major version number.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSADATA.wHighVersion">
            <summary>
            <para>Type: <c>WORD</c></para>
            <para>
            The highest version of the Windows Sockets specification that the Ws2_32.dll can support. The high-order byte specifies the
            minor version number; the low-order byte specifies the major version number.
            </para>
            <para>
            This is the same value as the <c>wVersion</c> member when the version requested in the wVersionRequested parameter passed to
            the WSAStartup function is the highest version of the Windows Sockets specification that the Ws2_32.dll can support.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSADATA.iMaxSockets">
            <summary>
            <para>Type: <c>unsigned short</c></para>
            <para>
            The maximum number of sockets that may be opened. This member should be ignored for Windows Sockets version 2 and later.
            </para>
            <para>
            The <c>iMaxSockets</c> member is retained for compatibility with Windows Sockets specification 1.1, but should not be used
            when developing new applications. No single value can be appropriate for all underlying service providers. The architecture
            of Windows Sockets changed in version 2 to support multiple providers, and the <c>WSADATA</c> structure no longer applies to
            a single vendor's stack.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSADATA.iMaxUdpDg">
            <summary>
            <para>Type: <c>unsigned short</c></para>
            <para>The maximum datagram message size. This member is ignored for Windows Sockets version 2 and later.</para>
            <para>
            The <c>iMaxUdpDg</c> member is retained for compatibility with Windows Sockets specification 1.1, but should not be used
            when developing new applications. The architecture of Windows Sockets changed in version 2 to support multiple providers,
            and the <c>WSADATA</c> structure no longer applies to a single vendor's stack. For the actual maximum message size specific
            to a particular Windows Sockets service provider and socket type, applications should use getsockopt to retrieve the value
            of option SO_MAX_MSG_SIZE after a socket has been created.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSADATA.lpVendorInfo">
            <summary>
            <para>Type: <c>char FAR*</c></para>
            <para>A pointer to vendor-specific information. This member should be ignored for Windows Sockets version 2 and later.</para>
            <para>
            The <c>lpVendorInfo</c> member is retained for compatibility with Windows Sockets specification 1.1. The architecture of
            Windows Sockets changed in version 2 to support multiple providers, and the <c>WSADATA</c> structure no longer applies to a
            single vendor's stack. Applications needing to access vendor-specific configuration information should use getsockopt to
            retrieve the value of option PVD_CONFIG for vendor-specific information.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSADATA.szDescription">
            <summary>
            <para>Type: <c>char[WSADESCRIPTION_LEN+1]</c></para>
            <para>
            A <c>NULL</c>-terminated ASCII string into which the Ws2_32.dll copies a description of the Windows Sockets implementation.
            The text (up to 256 characters in length) can contain any characters except control and formatting characters. The most
            likely use that an application would have for this member is to display it (possibly truncated) in a status message.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSADATA.szSystemStatus">
            <summary>
            <para>Type: <c>char[WSASYS_STATUS_LEN+1]</c></para>
            <para>
            A <c>NULL</c>-terminated ASCII string into which the Ws2_32.dll copies relevant status or configuration information. The
            Ws2_32.dll should use this parameter only if the information might be useful to the user or support staff. This member
            should not be considered as an extension of the <c>szDescription</c> parameter.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO">
            <summary>
            <para>The <c>WSAPROTOCOL_INFO</c> structure is used to store or retrieve complete information for a given protocol.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO.dwServiceFlags1">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            A bitmask that describes the services provided by the protocol. The possible values for this member are defined in the
            Winsock2.h header file.
            </para>
            <para>The following values are possible.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>XP1_CONNECTIONLESS 0x00000001</term>
            <term>Provides connectionless (datagram) service. If not set, the protocol supports connection-oriented data transfer.</term>
            </item>
            <item>
            <term>XP1_GUARANTEED_DELIVERY 0x00000002</term>
            <term>Guarantees that all data sent will reach the intended destination.</term>
            </item>
            <item>
            <term>XP1_GUARANTEED_ORDER 0x00000004</term>
            <term>
            Guarantees that data only arrives in the order in which it was sent and that it is not duplicated. This characteristic does
            not necessarily mean that the data is always delivered, but that any data that is delivered is delivered in the order in
            which it was sent.
            </term>
            </item>
            <item>
            <term>XP1_MESSAGE_ORIENTED 0x00000008</term>
            <term>Honors message boundariesas opposed to a stream-oriented protocol where there is no concept of message boundaries.</term>
            </item>
            <item>
            <term>XP1_PSEUDO_STREAM 0x00000010</term>
            <term>
            A message-oriented protocol, but message boundaries are ignored for all receipts. This is convenient when an application
            does not desire message framing to be done by the protocol.
            </term>
            </item>
            <item>
            <term>XP1_GRACEFUL_CLOSE 0x00000020</term>
            <term>Supports two-phase (graceful) close. If not set, only abortive closes are performed.</term>
            </item>
            <item>
            <term>XP1_EXPEDITED_DATA 0x00000040</term>
            <term>Supports expedited (urgent) data.</term>
            </item>
            <item>
            <term>XP1_CONNECT_DATA 0x00000080</term>
            <term>Supports connect data.</term>
            </item>
            <item>
            <term>XP1_DISCONNECT_DATA 0x00000100</term>
            <term>Supports disconnect data.</term>
            </item>
            <item>
            <term>XP1_SUPPORT_BROADCAST 0x00000200</term>
            <term>Supports a broadcast mechanism.</term>
            </item>
            <item>
            <term>XP1_SUPPORT_MULTIPOINT 0x00000400</term>
            <term>Supports a multipoint or multicast mechanism. Control and data plane attributes are indicated below.</term>
            </item>
            <item>
            <term>XP1_MULTIPOINT_CONTROL_PLANE 0x00000800</term>
            <term>Indicates whether the control plane is rooted (value = 1) or nonrooted (value = 0).</term>
            </item>
            <item>
            <term>XP1_MULTIPOINT_DATA_PLANE 0x00001000</term>
            <term>Indicates whether the data plane is rooted (value = 1) or nonrooted (value = 0).</term>
            </item>
            <item>
            <term>XP1_QOS_SUPPORTED 0x00002000</term>
            <term>Supports quality of service requests.</term>
            </item>
            <item>
            <term>XP1_INTERRUPT</term>
            <term>Bit is reserved.</term>
            </item>
            <item>
            <term>XP1_UNI_SEND 0x00008000</term>
            <term>Protocol is unidirectional in the send direction.</term>
            </item>
            <item>
            <term>XP1_UNI_RECV 0x00010000</term>
            <term>Protocol is unidirectional in the recv direction.</term>
            </item>
            <item>
            <term>XP1_IFS_HANDLES 0x00020000</term>
            <term>Socket descriptors returned by the provider are operating system Installable File System (IFS) handles.</term>
            </item>
            <item>
            <term>XP1_PARTIAL_MESSAGE 0x00040000</term>
            <term>The MSG_PARTIAL flag is supported in WSASend and WSASendTo.</term>
            </item>
            <item>
            <term>XP1_SAN_SUPPORT_SDP 0x00080000</term>
            <term>The protocol provides support for SAN. This value is supported on Windows 7 and Windows Server 2008 R2.</term>
            </item>
            </list>
            <para>
            <c>Note</c> Only one of XP1_UNI_SEND or XP1_UNI_RECV values may be set. If a protocol can be unidirectional in either
            direction, two WSAPROTOCOL_INFOW structures should be used. When neither bit is set, the protocol is considered to be bidirectional.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO.dwServiceFlags2">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>Reserved for additional protocol-attribute definitions.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO.dwServiceFlags3">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>Reserved for additional protocol-attribute definitions.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO.dwServiceFlags4">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            A set of flags that provides information on how this protocol is represented in the Winsock catalog. The possible values for
            this member are defined in the Winsock2.h header file.
            </para>
            <para>The following flag values are possible.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>PFL_MULTIPLE_PROTO_ENTRIES 0x00000001</term>
            <term>
            Indicates that this is one of two or more entries for a single protocol (from a given provider) which is capable of
            implementing multiple behaviors. An example of this is SPX which, on the receiving side, can behave either as a
            message-oriented or a stream-oriented protocol.
            </term>
            </item>
            <item>
            <term>PFL_RECOMMENDED_PROTO_ENTRY 0x00000002</term>
            <term>
            Indicates that this is the recommended or most frequently used entry for a protocol that is capable of implementing multiple behaviors.
            </term>
            </item>
            <item>
            <term>PFL_HIDDEN 0x00000004</term>
            <term>
            Set by a provider to indicate to the Ws2_32.dll that this protocol should not be returned in the result buffer generated by
            WSAEnumProtocols. Obviously, a Windows Sockets 2 application should never see an entry with this bit set.
            </term>
            </item>
            <item>
            <term>PFL_MATCHES_PROTOCOL_ZERO 0x00000008</term>
            <term>Indicates that a value of zero in the protocol parameter of socket or WSASocket matches this protocol entry.</term>
            </item>
            <item>
            <term>PFL_NETWORKDIRECT_PROVIDER 0x00000010</term>
            <term>
            Set by a provider to indicate support for network direct access. This value is supported on Windows 7 and Windows Server
            2008 R2.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO.dwProviderFlags">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>Reserved for additional protocol-attribute definitions.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO.ProviderId">
            <summary>
            <para>Type: <c>GUID</c></para>
            <para>
            A globally unique identifier (GUID) assigned to the provider by the service provider vendor. This value is useful for
            instances where more than one service provider is able to implement a particular protocol. An application can use the
            <c>ProviderId</c> member to distinguish between providers that might otherwise be indistinguishable.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO.dwCatalogEntryId">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>A unique identifier assigned by the WS2_32.DLL for each <c>WSAPROTOCOL_INFO</c> structure.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO.ProtocolChain">
            <summary>
            <para>Type: <c>WSAPROTOCOLCHAIN</c></para>
            <para>
            The WSAPROTOCOLCHAIN structure associated with the protocol. If the length of the chain is 0, this <c>WSAPROTOCOL_INFO</c>
            entry represents a layered protocol which has Windows Sockets 2 SPI as both its top and bottom edges. If the length of the
            chain equals 1, this entry represents a base protocol whose Catalog Entry identifier is in the <c>dwCatalogEntryId</c>
            member of the <c>WSAPROTOCOL_INFO</c> structure. If the length of the chain is larger than 1, this entry represents a
            protocol chain which consists of one or more layered protocols on top of a base protocol. The corresponding Catalog Entry
            identifiers are in the ProtocolChain.ChainEntries array starting with the layered protocol at the top (the zero element in
            the ProtocolChain.ChainEntries array) and ending with the base protocol. Refer to the Windows Sockets 2 Service Provider
            Interface specification for more information on protocol chains.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO.iVersion">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The protocol version identifier.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO.iAddressFamily">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            A value to pass as the address family parameter to the socket or WSASocket function in order to open a socket for this
            protocol. This value also uniquely defines the structure of a protocol address for a sockaddr used by the protocol.
            </para>
            <para>
            On the Windows SDK released for Windows Vista and later, the possible values for the address family are defined in the
            Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly.
            </para>
            <para>
            On versions of the Platform SDK for Windows Server 2003 and older, the possible values for the address family are defined in
            the Winsock2.h header file.
            </para>
            <para>
            The values currently supported are AF_INET or AF_INET6, which are the Internet address family formats for IPv4 and IPv6.
            Other options for address family (AF_NETBIOS for use with NetBIOS, for example) are supported if a Windows Sockets service
            provider for the address family is installed. Note that the values for the AF_ address family and PF_ protocol family
            constants are identical (for example, <c>AF_INET</c> and <c>PF_INET</c>), so either constant can be used.
            </para>
            <para>The table below lists common values for address family although many other values are possible.</para>
            <list type="table">
            <listheader>
            <term>iAddressFamily</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AF_INET 2</term>
            <term>The Internet Protocol version 4 (IPv4) address family.</term>
            </item>
            <item>
            <term>AF_IPX 6</term>
            <term>
            The IPX/SPX address family. This address family is only supported if the NWLink IPX/SPX NetBIOS Compatible Transport
            protocol is installed. This address family is not supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AF_APPLETALK 16</term>
            <term>
            The AppleTalk address family. This address family is only supported if the AppleTalk protocol is installed. This address
            family is not supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AF_NETBIOS 17</term>
            <term>
            The NetBIOS address family. This address family is only supported if the Windows Sockets provider for NetBIOS is installed.
            The Windows Sockets provider for NetBIOS is supported on 32-bit versions of Windows. This provider is installed by default
            on 32-bit versions of Windows. The Windows Sockets provider for NetBIOS is not supported on 64-bit versions of windows
            including Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003, or Windows XP. The Windows Sockets provider
            for NetBIOS only supports sockets where the type parameter is set to SOCK_DGRAM. The Windows Sockets provider for NetBIOS is
            not directly related to the NetBIOS programming interface. The NetBIOS programming interface is not supported on Windows
            Vista, Windows Server 2008, and later.
            </term>
            </item>
            <item>
            <term>AF_INET6 23</term>
            <term>The Internet Protocol version 6 (IPv6) address family.</term>
            </item>
            <item>
            <term>AF_IRDA 26</term>
            <term>
            The Infrared Data Association (IrDA) address family. This address family is only supported if the computer has an infrared
            port and driver installed.
            </term>
            </item>
            <item>
            <term>AF_BTH 32</term>
            <term>
            The Bluetooth address family. This address family is supported on Windows XP with SP2 or later if the computer has a
            Bluetooth adapter and driver installed.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO.iMaxSockAddr">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The maximum address length, in bytes.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO.iMinSockAddr">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The minimum address length, in bytes.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO.iSocketType">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            A value to pass as the socket type parameter to the socket or WSASocket function in order to open a socket for this
            protocol. Possible values for the socket type are defined in the Winsock2.h header file.
            </para>
            <para>The following table lists the possible values for the <c>iSocketType</c> member supported for Windows Sockets 2:</para>
            <list type="table">
            <listheader>
            <term>iSocketType</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SOCK_STREAM 1</term>
            <term>
            A socket type that provides sequenced, reliable, two-way, connection-based byte streams with an OOB data transmission
            mechanism. This socket type uses the Transmission Control Protocol (TCP) for the Internet address family (AF_INET or AF_INET6).
            </term>
            </item>
            <item>
            <term>SOCK_DGRAM 2</term>
            <term>
            A socket type that supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum
            length. This socket type uses the User Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).
            </term>
            </item>
            <item>
            <term>SOCK_RAW 3</term>
            <term>
            A socket type that provides a raw socket that allows an application to manipulate the next upper-layer protocol header. To
            manipulate the IPv4 header, the IP_HDRINCL socket option must be set on the socket. To manipulate the IPv6 header, the
            IPV6_HDRINCL socket option must be set on the socket.
            </term>
            </item>
            <item>
            <term>SOCK_RDM 4</term>
            <term>
            A socket type that provides a reliable message datagram. An example of this type is the Pragmatic General Multicast (PGM)
            multicast protocol implementation in Windows, often referred to as reliable multicast programming. This value is only
            supported if the Reliable Multicast Protocol is installed.
            </term>
            </item>
            <item>
            <term>SOCK_SEQPACKET 5</term>
            <term>A socket type that provides a pseudo-stream packet based on datagrams.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO.iProtocol">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            A value to pass as the protocol parameter to the socket or WSASocket function in order to open a socket for this protocol.
            The possible options for the <c>iProtocol</c> member are specific to the address family and socket type specified.
            </para>
            <para>
            On the Windows SDK released for Windows Vista and later, this member can be one of the values from the <c>IPPROTO</c>
            enumeration type defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in
            Winsock2.h, and should never be used directly.
            </para>
            <para>
            On versions of the Platform SDK for Windows Server 2003 and earlier, the possible values for the <c>iProtocol</c> member are
            defined in the Winsock2.h and Wsrm.h header files.
            </para>
            <para>The table below lists common values for the <c>iProtocol</c> although many other values are possible.</para>
            <list type="table">
            <listheader>
            <term>iProtocol</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>IPPROTO_ICMP 1</term>
            <term>The Internet Control Message Protocol (ICMP). This value is supported on Windows XP and later.</term>
            </item>
            <item>
            <term>IPPROTO_IGMP 2</term>
            <term>The Internet Group Management Protocol (IGMP). This value is supported on Windows XP and later.</term>
            </item>
            <item>
            <term>BTHPROTO_RFCOMM 3</term>
            <term>
            The Bluetooth Radio Frequency Communications (Bluetooth RFCOMM) protocol. This value is supported on Windows XP with SP2 or later.
            </term>
            </item>
            <item>
            <term>IPPROTO_TCP 6</term>
            <term>The Transmission Control Protocol (TCP).</term>
            </item>
            <item>
            <term>IPPROTO_UDP 17</term>
            <term>The User Datagram Protocol (UDP).</term>
            </item>
            <item>
            <term>IPPROTO_ICMPV6 58</term>
            <term>The Internet Control Message Protocol Version 6 (ICMPv6). This value is supported on Windows XP and later.</term>
            </item>
            <item>
            <term>IPPROTO_RM 113</term>
            <term>
            The PGM protocol for reliable multicast. On the Windows SDK released for Windows Vista and later, this protocol is also
            called IPPROTO_PGM. This value is only supported if the Reliable Multicast Protocol is installed.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO.iProtocolMaxOffset">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            The maximum value that may be added to <c>iProtocol</c> when supplying a value for the protocol parameter to socket or
            WSASocket function. Not all protocols allow a range of values. When this is the case <c>iProtocolMaxOffset</c> is zero.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO.iNetworkByteOrder">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            Currently these values are manifest constants (BIGENDIAN and LITTLEENDIAN) that indicate either big-endian or little-endian
            with the values 0 and 1 respectively.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO.iSecurityScheme">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            The type of security scheme employed (if any). A value of SECURITY_PROTOCOL_NONE (0) is used for protocols that do not
            incorporate security provisions.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO.dwMessageSize">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            The maximum message size, in bytes, supported by the protocol. This is the maximum size that can be sent from any of the
            host's local interfaces. For protocols that do not support message framing, the actual maximum that can be sent to a given
            address may be less. There is no standard provision to determine the maximum inbound message size. The following special
            values are defined.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>The protocol is stream-oriented and hence the concept of message size is not relevant.</term>
            </item>
            <item>
            <term>0x1</term>
            <term>
            The maximum outbound (send) message size is dependent on the underlying network MTU (maximum sized transmission unit) and
            hence cannot be known until after a socket is bound. Applications should use getsockopt to retrieve the value of
            SO_MAX_MSG_SIZE after the socket has been bound to a local address.
            </term>
            </item>
            <item>
            <term>0xFFFFFFFF</term>
            <term>The protocol is message-oriented, but there is no maximum limit to the size of messages that may be transmitted.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO.dwProviderReserved">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>Reserved for use by service providers.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO.szProtocol">
            <summary>
            <para>Type: <c>TCHAR[WSAPROTOCOL_LEN+1]</c></para>
            <para>
            An array of characters that contains a human-readable name identifying the protocol, for example "MSAFD Tcpip [UDP/IP]". The
            maximum number of characters allowed is WSAPROTOCOL_LEN, which is defined to be 255.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WSAPROTOCOLCHAIN">
            <summary>
            <para>The <c>WSAPROTOCOLCHAIN</c> structure contains a counted list of Catalog Entry identifiers that comprise a protocol chain.</para>
            </summary>
            <remarks>
            <para>
            If the length of the chain is larger than 1, this structure represents a protocol chain which consists of one or more layered
            protocols on top of a base protocol. The corresponding Catalog Entry IDs are in the ProtocolChain.ChainEntries array starting
            with the layered protocol at the top (the zeroth element in the ProtocolChain.ChainEntries array) and ending with the base
            protocol. Refer to Windows Sockets 2 Service Provider Interface for more information on protocol chains.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOLCHAIN.ChainLen">
            <summary>
            <para>Length of the chain, in bytes. The following settings apply:</para>
            <para>Setting <c>ChainLen</c> to zero indicates a layered protocol</para>
            <para>Setting <c>ChainLen</c> to one indicates a base protocol</para>
            <para>Setting <c>ChainLen</c> to greater than one indicates a protocol chain</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOLCHAIN.ChainEntries">
            <summary>
            <para>Array of protocol chain entries.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SafeSOCKET">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> for <see cref="T:Vanara.PInvoke.Ws2_32.SOCKET"/> that is disposed using <see cref="M:Vanara.PInvoke.Ws2_32.closesocket(Vanara.PInvoke.Ws2_32.SOCKET)"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SafeSOCKET.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.SafeSOCKET"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SafeSOCKET.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.SafeSOCKET"/> class.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.SafeSOCKET.INVALID_SOCKET">
            <summary>Represents an invalid socket which is different than a null socket.</summary>
            <value>The invalid socket.</value>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.SafeSOCKET.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.Ws2_32.SafeSOCKET"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
            <value>Returns a <see cref="T:Vanara.PInvoke.Ws2_32.SafeSOCKET"/> value.</value>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SafeSOCKET.op_Implicit(Vanara.PInvoke.Ws2_32.SafeSOCKET)~Vanara.PInvoke.Ws2_32.SOCKET">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.SafeSOCKET"/> to <see cref="T:Vanara.PInvoke.Ws2_32.SOCKET"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SafeSOCKET.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SOCKADDR">
            <summary>
            <para>
            The sockaddr structure varies depending on the protocol selected. Except for the sin*_family parameter, sockaddr contents are
            expressed in network byte order.
            </para>
            <para>
            Winsock functions using sockaddr are not strictly interpreted to be pointers to a sockaddr structure. The structure is
            interpreted differently in the context of different address families. The only requirements are that the first <c>u_short</c> is
            the address family and the total size of the memory buffer in bytes is namelen.
            </para>
            <para>
            The <c>SOCKADDR_STORAGE</c> structure also stores socket address information and the structure is sufficiently large to store
            IPv4 or IPv6 address information. The use of the <c>SOCKADDR_STORAGE</c> structure promotes protocol-family and protocol-version
            independence, and simplifies development. It is recommended that the <c>SOCKADDR_STORAGE</c> structure be used in place of the
            sockaddr structure. The <c>SOCKADDR_STORAGE</c> structure is supported on Windows Server 2003 and later.
            </para>
            <para>The sockaddr structure and sockaddr_in structures below are used with IPv4. Other protocols use similar structures.</para>
            <para>The sockaddr_in6 and sockaddr_in6_old structures below are used with IPv6.</para>
            <para>
            On the Microsoft Windows Software Development Kit (SDK) released for Windows Vista and later, <c>SOCKADDR</c> and
            <c>SOCKADDR_IN</c> typedef tags are defined for sockaddr and sockaddr_in structures as follows:
            </para>
            <para>
            On the Windows SDK released for Windows Vista and later, the organization of header files has changed and the sockaddr and
            sockaddr_in structures are defined in the Ws2def.h header file, not the Winsock2.h header file. The Ws2def.h header file is
            automatically included by the Winsock2.h header file. The sockaddr_in6 structure is defined in the Ws2ipdef.h header file, not
            the Ws2tcpip.h header file. The Ws2ipdef.h header file is automatically included by the Ws2tcpip.h header file. The Ws2def.h and
            Ws2ipdef.h header files should never be used directly.
            </para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR.#ctor(System.IntPtr,System.Boolean,System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR"/> class.</summary>
            <param name="handle">The handle to the memory with the address.</param>
            <param name="ownsHandle">if set to <see langword="true"/> this class with dispose the memory.</param>
            <param name="size">The size of the memory pointed to by <paramref name="handle"/>.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR.#ctor(System.UInt32,System.UInt16)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR"/> class.</summary>
            <param name="addr">The IPv4 address value.</param>
            <param name="port">The port.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR.#ctor(System.Byte[],System.UInt16,System.UInt32)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR"/> class.</summary>
            <param name="addr">The IPv4 or IPv6 address as a byte array.</param>
            <param name="port">The port.</param>
            <param name="scopeId">The scope identifier for IPv6 addresses.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">addr</exception>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR.#ctor(Vanara.PInvoke.Ws2_32.SOCKADDR_IN)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR"/> class.</summary>
            <param name="addr">The <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN"/> value to assign.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR.#ctor(Vanara.PInvoke.Ws2_32.SOCKADDR_IN6)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR"/> class.</summary>
            <param name="addr">The <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6"/> value to assign.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR.#ctor(System.Net.IPAddress)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR"/> class.</summary>
            <param name="ipAddress">The ip address.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR.#ctor(System.Net.IPEndPoint)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR"/> class.</summary>
            <param name="endPoint">The socket address.</param>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.SOCKADDR.Empty">
            <summary>Gets an instance that represents an empty address.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR.GetAddressBytes">
            <summary>Provides a copy of <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR"/> as an array of bytes.</summary>
            <value>The array of bytes from this instance.</value>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.SOCKADDR.sa_data">
            <summary>Gets the data behind this address as a byte array.</summary>
            <value>The address data.</value>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.SOCKADDR.sa_family">
            <summary>Gets the <see cref="T:Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY"/> of this address.</summary>
            <value>The address family.</value>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR.CreateFromStructure``1(``0)">
            <summary>Allocates from unmanaged memory sufficient memory to hold an object of type T.</summary>
            <typeparam name="T">Native type</typeparam>
            <param name="value">The value.</param>
            <returns><see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR"/> object to an native (unmanaged) memory block the size of T.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR.op_Explicit(Vanara.PInvoke.Ws2_32.SOCKADDR)~Vanara.PInvoke.Ws2_32.SOCKADDR_IN">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR"/> to <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN"/>.</summary>
            <param name="addr">The address.</param>
            <returns>The resulting <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN"/> instance from the conversion.</returns>
            <exception cref="T:System.InvalidCastException"></exception>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR.op_Explicit(Vanara.PInvoke.Ws2_32.SOCKADDR)~Vanara.PInvoke.Ws2_32.SOCKADDR_IN6">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR"/> to <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6"/>.</summary>
            <param name="addr">The address.</param>
            <returns>The resulting <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6"/> instance from the conversion.</returns>
            <exception cref="T:System.InvalidCastException"></exception>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR.op_Implicit(Vanara.PInvoke.Ws2_32.SOCKADDR_IN)~Vanara.PInvoke.Ws2_32.SOCKADDR">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN"/> to <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR"/>.</summary>
            <param name="addr">The address.</param>
            <returns>The resulting <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR"/> instance from the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR.op_Implicit(Vanara.PInvoke.Ws2_32.SOCKADDR_IN6)~Vanara.PInvoke.Ws2_32.SOCKADDR">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6"/> to <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR"/>.</summary>
            <param name="addr">The address.</param>
            <returns>The resulting <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR"/> instance from the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR.op_Implicit(Vanara.PInvoke.Ws2_32.SOCKADDR)~System.IntPtr">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="addr">The address.</param>
            <returns>The resulting <see cref="T:System.IntPtr"/> instance from the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SD">
            <summary>A flag that describes what types of operation will no longer be allowed.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SD.SD_RECEIVE">
            <summary>Shutdown receive operations.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SD.SD_SEND">
            <summary>Shutdown send operations.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SD.SD_BOTH">
            <summary>Shutdown both send and receive operations.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.accept(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.SOCKADDR,System.Int32@)">
            <summary>The <c>accept</c> function permits an incoming connection attempt on a socket.</summary>
            <param name="s">
            A descriptor that identifies a socket that has been placed in a listening state with the listen function. The connection is
            actually made with the socket that is returned by <c>accept</c>.
            </param>
            <param name="addr">
            An optional pointer to a buffer that receives the address of the connecting entity, as known to the communications layer. The
            exact format of the addr parameter is determined by the address family that was established when the socket from the sockaddr
            structure was created.
            </param>
            <param name="addrlen">An optional pointer to an integer that contains the length of structure pointed to by the addr parameter.</param>
            <returns>
            <para>
            If no error occurs, <c>accept</c> returns a value of type <c>SOCKET</c> that is a descriptor for the new socket. This returned
            value is a handle for the socket on which the actual connection is made.
            </para>
            <para>Otherwise, a value of <c>INVALID_SOCKET</c> is returned, and a specific error code can be retrieved by calling WSAGetLastError.</para>
            <para>
            The integer referred to by addrlen initially contains the amount of space pointed to by addr. On return it will contain the
            actual length in bytes of the address returned.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAECONNRESET</term>
            <term>An incoming connection was indicated, but was subsequently terminated by the remote peer prior to accepting the call.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The addrlen parameter is too small or addr is not a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>A blocking Windows Sockets 1.1 call was canceled through WSACancelBlockingCall.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>The listen function was not invoked prior to accept.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEMFILE</term>
            <term>The queue is nonempty upon entry to accept and there are no descriptors available.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>No buffer space is available.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>The referenced socket is not a type that supports connection-oriented service.</term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>The socket is marked as nonblocking and no connections are present to be accepted.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>accept</c> function extracts the first connection on the queue of pending connections on socket s. It then creates and
            returns a handle to the new socket. The newly created socket is the socket that will handle the actual connection; it has the
            same properties as socket s, including the asynchronous events registered with the WSAAsyncSelect or WSAEventSelect functions.
            </para>
            <para>
            The <c>accept</c> function can block the caller until a connection is present if no pending connections are present on the
            queue, and the socket is marked as blocking. If the socket is marked as nonblocking and no pending connections are present on
            the queue, <c>accept</c> returns an error as described in the following. After the successful completion of <c>accept</c>
            returns a new socket handle, the accepted socket cannot be used to accept more connections. The original socket remains open and
            listens for new connection requests.
            </para>
            <para>
            The parameter addr is a result parameter that is filled in with the address of the connecting entity, as known to the
            communications layer. The exact format of the addr parameter is determined by the address family in which the communication is
            occurring. The addrlen is a value-result parameter; it should initially contain the amount of space pointed to by addr; on
            return it will contain the actual length (in bytes) of the address returned.
            </para>
            <para>
            The <c>accept</c> function is used with connection-oriented socket types such as SOCK_STREAM. If addr and/or addrlen are equal
            to <c>NULL</c>, then no information about the remote address of the accepted socket is returned.
            </para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>accept</c>, Winsock may need to wait for a network event before the
            call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure
            call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing
            blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients.
            </para>
            <para>Example Code</para>
            <para>The following example demonstrates the use of the <c>accept</c> function.</para>
            <para>For another example that uses the <c>accept</c> function, see Getting Started With Winsock.</para>
            <para>Notes for ATM</para>
            <para>
            The following are important issues associated with connection setup, and must be considered when using Asynchronous Transfer
            Mode (ATM) with Windows Sockets 2:
            </para>
            <list type="bullet">
            <item>
            <term>
            The <c>accept</c> and WSAAccept functions do not necessarily set the remote address and address length parameters. Therefore,
            when using ATM, the caller should use the <c>WSAAccept</c> function and place ATM_CALLING_PARTY_NUMBER_IE in the
            <c>ProviderSpecific</c> member of the QoS structure, which itself is included in the lpSQOS parameter of the callback function
            used in accordance with <c>WSAAccept</c>.
            </term>
            </item>
            <item>
            <term>
            When using the <c>accept</c> function, realize that the function may return before connection establishment has traversed the
            entire distance between sender and receiver. This is because the <c>accept</c> function returns as soon as it receives a CONNECT
            ACK message; in ATM, a CONNECT ACK message is returned by the next switch in the path as soon as a CONNECT message is processed
            (rather than the CONNECT ACK being sent by the end node to which the connection is ultimately established). As such,
            applications should realize that if data is sent immediately following receipt of a CONNECT ACK message, data loss is possible,
            since the connection may not have been established all the way between sender and receiver.
            </term>
            </item>
            </list>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.accept(Vanara.PInvoke.Ws2_32.SOCKET,System.IntPtr,System.IntPtr)">
            <summary>The <c>accept</c> function permits an incoming connection attempt on a socket.</summary>
            <param name="s">
            A descriptor that identifies a socket that has been placed in a listening state with the listen function. The connection is
            actually made with the socket that is returned by <c>accept</c>.
            </param>
            <param name="addr">
            An optional pointer to a buffer that receives the address of the connecting entity, as known to the communications layer. The
            exact format of the addr parameter is determined by the address family that was established when the socket from the sockaddr
            structure was created.
            </param>
            <param name="addrlen">An optional pointer to an integer that contains the length of structure pointed to by the addr parameter.</param>
            <returns>
            <para>
            If no error occurs, <c>accept</c> returns a value of type <c>SOCKET</c> that is a descriptor for the new socket. This returned
            value is a handle for the socket on which the actual connection is made.
            </para>
            <para>Otherwise, a value of <c>INVALID_SOCKET</c> is returned, and a specific error code can be retrieved by calling WSAGetLastError.</para>
            <para>
            The integer referred to by addrlen initially contains the amount of space pointed to by addr. On return it will contain the
            actual length in bytes of the address returned.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAECONNRESET</term>
            <term>An incoming connection was indicated, but was subsequently terminated by the remote peer prior to accepting the call.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The addrlen parameter is too small or addr is not a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>A blocking Windows Sockets 1.1 call was canceled through WSACancelBlockingCall.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>The listen function was not invoked prior to accept.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEMFILE</term>
            <term>The queue is nonempty upon entry to accept and there are no descriptors available.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>No buffer space is available.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>The referenced socket is not a type that supports connection-oriented service.</term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>The socket is marked as nonblocking and no connections are present to be accepted.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>accept</c> function extracts the first connection on the queue of pending connections on socket s. It then creates and
            returns a handle to the new socket. The newly created socket is the socket that will handle the actual connection; it has the
            same properties as socket s, including the asynchronous events registered with the WSAAsyncSelect or WSAEventSelect functions.
            </para>
            <para>
            The <c>accept</c> function can block the caller until a connection is present if no pending connections are present on the
            queue, and the socket is marked as blocking. If the socket is marked as nonblocking and no pending connections are present on
            the queue, <c>accept</c> returns an error as described in the following. After the successful completion of <c>accept</c>
            returns a new socket handle, the accepted socket cannot be used to accept more connections. The original socket remains open and
            listens for new connection requests.
            </para>
            <para>
            The parameter addr is a result parameter that is filled in with the address of the connecting entity, as known to the
            communications layer. The exact format of the addr parameter is determined by the address family in which the communication is
            occurring. The addrlen is a value-result parameter; it should initially contain the amount of space pointed to by addr; on
            return it will contain the actual length (in bytes) of the address returned.
            </para>
            <para>
            The <c>accept</c> function is used with connection-oriented socket types such as SOCK_STREAM. If addr and/or addrlen are equal
            to <c>NULL</c>, then no information about the remote address of the accepted socket is returned.
            </para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>accept</c>, Winsock may need to wait for a network event before the
            call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure
            call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing
            blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients.
            </para>
            <para>Example Code</para>
            <para>The following example demonstrates the use of the <c>accept</c> function.</para>
            <para>For another example that uses the <c>accept</c> function, see Getting Started With Winsock.</para>
            <para>Notes for ATM</para>
            <para>
            The following are important issues associated with connection setup, and must be considered when using Asynchronous Transfer
            Mode (ATM) with Windows Sockets 2:
            </para>
            <list type="bullet">
            <item>
            <term>
            The <c>accept</c> and WSAAccept functions do not necessarily set the remote address and address length parameters. Therefore,
            when using ATM, the caller should use the <c>WSAAccept</c> function and place ATM_CALLING_PARTY_NUMBER_IE in the
            <c>ProviderSpecific</c> member of the QoS structure, which itself is included in the lpSQOS parameter of the callback function
            used in accordance with <c>WSAAccept</c>.
            </term>
            </item>
            <item>
            <term>
            When using the <c>accept</c> function, realize that the function may return before connection establishment has traversed the
            entire distance between sender and receiver. This is because the <c>accept</c> function returns as soon as it receives a CONNECT
            ACK message; in ATM, a CONNECT ACK message is returned by the next switch in the path as soon as a CONNECT message is processed
            (rather than the CONNECT ACK being sent by the end node to which the connection is ultimately established). As such,
            applications should realize that if data is sent immediately following receipt of a CONNECT ACK message, data loss is possible,
            since the connection may not have been established all the way between sender and receiver.
            </term>
            </item>
            </list>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.bind(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.SOCKADDR,System.Int32)">
            <summary>The <c>bind</c> function associates a local address with a socket.</summary>
            <param name="s">A descriptor identifying an unbound socket.</param>
            <param name="addr">TBD</param>
            <param name="namelen">The length, in bytes, of the value pointed to by the name parameter.</param>
            <returns>
            <para>
            If no error occurs, <c>bind</c> returns zero. Otherwise, it returns SOCKET_ERROR, and a specific error code can be retrieved by
            calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term></term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEACCES</term>
            <term>
            An attempt was made to access a socket in a way forbidden by its access permissions. This error is returned if nn attempt to
            bind a datagram socket to the broadcast address failed because the setsockopt option SO_BROADCAST is not enabled.
            </term>
            </item>
            <item>
            <term>WSAEADDRINUSE</term>
            <term>
            Only one usage of each socket address (protocol/network address/port) is normally permitted. This error is returned if a process
            on the computer is already bound to the same fully qualified address and the socket has not been marked to allow address reuse
            with SO_REUSEADDR. For example, the IP address and port specified in the name parameter are already bound to another socket
            being used by another application. For more information, see the SO_REUSEADDR socket option in the SOL_SOCKET Socket Options
            reference, Using SO_REUSEADDR and SO_EXCLUSIVEADDRUSE, and SO_EXCLUSIVEADDRUSE.
            </term>
            </item>
            <item>
            <term>WSAEADDRNOTAVAIL</term>
            <term>
            The requested address is not valid in its context. This error is returned if the specified address pointed to by the name
            parameter is not a valid local IP address on this computer.
            </term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The system detected an invalid pointer address in attempting to use a pointer argument in a call. This error is returned if the
            name parameter is NULL, the name or namelen parameter is not a valid part of the user address space, the namelen parameter is
            too small, the name parameter contains an incorrect address format for the associated address family, or the first two bytes of
            the memory block specified by name do not match the address family associated with the socket descriptor s.
            </term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>An invalid argument was supplied. This error is returned of the socket s is already bound to an address.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>
            An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full.
            This error is returned of not enough buffers are available or there are too many connections.
            </term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>
            An operation was attempted on something that is not a socket. This error is returned if the descriptor in the s parameter is not
            a socket.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>bind</c> function is required on an unconnected socket before subsequent calls to the listen function. It is normally
            used to bind to either connection-oriented (stream) or connectionless (datagram) sockets. The <c>bind</c> function may also be
            used to bind to a raw socket (the socket was created by calling the socketfunction with the type parameter set to SOCK_RAW). The
            <c>bind</c> function may also be used on an unconnected socket before subsequent calls to the connect, ConnectEx, WSAConnect,
            WSAConnectByList, or WSAConnectByName functions before send operations.
            </para>
            <para>
            When a socket is created with a call to the socket function, it exists in a namespace (address family), but it has no name
            assigned to it. Use the <c>bind</c> function to establish the local association of the socket by assigning a local name to an
            unnamed socket.
            </para>
            <para>A name consists of three parts when using the Internet address family:</para>
            <list type="bullet">
            <item>
            <term>The address family.</term>
            </item>
            <item>
            <term>A host address.</term>
            </item>
            <item>
            <term>A port number that identifies the application.</term>
            </item>
            </list>
            <para>
            In Windows Sockets 2, the name parameter is not strictly interpreted as a pointer to a sockaddr structure. It is cast this way
            for Windows Sockets 1.1 compatibility. Service providers are free to regard it as a pointer to a block of memory of size
            namelen. The first 2 bytes in this block (corresponding to the <c>sa_family</c> member of the <c>sockaddr</c> structure, the
            <c>sin_family</c> member of the <c>sockaddr_in</c> structure, or the <c>sin6_family</c> member of the <c>sockaddr_in6</c>
            structure) must contain the address family that was used to create the socket. Otherwise, an error WSAEFAULT occurs.
            </para>
            <para>
            If an application does not care what local address is assigned, specify the constant value <c>INADDR_ANY</c> for an IPv4 local
            address or the constant value <c>in6addr_any</c> for an IPv6 local address in the <c>sa_data</c> member of the name parameter.
            This allows the underlying service provider to use any appropriate network address, potentially simplifying application
            programming in the presence of multihomed hosts (that is, hosts that have more than one network interface and address).
            </para>
            <para>
            For TCP/IP, if the port is specified as zero, the service provider assigns a unique port to the application from the dynamic
            client port range. On Windows Vista and later, the dynamic client port range is a value between 49152 and 65535. This is a
            change from Windows Server 2003 and earlier where the dynamic client port range was a value between 1025 and 5000. The maximum
            value for the client dynamic port range can be changed by setting a value under the following registry key:
            </para>
            <para><c>HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters</c></para>
            <para>
            The <c>MaxUserPort</c> registry value sets the value to use for the maximum value of the dynamic client port range. You must
            restart the computer for this setting to take effect.
            </para>
            <para>
            On Windows Vista and later, the dynamic client port range can be viewed and changed using <c>netsh</c> commands. The dynamic
            client port range can be set differently for UDP and TCP and also for IPv4 and IPv6. For more information, see KB 929851.
            </para>
            <para>
            The application can use getsockname after calling <c>bind</c> to learn the address and the port that has been assigned to the
            socket. If the Internet address is equal to <c>INADDR_ANY</c> or <c>in6addr_any</c>, <c>getsockname</c> cannot necessarily
            supply the address until the socket is connected, since several addresses can be valid if the host is multihomed. Binding to a
            specific port number other than port 0 is discouraged for client applications, since there is a danger of conflicting with
            another socket already using that port number on the local computer.
            </para>
            <para>
            For multicast operations, the preferred method is to call the <c>bind</c> function to associate a socket with a local IP address
            and then join the multicast group. Although this order of operations is not mandatory, it is strongly recommended. So a
            multicast application would first select an IPv4 or IPv6 address on the local computer, the wildcard IPv4 address (
            <c>INADDR_ANY</c>), or the wildcard IPv6 address ( <c>in6addr_any</c>). The the multicast application would then call the
            <c>bind</c> function with this address in the in the <c>sa_data</c> member of the name parameter to associate the local IP
            address with the socket. If a wildcard address was specified, then Windows will select the local IP address to use. After the
            <c>bind</c> function completes, an application would then join the multicast group of interest. For more information on how to
            join a multicast group, see the section on Multicast Programming. This socket can then be used to receive multicast packets from
            the multicast group using the recv, recvfrom, WSARecv, WSARecvEx, WSARecvFrom, or WSARecvMsg functions.
            </para>
            <para>
            The <c>bind</c> function is not normally required for send operations to a multicast group. The sendto,WSASendMsg, and WSASendTo
            functions implicitly bind the socket to the wildcard address if the socket is not already bound. The <c>bind</c> function is
            required before the use of the send or WSASend functions which do not perform an implicit bind and are allowed only on connected
            sockets, which means the socket must have already been bound for it to be connected. The <c>bind</c> function might be used
            before send operations using the <c>sendto</c>, <c>WSASendMsg</c>, or <c>WSASendTo</c> functions if an application wanted to
            select a specific local IP address on a local computer with multiple network interfaces and local IP addresses. Otherwise an
            implicit bind to the wildcard address using the <c>sendto</c>, <c>WSASendMsg</c> , or <c>WSASendTo</c> functions might result in
            a different local IP address being used for send operations.
            </para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>bind</c>, Winsock may need to wait for a network event before the
            call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure
            call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing
            blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients.
            </para>
            <para>Notes for IrDA Sockets</para>
            <list type="bullet">
            <item>
            <term>The Af_irda.h header file must be explicitly included.</term>
            </item>
            <item>
            <term>
            Local names are not exposed in IrDA. IrDA client sockets therefore, must never call the <c>bind</c> function before the connect
            function. If the IrDA socket was previously bound to a service name using <c>bind</c>, the <c>connect</c> function will fail
            with SOCKET_ERROR.
            </term>
            </item>
            <item>
            <term>
            If the service name is of the form "LSAP-SELxxx," where xxx is a decimal integer in the range 1-127, the address indicates a
            specific LSAP-SEL xxx rather than a service name. Service names such as these allow server applications to accept incoming
            connections directed to a specific LSAP-SEL, without first performing an ISA service name query to get the associated LSAP-SEL.
            One example of this service name type is a non-Windows device that does not support IAS.
            </term>
            </item>
            </list>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            <para>Examples</para>
            <para>
            The following example demonstrates the use of the <c>bind</c> function. For another example that uses the <c>bind</c> function,
            see Getting Started With Winsock.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.closesocket(Vanara.PInvoke.Ws2_32.SOCKET)">
            <summary>The <c>closesocket</c> function closes an existing socket.</summary>
            <param name="s">A descriptor identifying the socket to close.</param>
            <returns>
            <para>
            If no error occurs, <c>closesocket</c> returns zero. Otherwise, a value of <c>SOCKET_ERROR</c> is returned, and a specific error
            code can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>The (blocking) Windows Socket 1.1 call was canceled through WSACancelBlockingCall.</term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>
            The socket is marked as nonblocking, but the l_onoff member of the linger structure is set to nonzero and the l_linger member of
            the linger structure is set to a nonzero timeout value.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>closesocket</c> function closes a socket. Use it to release the socket descriptor passed in the s parameter. Note that
            the socket descriptor passed in the s parameter may immediately be reused by the system as soon as <c>closesocket</c> function
            is issued. As a result, it is not reliable to expect further references to the socket descriptor passed in the s parameter to
            fail with the error WSAENOTSOCK. A Winsock client must never issue <c>closesocket</c> on s concurrently with another Winsock
            function call.
            </para>
            <para>
            Any pending overlapped send and receive operations ( WSASend/ WSASendTo/ WSARecv/ WSARecvFrom with an overlapped socket) issued
            by any thread in this process are also canceled. Any event, completion routine, or completion port action specified for these
            overlapped operations is performed. The pending overlapped operations fail with the error status WSA_OPERATION_ABORTED.
            </para>
            <para>
            An application should not assume that any outstanding I/O operations on a socket will all be guaranteed to completed when
            <c>closesocket</c> returns. The <c>closesocket</c> function will initiate cancellation on the outstanding I/O operations, but
            that does not mean that an application will receive I/O completion for these I/O operations by the time the <c>closesocket</c>
            function returns. Thus, an application should not cleanup any resources (WSAOVERLAPPED structures, for example) referenced by
            the outstanding I/O requests until the I/O requests are indeed completed.
            </para>
            <para>
            An application should always have a matching call to <c>closesocket</c> for each successful call to socket to return any socket
            resources to the system.
            </para>
            <para>
            The linger structure maintains information about a specific socket that specifies how that socket should behave when data is
            queued to be sent and the <c>closesocket</c> function is called on the socket.
            </para>
            <para>
            The <c>l_onoff</c> member of the <c>linger</c> structure determines whether a socket should remain open for a specified amount
            of time after a <c>closesocket</c> function call to enable queued data to be sent. This member can be modified in two ways:
            </para>
            <list type="bullet">
            <item>
            <term>
            Call the setsockopt function with the optname parameter set to <c>SO_DONTLINGER</c>. The optval parameter determines how the
            <c>l_onoff</c> member is modified.
            </term>
            </item>
            <item>
            <term>
            Call the setsockopt function with the optname parameter set to <c>SO_LINGER</c>. The optval parameter specifies how both the
            <c>l_onoff</c> and <c>l_linger</c> members are modified.
            </term>
            </item>
            </list>
            <para>
            The <c>l_linger</c> member of the <c>linger</c> structure determines the amount of time, in seconds, a socket should remain
            open. This member is only applicable if the <c>l_onoff</c> member of the <c>linger</c> structure is nonzero.
            </para>
            <para>
            The default parameters for a socket are the <c>l_onoff</c> member of the <c>linger</c> structure is zero, indicating that the
            socket should not remain open. The default value for the <c>l_linger</c> member of the <c>linger</c> structure is zero, but this
            value is ignored when the <c>l_onoff</c> member is set to zero.
            </para>
            <para>
            To enable a socket to remain open, an application should set the <c>l_onoff</c> member to a nonzero value and set the
            <c>l_linger</c> member to the desired timeout in seconds. To disable a socket from remaining open, an application only needs to
            set the <c>l_onoff</c> member of the <c>linger</c> structure to zero.
            </para>
            <para>
            If an application calls the setsockopt function with the optname parameter set to <c>SO_DONTLINGER</c> to set the <c>l_onoff</c>
            member to a nonzero value, the value for the <c>l_linger</c> member is not specified. In this case, the timeout used is
            implementation dependent. If a previous timeout has been established for a socket (by previously calling the <c>setsockopt</c>
            function with the optname parameter set to <c>SO_LINGER</c>), this timeout value should be reinstated by the service provider.
            </para>
            <para>
            The semantics of the <c>closesocket</c> function are affected by the socket options that set members of <c>linger</c> structure.
            </para>
            <list type="table">
            <listheader>
            <term>l_onoff</term>
            <term>l_linger</term>
            <term>Type of close</term>
            <term>Wait for close?</term>
            </listheader>
            <item>
            <term>zero</term>
            <term>Do not care</term>
            <term>Graceful close</term>
            <term>No</term>
            </item>
            <item>
            <term>nonzero</term>
            <term>zero</term>
            <term>Hard</term>
            <term>No</term>
            </item>
            <item>
            <term>nonzero</term>
            <term>nonzero</term>
            <term>
            Graceful if all data is sent within timeout value specified in the l_linger member. Hard if all data could not be sent within
            timeout value specified in the l_linger member.
            </term>
            <term>Yes</term>
            </item>
            </list>
            <para>
            If the <c>l_onoff</c> member of the LINGER structure is zero on a stream socket, the <c>closesocket</c> call will return
            immediately and does not receive WSAEWOULDBLOCK whether the socket is blocking or nonblocking. However, any data queued for
            transmission will be sent, if possible, before the underlying socket is closed. This is also called a graceful disconnect or
            close. In this case, the Windows Sockets provider cannot release the socket and other resources for an arbitrary period, thus
            affecting applications that expect to use all available sockets. This is the default behavior for a socket.
            </para>
            <para>
            If the <c>l_onoff</c> member of the linger structure is nonzero and <c>l_linger</c> member is zero, <c>closesocket</c> is not
            blocked even if queued data has not yet been sent or acknowledged. This is called a hard or abortive close, because the socket's
            virtual circuit is reset immediately, and any unsent data is lost. On Windows, any <c>recv</c> call on the remote side of the
            circuit will fail with WSAECONNRESET.
            </para>
            <para>
            If the <c>l_onoff</c> member of the linger structure is set to nonzero and <c>l_linger</c> member is set to a nonzero timeout on
            a blocking socket, the <c>closesocket</c> call blocks until the remaining data has been sent or until the timeout expires. This
            is called a graceful disconnect or close if all of the data is sent within timeout value specified in the <c>l_linger</c>
            member. If the timeout expires before all data has been sent, the Windows Sockets implementation terminates the connection
            before <c>closesocket</c> returns and this is called a hard or abortive close.
            </para>
            <para>
            Setting the <c>l_onoff</c> member of the linger structure to nonzero and the <c>l_linger</c> member with a nonzero timeout
            interval on a nonblocking socket is not recommended. In this case, the call to <c>closesocket</c> will fail with an error of
            WSAEWOULDBLOCK if the close operation cannot be completed immediately. If <c>closesocket</c> fails with WSAEWOULDBLOCK the
            socket handle is still valid, and a disconnect is not initiated. The application must call <c>closesocket</c> again to close the socket.
            </para>
            <para>
            If the <c>l_onoff</c> member of the linger structure is nonzero and the <c>l_linger</c> member is a nonzero timeout interval on
            a blocking socket, the result of the <c>closesocket</c> function can't be used to determine whether all data has been sent to
            the peer. If the data is sent before the timeout specified in the <c>l_linger</c> member expires or if the connection was
            aborted, the <c>closesocket</c> function won't return an error code (the return value from the <c>closesocket</c> function is zero).
            </para>
            <para>
            The <c>closesocket</c> call will only block until all data has been delivered to the peer or the timeout expires. If the
            connection is reset because the timeout expires, then the socket will not go into TIME_WAIT state. If all data is sent within
            the timeout period, then the socket can go into TIME_WAIT state.
            </para>
            <para>
            If the <c>l_onoff</c> member of the linger structure is nonzero and the <c>l_linger</c> member is a zero timeout interval on a
            blocking socket, then a call to <c>closesocket</c> will reset the connection. The socket will not go to the TIME_WAIT state.
            </para>
            <para>
            The getsockopt function can be called with the optname parameter set to <c>SO_LINGER</c> to retrieve the current value of the
            <c>linger</c> structure associated with a socket.
            </para>
            <para>
            <c>Note</c> To assure that all data is sent and received on a connection, an application should call shutdown before calling
            <c>closesocket</c> (see Graceful shutdown, linger options, and socket closure for more information). Also note, an FD_CLOSE
            network event is not posted after <c>closesocket</c> is called.
            </para>
            <para>Here is a summary of <c>closesocket</c> behavior:</para>
            <list type="bullet">
            <item>
            <term>
            If the <c>l_onoff</c> member of the LINGER structure is zero (the default for a socket), <c>closesocket</c> returns immediately
            and the connection is gracefully closed in the background.
            </term>
            </item>
            <item>
            <term>
            If the <c>l_onoff</c> member of the linger structure is set to nonzero and the <c>l_linger</c> member is set to zero (no
            timeout) <c>closesocket</c> returns immediately and the connection is reset or terminated.
            </term>
            </item>
            <item>
            <term>
            If the <c>l_onoff</c> member of the linger structure is set to nonzero and the <c>l_linger</c> member is set to a nonzero
            timeout: For a blocking socket, <c>closesocket</c> blocks until all data is sent or the timeout expires.
            </term>
            </item>
            </list>
            <para>For additional information please see Graceful Shutdown, Linger Options, and Socket Closure for more information.</para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>closesocket</c>, Winsock may need to wait for a network event before
            the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous
            procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an
            ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients.
            </para>
            <para>Notes for IrDA Sockets</para>
            <para>Keep the following in mind:</para>
            <list type="bullet">
            <item>
            <term>The Af_irda.h header file must be explicitly included.</term>
            </item>
            <item>
            <term>The standard linger options are supported.</term>
            </item>
            <item>
            <term>
            Although IrDA does not provide a graceful close, IrDA will defer closing until receive queues are purged. Thus, an application
            can send data and immediately call the socket function, and be confident that the receiver will copy the data before receiving
            an FD_CLOSE message.
            </term>
            </item>
            </list>
            <para>Notes for ATM</para>
            <para>
            The following are important issues associated with connection teardown when using Asynchronous Transfer Mode (ATM) and Windows
            Sockets 2:
            </para>
            <list type="bullet">
            <item>
            <term>
            Using the <c>closesocket</c> or shutdown functions with SD_SEND or SD_BOTH results in a RELEASE signal being sent out on the
            control channel. Due to ATM's use of separate signal and data channels, it is possible that a RELEASE signal could reach the
            remote end before the last of the data reaches its destination, resulting in a loss of that data. One possible solutions is
            programming a sufficient delay between the last data sent and the <c>closesocket</c> or shutdown function calls for an ATM socket.
            </term>
            </item>
            <item>
            <term>Half close is not supported by ATM.</term>
            </item>
            <item>
            <term>
            Both abortive and graceful disconnects result in a RELEASE signal being sent out with the same cause field. In either case,
            received data at the remote end of the socket is still delivered to the application. See Graceful Shutdown, Linger Options, and
            Socket Closure for more information.
            </term>
            </item>
            </list>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.connect(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.SOCKADDR,System.Int32)">
            <summary>The <c>connect</c> function establishes a connection to a specified socket.</summary>
            <param name="s">A descriptor identifying an unconnected socket.</param>
            <param name="name">A pointer to the sockaddr structure to which the connection should be established.</param>
            <param name="namelen">The length, in bytes, of the sockaddr structure pointed to by the name parameter.</param>
            <returns>
            <para>
            If no error occurs, <c>connect</c> returns zero. Otherwise, it returns SOCKET_ERROR, and a specific error code can be retrieved
            by calling WSAGetLastError.
            </para>
            <para>On a blocking socket, the return value indicates success or failure of the connection attempt.</para>
            <para>
            With a nonblocking socket, the connection attempt cannot be completed immediately. In this case, <c>connect</c> will return
            SOCKET_ERROR, and WSAGetLastError will return WSAEWOULDBLOCK. In this case, there are three possible scenarios:
            </para>
            <list type="bullet">
            <item>
            <term>Use the select function to determine the completion of the connection request by checking to see if the socket is writeable.</term>
            </item>
            <item>
            <term>
            If the application is using WSAAsyncSelect to indicate interest in connection events, then the application will receive an
            FD_CONNECT notification indicating that the <c>connect</c> operation is complete (successfully or not).
            </term>
            </item>
            <item>
            <term>
            If the application is using WSAEventSelect to indicate interest in connection events, then the associated event object will be
            signaled indicating that the <c>connect</c> operation is complete (successfully or not).
            </term>
            </item>
            </list>
            <para>
            Until the connection attempt completes on a nonblocking socket, all subsequent calls to <c>connect</c> on the same socket will
            fail with the error code WSAEALREADY, and WSAEISCONN when the connection completes successfully. Due to ambiguities in version
            1.1 of the Windows Sockets specification, error codes returned from <c>connect</c> while a connection is already pending may
            vary among implementations. As a result, it is not recommended that applications use multiple calls to connect to detect
            connection completion. If they do, they must be prepared to handle WSAEINVAL and WSAEWOULDBLOCK error values the same way that
            they handle WSAEALREADY, to assure robust operation.
            </para>
            <para>
            If the error code returned indicates the connection attempt failed (that is, WSAECONNREFUSED, WSAENETUNREACH, WSAETIMEDOUT) the
            application can call <c>connect</c> again for the same socket.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEADDRINUSE</term>
            <term>
            The socket's local address is already in use and the socket was not marked to allow address reuse with SO_REUSEADDR. This error
            usually occurs when executing bind, but could be delayed until the connect function if the bind was to a wildcard address
            (INADDR_ANY or in6addr_any) for the local IP address. A specific address needs to be implicitly bound by the connect function.
            </term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>The blocking Windows Socket 1.1 call was canceled through WSACancelBlockingCall.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEALREADY</term>
            <term>A nonblocking connect call is in progress on the specified socket.</term>
            </item>
            <item>
            <term>WSAEADDRNOTAVAIL</term>
            <term>The remote address is not a valid address (such as INADDR_ANY or in6addr_any) .</term>
            </item>
            <item>
            <term>WSAEAFNOSUPPORT</term>
            <term>Addresses in the specified family cannot be used with this socket.</term>
            </item>
            <item>
            <term>WSAECONNREFUSED</term>
            <term>The attempt to connect was forcefully rejected.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The sockaddr structure pointed to by the name contains incorrect address format for the associated address family or the namelen
            parameter is too small. This error is also returned if the sockaddr structure pointed to by the name parameter with a length
            specified in the namelen parameter is not in a valid part of the user address space.
            </term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>The parameter s is a listening socket.</term>
            </item>
            <item>
            <term>WSAEISCONN</term>
            <term>The socket is already connected (connection-oriented sockets only).</term>
            </item>
            <item>
            <term>WSAENETUNREACH</term>
            <term>The network cannot be reached from this host at this time.</term>
            </item>
            <item>
            <term>WSAEHOSTUNREACH</term>
            <term>A socket operation was attempted to an unreachable host.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term></term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor specified in the s parameter is not a socket.</term>
            </item>
            <item>
            <term>WSAETIMEDOUT</term>
            <term>An attempt to connect timed out without establishing a connection.</term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>The socket is marked as nonblocking and the connection cannot be completed immediately.</term>
            </item>
            <item>
            <term>WSAEACCES</term>
            <term>An attempt to connect a datagram socket to broadcast address failed because setsockopt option SO_BROADCAST is not enabled.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>connect</c> function is used to create a connection to the specified destination. If socket s, is unbound, unique values
            are assigned to the local association by the system, and the socket is marked as bound.
            </para>
            <para>
            For connection-oriented sockets (for example, type SOCK_STREAM), an active connection is initiated to the foreign host using
            name (an address in the namespace of the socket; for a detailed description, see bind and sockaddr).
            </para>
            <para>
            When the socket call completes successfully, the socket is ready to send and receive data. If the address member of the
            structure specified by the name parameter is filled with zeros, <c>connect</c> will return the error WSAEADDRNOTAVAIL. Any
            attempt to reconnect an active connection will fail with the error code WSAEISCONN.
            </para>
            <para>
            For connection-oriented, nonblocking sockets, it is often not possible to complete the connection immediately. In such a case,
            this function returns the error WSAEWOULDBLOCK. However, the operation proceeds.
            </para>
            <para>
            When the success or failure outcome becomes known, it may be reported in one of two ways, depending on how the client registers
            for notification.
            </para>
            <list type="bullet">
            <item>
            <term>
            If the client uses the select function, success is reported in the writefds set and failure is reported in the exceptfds set.
            </term>
            </item>
            <item>
            <term>
            If the client uses the functions WSAAsyncSelect or WSAEventSelect, the notification is announced with FD_CONNECT and the error
            code associated with the FD_CONNECT indicates either success or a specific reason for failure.
            </term>
            </item>
            </list>
            <para>
            For a connectionless socket (for example, type SOCK_DGRAM), the operation performed by <c>connect</c> is merely to establish a
            default destination address that can be used on subsequent send/ WSASend and recv/ WSARecv calls. Any datagrams received from an
            address other than the destination address specified will be discarded. If the address member of the structure specified by name
            is filled with zeros, the socket will be disconnected. Then, the default remote address will be indeterminate, so send/ WSASend
            and recv/ WSARecv calls will return the error code WSAENOTCONN. However, sendto/ WSASendTo and recvfrom/ WSARecvFrom can still
            be used. The default destination can be changed by simply calling <c>connect</c> again, even if the socket is already connected.
            Any datagrams queued for receipt are discarded if name is different from the previous <c>connect</c>.
            </para>
            <para>
            For connectionless sockets, name can indicate any valid address, including a broadcast address. However, to connect to a
            broadcast address, a socket must use setsockopt to enable the SO_BROADCAST option. Otherwise, <c>connect</c> will fail with the
            error code WSAEACCES.
            </para>
            <para>
            When a connection between sockets is broken, the socket that was connected should be discarded and new socket should be created.
            When a problem develops on a connected socket, the application must discard the socket and create the socket again in order to
            return to a stable point.
            </para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>connect</c>, Winsock may need to wait for a network event before the
            call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure
            call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing
            blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients.
            </para>
            <para>Example Code</para>
            <para>The following example demonstrates the use of the <c>connect</c> function.</para>
            <para>For another example that uses the <c>connect</c> function, see Getting Started With Winsock.</para>
            <para>Notes for IrDA Sockets</para>
            <list type="bullet">
            <item>
            <term>The Af_irda.h header file must be explicitly included.</term>
            </item>
            <item>
            <term>If an existing IrDA connection is detected at the media-access level, WSAENETDOWN is returned.</term>
            </item>
            <item>
            <term>If active connections to a device with a different address exist, WSAEADDRINUSE is returned.</term>
            </item>
            <item>
            <term>If the socket is already connected or an exclusive/multiplexed mode change failed, WSAEISCONN is returned.</term>
            </item>
            <item>
            <term>
            If the socket was previously bound to a local service name to accept incoming connections using bind, WSAEINVAL is returned.
            Note that once a socket is bound, it cannot be used for establishing an outbound connection.
            </term>
            </item>
            </list>
            <para>
            IrDA implements the connect function with addresses of the form sockaddr_irda. Typically, a client application will create a
            socket with the socket function, scan the immediate vicinity for IrDA devices with the IRLMP_ENUMDEVICES socket option, choose a
            device from the returned list, form an address, and then call <c>connect</c>. There is no difference between blocking and
            nonblocking semantics.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.gethostname(System.Text.StringBuilder,System.Int32)">
            <summary>The <c>gethostname</c> function retrieves the standard host name for the local computer.</summary>
            <param name="name">A pointer to a buffer that receives the local host name.</param>
            <param name="namelen">The length, in bytes, of the buffer pointed to by the name parameter.</param>
            <returns>
            <para>
            If no error occurs, <c>gethostname</c> returns zero. Otherwise, it returns SOCKET_ERROR and a specific error code can be
            retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The name parameter is a NULL pointer or is not a valid part of the user address space. This error is also returned if the buffer
            size specified by namelen parameter is too small to hold the complete host name.
            </term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>gethostname</c> function returns the name of the local host into the buffer specified by the name parameter. The host
            name is returned as a <c>null</c>-terminated string. The form of the host name is dependent on the Windows Sockets providerit
            can be a simple host name, or it can be a fully qualified domain name. However, it is guaranteed that the name returned will be
            successfully parsed by gethostbyname and WSAAsyncGetHostByName.
            </para>
            <para>The maximum length of the name returned in the buffer pointed to by the name parameter is dependent on the namespace provider.</para>
            <para>
            If the <c>gethostname</c> function is used on a cluster resource on Windows Server 2008, Windows Server 2003, or Windows 2000
            Server and the CLUSTER_NETWORK_NAME environment variable is defined, then the value in this environment variable overrides the
            actual hostname and is returned. On a cluster resource, the CLUSTER_NETWORK_NAME environment variable contains the name of the cluster.
            </para>
            <para>
            The <c>gethostname</c> function queries namespace providers to determine the local host name using the SVCID_HOSTNAME GUID
            defined in the Svgguid.h header file. If no namespace provider responds, then the <c>gethostname</c> function returns the
            NetBIOS name of the local computer.
            </para>
            <para>
            The maximum length, in bytes, of the string returned in the buffer pointed to by the name parameter is dependent on the
            namespace provider, but this string must be 256 bytes or less. So if a buffer of 256 bytes is passed in the name parameter and
            the namelen parameter is set to 256, the buffer size will always be adequate.
            </para>
            <para>
            <c>Note</c> If no local host name has been configured, <c>gethostname</c> must succeed and return a token host name that
            gethostbyname or WSAAsyncGetHostByName can resolve.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.GetHostNameW(System.Text.StringBuilder,System.Int32)">
            <summary>The <c>GetHostNameW</c> function retrieves the standard host name for the local computer as a Unicode string.</summary>
            <param name="name">A pointer to a buffer that receives the local host name as a <c>null</c>-terminated Unicode string.</param>
            <param name="namelen">The length, in wide characters, of the buffer pointed to by the name parameter.</param>
            <returns>
            <para>
            If no error occurs, <c>GetHostNameW</c> returns zero. Otherwise, it returns <c>SOCKET_ERROR</c> and a specific error code can be
            retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The name parameter is a NULL pointer or is not a valid part of the user address space. This error is also returned if the buffer
            size specified by namelen parameter is too small to hold the complete host name.
            </term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>GetHostNameW</c> function returns the name of the local host into the buffer specified by the name parameter in Unicode
            (UTF-16). The host name is returned as a <c>null</c>-terminated Unicode string. The form of the host name is dependent on the
            Windows Sockets providerit can be a simple host name, or it can be a fully qualified domain name. However, it is guaranteed
            that the name returned will be successfully parsed by GetAddrInfoW.
            </para>
            <para>
            With the growth of the Internet, there is a growing need to identify Internet host names for other languages not represented by
            the ASCII character set. Identifiers which facilitate this need and allow non-ASCII characters (Unicode) to be represented as
            special ASCII character strings (Punycode) are known as Internationalized Domain Names (IDNs). A mechanism called
            Internationalizing Domain Names in Applications (IDNA) is used to handle IDNs in a standard fashion. The <c>GetHostNameW</c>
            function does not convert the local hostname between Punycode and Unicode. The GetAddrInfoW function provides support for
            Internationalized Domain Name (IDN) parsing and performs Punycode/IDN encoding and conversion.
            </para>
            <para>
            If the <c>GetHostNameW</c> function is used on a cluster resource on Windows Server 2012 and the CLUSTER_NETWORK_NAME
            environment variable is defined, then the value in this environment variable overrides the actual hostname and is returned. On a
            cluster resource, the CLUSTER_NETWORK_NAME environment variable contains the name of the cluster.
            </para>
            <para>
            The <c>GetHostNameW</c> function queries namespace providers to determine the local host name using the SVCID_HOSTNAME GUID
            defined in the Svgguid.h header file. If no namespace provider responds, then the <c>GetHostNameW</c> function returns the
            NetBIOS name of the local computer in Unicode.
            </para>
            <para>
            The maximum length, in wide characters, of the string returned in the buffer pointed to by the name parameter is dependent on
            the namespace provider, but this string must be 256 wide characters or less. So if a buffer of 256 wide characters is passed in
            the name parameter and the namelen parameter is set to 256, the buffer size will always be adequate.
            </para>
            <para>
            <c>Note</c> If no local host name has been configured, <c>GetHostNameW</c> must succeed and return a token host name that
            GetAddrInfoW can resolve.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.getpeername(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.SOCKADDR,System.Int32@)">
            <summary>The <c>getpeername</c> function retrieves the address of the peer to which a socket is connected.</summary>
            <param name="s">A descriptor identifying a connected socket.</param>
            <param name="name">The SOCKADDR structure that receives the address of the peer.</param>
            <param name="namelen">A pointer to the size, in bytes, of the name parameter.</param>
            <returns>
            <para>
            If no error occurs, <c>getpeername</c> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code
            can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The name or the namelen parameter is not in a valid part of the user address space, or the namelen parameter is too small.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAENOTCONN</term>
            <term>The socket is not connected.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>getpeername</c> function retrieves the address of the peer connected to the socket s and stores the address in the
            SOCKADDR structure identified by the name parameter. This function works with any address family and it simply returns the
            address to which the socket is connected. The <c>getpeername</c> function can be used only on a connected socket.
            </para>
            <para>
            For datagram sockets, only the address of a peer specified in a previous connect call will be returned. Any address specified by
            a previous sendto call will not be returned by <c>getpeername</c>.
            </para>
            <para>
            On call, the namelen parameter contains the size, in bytes, of the name buffer. On return, the namelen parameter contains the
            actual size, in bytes, of the name parameter returned.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.getprotobyname_unsafe(System.String)">
            <summary>The <c>getprotobyname</c> function retrieves the protocol information corresponding to a protocol name.</summary>
            <param name="name">Pointer to a null-terminated protocol name.</param>
            <returns>
            <para>
            If no error occurs, <c>getprotobyname</c> returns a pointer to the protoent. Otherwise, it returns a null pointer and a specific
            error number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAHOST_NOT_FOUND</term>
            <term>Authoritative answer protocol not found.</term>
            </item>
            <item>
            <term>WSATRY_AGAIN</term>
            <term>A nonauthoritative protocol not found, or server failure.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>Nonrecoverable errors, the protocols database is not accessible.</term>
            </item>
            <item>
            <term>WSANO_DATA</term>
            <term>Valid name, no data record of requested type.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The name parameter is not a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>A blocking Windows Socket 1.1 call was canceled through WSACancelBlockingCall.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>getprotobyname</c> function returns a pointer to the protoent structure containing the name(s) and protocol number that
            correspond to the protocol specified in the name parameter. All strings are null-terminated. The <c>protoent</c> structure is
            allocated by the Windows Sockets library. An application must never attempt to modify this structure or to free any of its
            components. Furthermore, like hostent, only one copy of this structure is allocated per thread, so the application should copy
            any information that it needs before issuing any other Windows Sockets function calls.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.getprotobyname(System.String)">
            <summary>The <c>getprotobyname</c> function retrieves the protocol information corresponding to a protocol name.</summary>
            <param name="name">Pointer to a null-terminated protocol name.</param>
            <returns>
            <para>
            If no error occurs, <c>getprotobyname</c> returns a pointer to the protoent. Otherwise, it returns a null pointer and a specific
            error number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAHOST_NOT_FOUND</term>
            <term>Authoritative answer protocol not found.</term>
            </item>
            <item>
            <term>WSATRY_AGAIN</term>
            <term>A nonauthoritative protocol not found, or server failure.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>Nonrecoverable errors, the protocols database is not accessible.</term>
            </item>
            <item>
            <term>WSANO_DATA</term>
            <term>Valid name, no data record of requested type.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The name parameter is not a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>A blocking Windows Socket 1.1 call was canceled through WSACancelBlockingCall.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>getprotobyname</c> function returns a pointer to the protoent structure containing the name(s) and protocol number that
            correspond to the protocol specified in the name parameter. All strings are null-terminated. The <c>protoent</c> structure is
            allocated by the Windows Sockets library. An application must never attempt to modify this structure or to free any of its
            components. Furthermore, like hostent, only one copy of this structure is allocated per thread, so the application should copy
            any information that it needs before issuing any other Windows Sockets function calls.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.getprotobynumber_unsafe(System.Int32)">
            <summary>The <c>getprotobynumber</c> function retrieves protocol information corresponding to a protocol number.</summary>
            <param name="number"/>
            <returns>
            <para>
            If no error occurs, <c>getprotobynumber</c> returns a pointer to the protoent structure. Otherwise, it returns a null pointer
            and a specific error number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAHOST_NOT_FOUND</term>
            <term>Authoritative answer protocol not found.</term>
            </item>
            <item>
            <term>WSATRY_AGAIN</term>
            <term>A nonauthoritative Protocol not found, or server failure.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>Nonrecoverable errors, the protocols database is not accessible.</term>
            </item>
            <item>
            <term>WSANO_DATA</term>
            <term>Valid name, no data record of requested type.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>A blocking Windows Socket 1.1 call was canceled through WSACancelBlockingCall.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This <c>getprotobynumber</c> function returns a pointer to the protoent structure as previously described in getprotobyname. The
            contents of the structure correspond to the given protocol number.
            </para>
            <para>
            The pointer that is returned points to the structure allocated by Windows Sockets. The application must never attempt to modify
            this structure or to free any of its components. Furthermore, only one copy of this structure is allocated per thread, so the
            application should copy any information that it needs before issuing any other Windows Sockets function calls.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.getprotobynumber(System.Int32)">
            <summary>The <c>getprotobynumber</c> function retrieves protocol information corresponding to a protocol number.</summary>
            <param name="number"/>
            <returns>
            <para>
            If no error occurs, <c>getprotobynumber</c> returns a pointer to the protoent structure. Otherwise, it returns a null pointer
            and a specific error number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAHOST_NOT_FOUND</term>
            <term>Authoritative answer protocol not found.</term>
            </item>
            <item>
            <term>WSATRY_AGAIN</term>
            <term>A nonauthoritative Protocol not found, or server failure.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>Nonrecoverable errors, the protocols database is not accessible.</term>
            </item>
            <item>
            <term>WSANO_DATA</term>
            <term>Valid name, no data record of requested type.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>A blocking Windows Socket 1.1 call was canceled through WSACancelBlockingCall.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            This <c>getprotobynumber</c> function returns a pointer to the protoent structure as previously described in getprotobyname. The
            contents of the structure correspond to the given protocol number.
            </para>
            <para>
            The pointer that is returned points to the structure allocated by Windows Sockets. The application must never attempt to modify
            this structure or to free any of its components. Furthermore, only one copy of this structure is allocated per thread, so the
            application should copy any information that it needs before issuing any other Windows Sockets function calls.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.getservbyname(System.String,System.String)">
            <summary>The <c>getservbyname</c> function retrieves service information corresponding to a service name and protocol.</summary>
            <param name="name">A pointer to a <c>null</c>-terminated service name.</param>
            <param name="proto">
            A pointer to a <c>null</c>-terminated protocol name. If this pointer is <c>NULL</c>, the <c>getservbyname</c> function returns
            the first service entry where name matches the <c>s_name</c> member of the servent structure or the <c>s_aliases</c> member of
            the <c>servent</c> structure. Otherwise, <c>getservbyname</c> matches both the name and the proto.
            </param>
            <returns>
            <para>
            If no error occurs, <c>getservbyname</c> returns a pointer to the servent structure. Otherwise, it returns a <c>null</c> pointer
            and a specific error number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAHOST_NOT_FOUND</term>
            <term>Authoritative Answer Service not found.</term>
            </item>
            <item>
            <term>WSATRY_AGAIN</term>
            <term>A nonauthoritative Service not found, or server failure.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>Nonrecoverable errors, the services database is not accessible.</term>
            </item>
            <item>
            <term>WSANO_DATA</term>
            <term>Valid name, no data record of requested type.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>A blocking Windows Socket 1.1 call was canceled through WSACancelBlockingCall.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>getservbyname</c> function returns a pointer to the servent structure containing the name(s) and service number that
            match the string in the name parameter. All strings are <c>null</c>-terminated.
            </para>
            <para>
            The pointer that is returned points to the <c>servent</c> structure allocated by the Windows Sockets library. The application
            must never attempt to modify this structure or to free any of its components. Furthermore, only one copy of this structure is
            allocated per thread, so the application should copy any information it needs before issuing any other Windows Sockets function calls.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.getservbyport(System.Int32,System.String)">
            <summary>The <c>getservbyport</c> function retrieves service information corresponding to a port and protocol.</summary>
            <param name="port">Port for a service, in network byte order.</param>
            <param name="proto">
            Optional pointer to a protocol name. If this is null, <c>getservbyport</c> returns the first service entry for which the port
            matches the <c>s_port</c> of the servent structure. Otherwise, <c>getservbyport</c> matches both the port and the proto parameters.
            </param>
            <returns>
            <para>
            If no error occurs, <c>getservbyport</c> returns a pointer to the servent structure. Otherwise, it returns a null pointer and a
            specific error number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAHOST_NOT_FOUND</term>
            <term>Authoritative Answer Service not found.</term>
            </item>
            <item>
            <term>WSATRY_AGAIN</term>
            <term>A nonauthoritative Service not found, or server failure.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>Nonrecoverable errors, the services database is not accessible.</term>
            </item>
            <item>
            <term>WSANO_DATA</term>
            <term>Valid name, no data record of requested type.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The proto parameter is not a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>A blocking Windows Socket 1.1 call was canceled through WSACancelBlockingCall.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>getservbyport</c> function returns a pointer to a servent structure as it does in the getservbyname function.</para>
            <para>
            The <c>servent</c> structure is allocated by Windows Sockets. The application must never attempt to modify this structure or to
            free any of its components. Furthermore, only one copy of this structure is allocated per thread, so the application should copy
            any information it needs before issuing any other Windows Sockets function calls.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.getsockname(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.SOCKADDR,System.Int32@)">
            <summary>The <c>getsockname</c> function retrieves the local name for a socket.</summary>
            <param name="s">Descriptor identifying a socket.</param>
            <param name="name">Pointer to a SOCKADDR structure that receives the address (name) of the socket.</param>
            <param name="namelen">Size of the name buffer, in bytes.</param>
            <returns>
            <para>
            If no error occurs, <c>getsockname</c> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code
            can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this API.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The name or the namelen parameter is not a valid part of the user address space, or the namelen parameter is too small.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>The socket has not been bound to an address with bind, or ADDR_ANY is specified in bind but connection has not yet occurred.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>getsockname</c> function retrieves the current name for the specified socket descriptor in name. It is used on the bound
            or connected socket specified by the s parameter. The local association is returned. This call is especially useful when a
            connect call has been made without doing a bind first; the <c>getsockname</c> function provides the only way to determine the
            local association that has been set by the system.
            </para>
            <para>
            On call, the namelen parameter contains the size of the name buffer, in bytes. On return, the namelen parameter contains the
            actual size in bytes of the name parameter.
            </para>
            <para>
            The <c>getsockname</c> function does not always return information about the host address when the socket has been bound to an
            unspecified address, unless the socket has been connected with connect or accept (for example, using ADDR_ANY). A Windows
            Sockets application must not assume that the address will be specified unless the socket is connected. The address that will be
            used for the socket is unknown unless the socket is connected when used in a multihomed host. If the socket is using a
            connectionless protocol, the address may not be available until I/O occurs on the socket.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.getsockopt(Vanara.PInvoke.Ws2_32.SOCKET,System.Int32,System.Int32,System.IntPtr,System.Int32@)">
            <summary>The <c>getsockopt</c> function retrieves a socket option.</summary>
            <param name="s">A descriptor identifying a socket.</param>
            <param name="level">The level at which the option is defined. Example: SOL_SOCKET.</param>
            <param name="optname">
            The socket option for which the value is to be retrieved. Example: SO_ACCEPTCONN. The optname value must be a socket option
            defined within the specified level, or behavior is undefined.
            </param>
            <param name="optval">A pointer to the buffer in which the value for the requested option is to be returned.</param>
            <param name="optlen">A pointer to the size, in bytes, of the optval buffer.</param>
            <returns>
            <para>
            If no error occurs, <c>getsockopt</c> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code
            can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term/>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            One of the optval or the optlen parameters is not a valid part of the user address space, or the optlen parameter is too small.
            </term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>The level parameter is unknown or invalid.</term>
            </item>
            <item>
            <term>WSAENOPROTOOPT</term>
            <term>The option is unknown or unsupported by the indicated protocol family.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>getsockopt</c> function retrieves the current value for a socket option associated with a socket of any type, in any
            state, and stores the result in optval. Options can exist at multiple protocol levels, but they are always present at the
            uppermost socket level. Options affect socket operations, such as the packet routing and OOB data transfer.
            </para>
            <para>
            The value associated with the selected option is returned in the buffer optval. The integer pointed to by optlen should
            originally contain the size of this buffer; on return, it will be set to the size of the value returned. For SO_LINGER, this
            will be the size of a LINGER structure. For most other options, it will be the size of an integer.
            </para>
            <para>
            The application is responsible for allocating any memory space pointed to directly or indirectly by any of the parameters it specified.
            </para>
            <para>If the option was never set with setsockopt, then <c>getsockopt</c> returns the default value for the option.</para>
            <para>The following options are supported for <c>getsockopt</c>. The Type column identifies the type of data addressed by optval.</para>
            <para>For more information on socket options, see Socket Options.</para>
            <para>The following table of value for the optname parameter are valid when the level parameter is set to <c>SOL_SOCKET</c>.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Type</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SO_ACCEPTCONN</term>
            <term>BOOL</term>
            <term>The socket is listening.</term>
            </item>
            <item>
            <term>SO_BROADCAST</term>
            <term>BOOL</term>
            <term>The socket is configured for the transmission and receipt of broadcast messages.</term>
            </item>
            <item>
            <term>SO_BSP_STATE</term>
            <term>CSADDR_INFO</term>
            <term>Returns the local address, local port, remote address, remote port, socket type, and protocol used by a socket.</term>
            </item>
            <item>
            <term>SO_CONDITIONAL_ACCEPT</term>
            <term>BOOL</term>
            <term>Returns current socket state, either from a previous call to setsockopt or the system default.</term>
            </item>
            <item>
            <term>SO_CONNECT_TIME</term>
            <term>DWORD</term>
            <term>
            Returns the number of seconds a socket has been connected. This socket option is valid for connection oriented protocols only.
            </term>
            </item>
            <item>
            <term>SO_DEBUG</term>
            <term>BOOL</term>
            <term>Debugging is enabled.</term>
            </item>
            <item>
            <term>SO_DONTLINGER</term>
            <term>BOOL</term>
            <term>If TRUE, the SO_LINGER option is disabled.</term>
            </item>
            <item>
            <term>SO_DONTROUTE</term>
            <term>BOOL</term>
            <term>
            Routing is disabled. Setting this succeeds but is ignored on AF_INET sockets; fails on AF_INET6 sockets with WSAENOPROTOOPT.
            This option is not supported on ATM sockets.
            </term>
            </item>
            <item>
            <term>SO_ERROR</term>
            <term>int</term>
            <term>Retrieves error status and clear.</term>
            </item>
            <item>
            <term>SO_EXCLUSIVEADDRUSE</term>
            <term>BOOL</term>
            <term>Prevents any other socket from binding to the same address and port. This option must be set before calling the bind function.</term>
            </item>
            <item>
            <term>SO_GROUP_ID</term>
            <term>GROUP</term>
            <term>Reserved.</term>
            </item>
            <item>
            <term>SO_GROUP_PRIORITY</term>
            <term>int</term>
            <term>Reserved.</term>
            </item>
            <item>
            <term>SO_KEEPALIVE</term>
            <term>BOOL</term>
            <term>Keep-alives are being sent. Not supported on ATM sockets.</term>
            </item>
            <item>
            <term>SO_LINGER</term>
            <term>LINGER structure</term>
            <term>Returns the current linger options.</term>
            </item>
            <item>
            <term>SO_MAX_MSG_SIZE</term>
            <term>unsigned int</term>
            <term>
            The maximum size of a message for message-oriented socket types (for example, SOCK_DGRAM). Has no meaning for stream oriented sockets.
            </term>
            </item>
            <item>
            <term>SO_OOBINLINE</term>
            <term>BOOL</term>
            <term>
            OOB data is being received in the normal data stream. (See section Windows Sockets 1.1 Blocking Routines and EINPROGRESS for a
            discussion of this topic.)
            </term>
            </item>
            <item>
            <term>SO_PORT_SCALABILITY</term>
            <term>BOOL</term>
            <term>
            Enables local port scalability for a socket by allowing port allocation to be maximized by allocating wildcard ports multiple
            times for different local address port pairs on a local machine.
            </term>
            </item>
            <item>
            <term>SO_PROTOCOL_INFO</term>
            <term>WSAPROTOCOL_INFO</term>
            <term>A description of the protocol information for the protocol that is bound to this socket.</term>
            </item>
            <item>
            <term>SO_RCVBUF</term>
            <term>int</term>
            <term>
            The total per-socket buffer space reserved for receives. This is unrelated to SO_MAX_MSG_SIZE and does not necessarily
            correspond to the size of the TCP receive window.
            </term>
            </item>
            <item>
            <term>SO_REUSEADDR</term>
            <term>BOOL</term>
            <term>The socket can be bound to an address which is already in use. Not applicable for ATM sockets.</term>
            </item>
            <item>
            <term>SO_SNDBUF</term>
            <term>int</term>
            <term>
            The total per-socket buffer space reserved for sends. This is unrelated to SO_MAX_MSG_SIZE and does not necessarily correspond
            to the size of a TCP send window.
            </term>
            </item>
            <item>
            <term>SO_TYPE</term>
            <term>int</term>
            <term>The type of the socket (for example, SOCK_STREAM).</term>
            </item>
            <item>
            <term>PVD_CONFIG</term>
            <term>Service Provider Dependent</term>
            <term>
            An opaque data structure object from the service provider associated with socket s. This object stores the current configuration
            information of the service provider. The exact format of this data structure is service provider specific.
            </term>
            </item>
            </list>
            <para>The following table of value for the optname parameter are valid when the level parameter is set to <c>IPPROTO_TCP</c>.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Type</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>TCP_NODELAY</term>
            <term>BOOL</term>
            <term>Disables the Nagle algorithm for send coalescing.</term>
            </item>
            </list>
            <para>The following table of value for the optname parameter are valid when the level parameter is set to <c>NSPROTO_IPX</c>.</para>
            <para><c>Note</c> Windows NT supports all IPX options. Windows Me, Windows 98, and Windows 95 support only the following options:</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Type</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>IPX_PTYPE</term>
            <term>int</term>
            <term>Retrieves the IPX packet type.</term>
            </item>
            <item>
            <term>IPX_FILTERPTYPE</term>
            <term>int</term>
            <term>Retrieves the receive filter packet type</term>
            </item>
            <item>
            <term>IPX_DSTYPE</term>
            <term>int</term>
            <term>Obtains the value of the data stream field in the SPX header on every packet sent.</term>
            </item>
            <item>
            <term>IPX_EXTENDED_ADDRESS</term>
            <term>BOOL</term>
            <term>Finds out whether extended addressing is enabled.</term>
            </item>
            <item>
            <term>IPX_RECVHDR</term>
            <term>BOOL</term>
            <term>Finds out whether the protocol header is sent up on all receive headers.</term>
            </item>
            <item>
            <term>IPX_MAXSIZE</term>
            <term>int</term>
            <term>Obtains the maximum data size that can be sent.</term>
            </item>
            <item>
            <term>IPX_ADDRESS</term>
            <term>IPX_ADDRESS_DATA structure</term>
            <term>
            Obtains information about a specific adapter to which IPX is bound. Adapter numbering is base zero. The adapternum member is
            filled in upon return.
            </term>
            </item>
            <item>
            <term>IPX_GETNETINFO</term>
            <term>IPX_NETNUM_DATA structure</term>
            <term>Obtains information about a specific IPX network number. If not available in the cache, uses RIP to obtain information.</term>
            </item>
            <item>
            <term>IPX_GETNETINFO_NORIP</term>
            <term>IPX_NETNUM_DATA structure</term>
            <term>
            Obtains information about a specific IPX network number. If not available in the cache, will not use RIP to obtain information,
            and returns error.
            </term>
            </item>
            <item>
            <term>IPX_SPXGETCONNECTIONSTATUS</term>
            <term>IPX_SPXCONNSTATUS_DATA structure</term>
            <term>Retrieves information about a connected SPX socket.</term>
            </item>
            <item>
            <term>IPX_ADDRESS_NOTIFY</term>
            <term>IPX_ADDRESS_DATA structure</term>
            <term>Retrieves status notification when changes occur on an adapter to which IPX is bound.</term>
            </item>
            <item>
            <term>IPX_MAX_ADAPTER_NUM</term>
            <term>int</term>
            <term>Retrieves maximum number of adapters present, numbered as base zero.</term>
            </item>
            <item>
            <term>IPX_RERIPNETNUMBER</term>
            <term>IPX_NETNUM_DATA structure</term>
            <term>Similar to IPX_GETNETINFO, but forces IPX to use RIP for resolution, even if the network information is in the local cache.</term>
            </item>
            <item>
            <term>IPX_IMMEDIATESPXACK</term>
            <term>BOOL</term>
            <term>
            Directs SPX connections not to delay before sending an ACK. Applications without back-and-forth traffic should set this to TRUE
            to increase performance.
            </term>
            </item>
            <item>
            <term>TCP_MAXSEG</term>
            <term>int</term>
            <term>Receives TCP maximum-segment size. Supported in Windows 10 and newer versions.</term>
            </item>
            </list>
            <para>
            The following table lists value for the optname that represent BSD socket options that are not supported by the
            <c>getsockopt</c> function.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Type</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SO_RCVLOWAT</term>
            <term>int</term>
            <term>Receives low watermark.</term>
            </item>
            <item>
            <term>SO_RCVTIMEO</term>
            <term>int</term>
            <term>Receives time-out.</term>
            </item>
            <item>
            <term>SO_SNDLOWAT</term>
            <term>int</term>
            <term>Sends low watermark.</term>
            </item>
            <item>
            <term>SO_SNDTIMEO</term>
            <term>int</term>
            <term>Sends time-out.</term>
            </item>
            <item>
            <term>TCP_MAXSEG</term>
            <term>int</term>
            <term>Receives TCP maximum-segment size. Not supported in versions before Windows 10.</term>
            </item>
            </list>
            <para>
            <c>Note</c> When using the recv function, if no data arrives during the period specified in SO_RCVTIMEO, the <c>recv</c>
            function completes. In Windows versions prior to Windows 2000, any data received subsequently fails with WSAETIMEDOUT. In
            Windows 2000 and later, if no data arrives within the period specified in SO_RCVTIMEO, the <c>recv</c> function returns
            WSAETIMEDOUT, and if data is received, <c>recv</c> returns SUCCESS.
            </para>
            <para>
            Calling <c>getsockopt</c> with an unsupported option will result in an error code of WSAENOPROTOOPT being returned from WSAGetLastError.
            </para>
            <para>
            More detailed information on some of the socket options for the optname parameter supported by the <c>getsockopt</c> function
            are listed below.
            </para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>getsockopt</c>, Winsock may need to wait for a network event before
            the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous
            procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an
            ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients.
            </para>
            <para>Example Code</para>
            <para>The following code sample demonstrates the use of the <c>getsockopt</c> function.</para>
            <para>Notes for IrDA Sockets</para>
            <list type="bullet">
            <item>
            <term>The Af_irda.h header file must be explicitly included.</term>
            </item>
            <item>
            <term>
            Windows returns WSAENETDOWN to indicate the underlying transceiver driver failed to initialize with the IrDA protocol stack.
            </term>
            </item>
            <item>
            <term>IrDA supports several special socket options:</term>
            </item>
            </list>
            <para>
            Before an IrDA socket connection can be initiated, a device address must be obtained by performing a
            <c>getsockopt</c>(,,IRLMP_ENUMDEVICES,,) function call, which returns a list of all available IrDA devices. A device address
            returned from the function call is copied into a SOCKADDR_IRDA structure, which in turn is used by a subsequent call to the
            connect function call.
            </para>
            <para>Discovery can be performed in two ways:</para>
            <list type="number">
            <item>
            <term>
            First, performing a getsockopt function call with the IRLMP_ENUMDEVICES option causes a single discovery to be run on each idle
            adapter. The list of discovered devices and cached devices (on active adapters) is returned immediately.
            </term>
            </item>
            <item>
            <term>
            The second approach to performing discovery of IrDA device addresses is to perform a lazy discovery; in this approach, the
            application is not notified until the discovered devices list changes from the last discovery run by the stack.
            </term>
            </item>
            </list>
            <para>
            The <c>DEVICELIST</c> structure shown in the Type column in the previous table is an extendible array of device descriptions.
            IrDA fills in as many device descriptions as can fit in the specified buffer. The device description consists of a device
            identifier necessary to form a sockaddr_irda structure, and a displayable string describing the device.
            </para>
            <para>
            The <c>IAS_QUERY</c> structure shown in the Type column in the previous table is used to retrieve a single attribute of a single
            class from a peer device's IAS database. The application specifies the device and class to query and the attribute and attribute
            type. Note that the device would have been obtained previously by a call to <c>getsockopt</c>(IRLMP_ENUMDEVICES). It is expected
            that the application allocates a buffer, of the necessary size, for the returned parameters.
            </para>
            <para>Many level socket options are not meaningful to IrDA; only SO_LINGER and SO_DONTLINGER are specifically supported.</para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.htonl(System.UInt32)">
            <summary>The <c>htonl</c> function converts a <c>u_long</c> from host to TCP/IP network byte order (which is big-endian).</summary>
            <param name="hostlong">A 32-bit number in host byte order.</param>
            <returns>The <c>htonl</c> function returns the value in TCP/IP's network byte order.</returns>
            <remarks>
            <para>
            The <c>htonl</c> function takes a 32-bit number in host byte order and returns a 32-bit number in the network byte order used in
            TCP/IP networks (the AF_INET or AF_INET6 address family).
            </para>
            <para>
            The <c>htonl</c> function can be used to convert an IPv4 address in host byte order to the IPv4 address in network byte order.
            This function does not do any checking to determine if the hostlong parameter is a valid IPv4 address.
            </para>
            <para>
            The <c>htonl</c> function does not require that the Winsock DLL has previously been loaded with a successful call to the
            WSAStartup function.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.htons(System.UInt16)">
            <summary>The <c>htons</c> function converts a <c>u_short</c> from host to TCP/IP network byte order (which is big-endian).</summary>
            <param name="hostshort">A 16-bit number in host byte order.</param>
            <returns>The <c>htons</c> function returns the value in TCP/IP network byte order.</returns>
            <remarks>
            <para>
            The <c>htons</c> function takes a 16-bit number in host byte order and returns a 16-bit number in network byte order used in
            TCP/IP networks (the AF_INET or AF_INET6 address family).
            </para>
            <para>
            The <c>htons</c> function can be used to convert an IP port number in host byte order to the IP port number in network byte order.
            </para>
            <para>
            The <c>htons</c> function does not require that the Winsock DLL has previously been loaded with a successful call to the
            WSAStartup function.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.inet_addr(System.String)">
            <summary>
            The <c>inet_addr</c> function converts a string containing an IPv4 dotted-decimal address into a proper address for the IN_ADDR structure.
            </summary>
            <param name="cp">TBD</param>
            <returns>
            <para>
            If no error occurs, the <c>inet_addr</c> function returns an unsigned long value containing a suitable binary representation of
            the Internet address given.
            </para>
            <para>
            If the string in the cp parameter does not contain a legitimate Internet address, for example if a portion of an "a.b.c.d"
            address exceeds 255, then <c>inet_addr</c> returns the value <c>INADDR_NONE</c>.
            </para>
            <para>
            On Windows Server 2003and later if the string in the cp parameter is an empty string, then <c>inet_addr</c> returns the value
            <c>INADDR_NONE</c>. If <c>NULL</c> is passed in the cp parameter, then <c>inet_addr</c> returns the value <c>INADDR_NONE</c>.
            </para>
            <para>
            On Windows XPand earlier if the string in the cp parameter is an empty string, then <c>inet_addr</c> returns the value
            <c>INADDR_ANY</c>. If <c>NULL</c> is passed in the cp parameter, then <c>inet_addr</c> returns the value <c>INADDR_NONE</c>.
            </para>
            </returns>
            <remarks>
            <para>
            The <c>inet_addr</c> function interprets the character string specified by the cp parameter. This string represents a numeric
            Internet address expressed in the Internet standard ".'' notation. The value returned is a number suitable for use as an
            Internet address. All Internet addresses are returned in IP's network order (bytes ordered from left to right). If you pass in "
            " (a space) to the <c>inet_addr</c> function, <c>inet_addr</c> returns zero.
            </para>
            <para>
            On Windows Vista and later, the RtlIpv4StringToAddress function can be used to convert a string representation of an IPv4
            address to a binary IPv4 address represented as an IN_ADDR structure. On Windows Vista and later, the RtlIpv6StringToAddress
            function can be used to convert a string representation of an IPv6 address to a binary IPv6 address represented as an
            <c>IN6_ADDR</c> structure.
            </para>
            <para>Internet Addresses</para>
            <para>Values specified using the ".'' notation take one of the following forms:</para>
            <para>a.b.c.d a.b.c a.b a</para>
            <para>
            When four parts are specified, each is interpreted as a byte of data and assigned, from left to right, to the 4 bytes of an
            Internet address. When an Internet address is viewed as a 32-bit integer quantity on the Intel architecture, the bytes referred
            to above appear as "d.c.b.a''. That is, the bytes on an Intel processor are ordered from right to left.
            </para>
            <para>
            The parts that make up an address in "." notation can be decimal, octal or hexadecimal as specified in the C language. Numbers
            that start with "0x" or "0X" imply hexadecimal. Numbers that start with "0" imply octal. All other numbers are interpreted as decimal.
            </para>
            <list type="table">
            <listheader>
            <term>Internet address value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>"4.3.2.16"</term>
            <term>Decimal</term>
            </item>
            <item>
            <term>"004.003.002.020"</term>
            <term>Octal</term>
            </item>
            <item>
            <term>"0x4.0x3.0x2.0x10"</term>
            <term>Hexadecimal</term>
            </item>
            <item>
            <term>"4.003.002.0x10"</term>
            <term>Mix</term>
            </item>
            </list>
            <para>
            The <c>inet_addr</c> function supports the decimal, octal, hexadecimal, and mixed notations for the string passed in the cp parameter.
            </para>
            <para>
            <c>Note</c> The following notations are only used by Berkeley software, and nowhere else on the Internet. For compatibility with
            Berkeley software, the <c>inet_addr</c> function also supports the additional notations specified below.
            </para>
            <para>
            When a three-part address is specified, the last part is interpreted as a 16-bit quantity and placed in the right-most 2 bytes
            of the network address. This makes the three-part address format convenient for specifying Class B network addresses as "128.net.host''
            </para>
            <para>
            When a two-part address is specified, the last part is interpreted as a 24-bit quantity and placed in the right-most 3 bytes of
            the network address. This makes the two-part address format convenient for specifying Class A network addresses as "net.host''.
            </para>
            <para>When only one part is given, the value is stored directly in the network address without any byte rearrangement.</para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            <para>Examples</para>
            <para>The following code example shows how to use the <c>inet_addr</c> function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.inet_ntoa(Vanara.PInvoke.Ws2_32.IN_ADDR)">
            <summary>
            <para>
            The <c>inet_ntoa</c> function converts an (Ipv4) Internet network address into an ASCII string in Internet standard
            dotted-decimal format.
            </para>
            </summary>
            <param name="a">An Internet address structure</param>
            <returns>
            <para>
            If no error occurs, inet_ntoa returns a character pointer to a static buffer containing the text address in standard ".''
            notation. Otherwise, it returns NULL.
            </para>
            </returns>
            <remarks>
            <para>
            The <c>inet_ntoa</c> function takes an Internet address structure specified by the in parameter and returns a
            <c>NULL</c>-terminated ASCII string that represents the address in "." (dot) notation as in "192.168.16.0", an example of an
            IPv4 address in dotted-decimal notation. The string returned by <c>inet_ntoa</c> resides in memory that is allocated by Windows
            Sockets. The application should not make any assumptions about the way in which the memory is allocated. The string returned is
            guaranteed to be valid only until the next Windows Sockets function call is made within the same thread. Therefore, the data
            should be copied before another Windows Sockets call is made.
            </para>
            <para>
            The WSAAddressToString function can be used to convert a sockaddr structure containing an IPv4 address to a string
            representation of an IPv4 address in Internet standard dotted-decimal notation. The advantage of the <c>WSAAddressToString</c>
            function is that it supports both IPv4 and IPv6 addresses. Another advantage of the <c>WSAAddressToString</c> function is that
            there are both ASCII and Unicode versions of this function.
            </para>
            <para>
            On Windows Vista and later, the RtlIpv4AddressToString function can be used to convert an IPv4 address represented as an IN_ADDR
            structure to a string representation of an IPv4 address in Internet standard dotted-decimal notation. On Windows Vista and
            later, the RtlIpv6AddressToString function can be used to convert an IPv6 address represented as an <c>IN6_ADDR</c> structure to
            a string representation of an IPv6 address.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.ioctlsocket(Vanara.PInvoke.Ws2_32.SOCKET,System.Int32,System.IntPtr)">
            <summary>The <c>ioctlsocket</c> function controls the I/O mode of a socket.</summary>
            <param name="s">A descriptor identifying a socket.</param>
            <param name="cmd">A command to perform on the socket s.</param>
            <param name="argp">A pointer to a parameter for cmd.</param>
            <returns>
            <para>
            Upon successful completion, the <c>ioctlsocket</c> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific
            error code can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor s is not a socket.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The argp parameter is not a valid part of the user address space.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>ioctlsocket</c> function can be used on any socket in any state. It is used to set or retrieve some operating parameters
            associated with the socket, independent of the protocol and communications subsystem. Here are the supported commands to use in
            the cmd parameter and their semantics:
            </para>
            <para>
            The WSAIoctl function is used to set or retrieve operating parameters associated with the socket, the transport protocol, or the
            communications subsystem.
            </para>
            <para>
            The <c>WSAIoctl</c> function is more powerful than the <c>ioctlsocket</c> function and supports a large number of possible
            values for the operating parameters to set or retrieve.
            </para>
            <para>Example Code</para>
            <para>The following example demonstrates the use of the <c>ioctlsocket</c> function.</para>
            <para>Compatibility</para>
            <para>
            This <c>ioctlsocket</c> function performs only a subset of functions on a socket when compared to the <c>ioctl</c> function
            found in Berkeley sockets. The <c>ioctlsocket</c> function has no command parameter equivalent to the FIOASYNC of <c>ioctl</c>,
            and SIOCATMARK is the only socket-level command that is supported by <c>ioctlsocket</c>.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.listen(Vanara.PInvoke.Ws2_32.SOCKET,System.Int32)">
            <summary>The <c>listen</c> function places a socket in a state in which it is listening for an incoming connection.</summary>
            <param name="s">A descriptor identifying a bound, unconnected socket.</param>
            <param name="backlog">
            <para>
            The maximum length of the queue of pending connections. If set to <c>SOMAXCONN</c>, the underlying service provider responsible
            for socket s will set the backlog to a maximum reasonable value. If set to <c>SOMAXCONN_HINT(N)</c> (where N is a number), the
            backlog value will be N, adjusted to be within the range (200, 65535). Note that <c>SOMAXCONN_HINT</c> can be used to set the
            backlog to a larger value than possible with SOMAXCONN.
            </para>
            <para>
            <c>SOMAXCONN_HINT</c> is only supported by the Microsoft TCP/IP service provider. There is no standard provision to obtain the
            actual backlog value.
            </para>
            </param>
            <returns>
            <para>
            If no error occurs, <c>listen</c> returns zero. Otherwise, a value of <c>SOCKET_ERROR</c> is returned, and a specific error code
            can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEADDRINUSE</term>
            <term>
            The socket's local address is already in use and the socket was not marked to allow address reuse with SO_REUSEADDR. This error
            usually occurs during execution of the bind function, but could be delayed until this function if the bind was to a partially
            wildcard address (involving ADDR_ANY) and if a specific address needs to be committed at the time of this function.
            </term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>The socket has not been bound with bind.</term>
            </item>
            <item>
            <term>WSAEISCONN</term>
            <term>The socket is already connected.</term>
            </item>
            <item>
            <term>WSAEMFILE</term>
            <term>No more socket descriptors are available.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>No buffer space is available.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>The referenced socket is not of a type that supports the listen operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            To accept connections, a socket is first created with the socket function and bound to a local address with the bind function. A
            backlog for incoming connections is specified with <c>listen</c>, and then the connections are accepted with the accept
            function. Sockets that are connection oriented, those of type <c>SOCK_STREAM</c> for example, are used with <c>listen</c>. The
            socket s is put into passive mode where incoming connection requests are acknowledged and queued pending acceptance by the process.
            </para>
            <para>
            A value for the backlog of <c>SOMAXCONN</c> is a special constant that instructs the underlying service provider responsible for
            socket s to set the length of the queue of pending connections to a maximum reasonable value.
            </para>
            <para>On Windows Sockets 2, this maximum value defaults to a large value (typically several hundred or more).</para>
            <para>
            When calling the <c>listen</c> function in a Bluetooth application, it is strongly recommended that a much lower value be used
            for the backlog parameter (typically 2 to 4), since only a few client connections are accepted. This reduces the system
            resources that are allocated for use by the listening socket. This same recommendation applies to other network applications
            that expect only a few client connections.
            </para>
            <para>
            The <c>listen</c> function is typically used by servers that can have more than one connection request at a time. If a
            connection request arrives and the queue is full, the client will receive an error with an indication of WSAECONNREFUSED.
            </para>
            <para>
            If there are no available socket descriptors, <c>listen</c> attempts to continue to function. If descriptors become available, a
            later call to <c>listen</c> or accept will refill the queue to the current or most recent value specified for the backlog
            parameter, if possible, and resume listening for incoming connections.
            </para>
            <para>
            If the <c>listen</c> function is called on an already listening socket, it will return success without changing the value for
            the backlog parameter. Setting the backlog parameter to 0 in a subsequent call to <c>listen</c> on a listening socket is not
            considered a proper reset, especially if there are connections on the socket.
            </para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>listen</c>, Winsock may need to wait for a network event before the
            call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure
            call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing
            blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients.
            </para>
            <para>Example Code</para>
            <para>The following example demonstrates the use of the <c>listen</c> function.</para>
            <para>Example Code</para>
            <para>For another example that uses the <c>listen</c> function, see Getting Started With Winsock.</para>
            <para>Notes for IrDA Sockets</para>
            <list type="bullet">
            <item>
            <term>The Af_irda.h header file must be explicitly included.</term>
            </item>
            </list>
            <para>Compatibility</para>
            <para>
            The backlog parameter is limited (silently) to a reasonable value as determined by the underlying service provider. Illegal
            values are replaced by the nearest legal value. There is no standard provision to find out the actual backlog value.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.ntohl(System.UInt32)">
            <summary>
            The <c>ntohl</c> function converts a <c>u_long</c> from TCP/IP network order to host byte order (which is little-endian on Intel processors).
            </summary>
            <param name="netlong">A 32-bit number in TCP/IP network byte order.</param>
            <returns>
            The <c>ntohl</c> function returns the value supplied in the netlong parameter with the byte order reversed. If netlong is
            already in host byte order, then this function will reverse it. It is up to the application to determine if the byte order must
            be reversed.
            </returns>
            <remarks>
            <para>
            The <c>ntohl</c> function takes a 32-bit number in TCP/IP network byte order (the AF_INET or AF_INET6 address family) and
            returns a 32-bit number in host byte order.
            </para>
            <para>
            The <c>ntohl</c> function can be used to convert an IPv4 address in network byte order to the IPv4 address in host byte order.
            This function does not do any checking to determine if the netlong parameter is a valid IPv4 address.
            </para>
            <para>
            The <c>ntohl</c> function does not require that the Winsock DLL has previously been loaded with a successful call to the
            WSAStartup function.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.ntohs(System.UInt16)">
            <summary>
            The <c>ntohs</c> function converts a <c>u_short</c> from TCP/IP network byte order to host byte order (which is little-endian on
            Intel processors).
            </summary>
            <param name="netshort">A 16-bit number in TCP/IP network byte order.</param>
            <returns>
            The <c>ntohs</c> function returns the value in host byte order. If the netshort parameter is already in host byte order, then
            this function will reverse it. It is up to the application to determine if the byte order must be reversed.
            </returns>
            <remarks>
            <para>
            The <c>ntohs</c> function takes a 16-bit number in TCP/IP network byte order (the AF_INET or AF_INET6 address family) and
            returns a 16-bit number in host byte order.
            </para>
            <para>
            The <c>ntohs</c> function can be used to convert an IP port number in network byte order to the IP port number in host byte order.
            </para>
            <para>
            The <c>ntohs</c> function does not require that the Winsock DLL has previously been loaded with a successful call to the
            WSAStartup function.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.recv(Vanara.PInvoke.Ws2_32.SOCKET,System.IntPtr,System.Int32,Vanara.PInvoke.Ws2_32.MsgFlags)">
            <summary>The <c>recv</c> function receives data from a connected socket or a bound connectionless socket.</summary>
            <param name="s">The descriptor that identifies a connected socket.</param>
            <param name="buf">A pointer to the buffer to receive the incoming data.</param>
            <param name="len">The length, in bytes, of the buffer pointed to by the buf parameter.</param>
            <param name="flags">
            A set of flags that influences the behavior of this function. See remarks below. See the Remarks section for details on the
            possible value for this parameter.
            </param>
            <returns>
            <para>
            If no error occurs, <c>recv</c> returns the number of bytes received and the buffer pointed to by the buf parameter will contain
            this data received. If the connection has been gracefully closed, the return value is zero.
            </para>
            <para>Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError.</para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The buf parameter is not completely contained in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAENOTCONN</term>
            <term>The socket is not connected.</term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>The (blocking) call was canceled through WSACancelBlockingCall.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAENETRESET</term>
            <term>
            For a connection-oriented socket, this error indicates that the connection has been broken due to keep-alive activity that
            detected a failure while the operation was in progress. For a datagram socket, this error indicates that the time to live has expired.
            </term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>
            MSG_OOB was specified, but the socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the
            communication domain associated with this socket, or the socket is unidirectional and supports only send operations.
            </term>
            </item>
            <item>
            <term>WSAESHUTDOWN</term>
            <term>
            The socket has been shut down; it is not possible to receive on a socket after shutdown has been invoked with how set to
            SD_RECEIVE or SD_BOTH.
            </term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>The socket is marked as nonblocking and the receive operation would block.</term>
            </item>
            <item>
            <term>WSAEMSGSIZE</term>
            <term>The message was too large to fit into the specified buffer and was truncated.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            The socket has not been bound with bind, or an unknown flag was specified, or MSG_OOB was specified for a socket with
            SO_OOBINLINE enabled or (for byte stream sockets only) len was zero or negative.
            </term>
            </item>
            <item>
            <term>WSAECONNABORTED</term>
            <term>
            The virtual circuit was terminated due to a time-out or other failure. The application should close the socket as it is no
            longer usable.
            </term>
            </item>
            <item>
            <term>WSAETIMEDOUT</term>
            <term>The connection has been dropped because of a network failure or because the peer system failed to respond.</term>
            </item>
            <item>
            <term>WSAECONNRESET</term>
            <term>
            The virtual circuit was reset by the remote side executing a hard or abortive close. The application should close the socket as
            it is no longer usable. On a UDP-datagram socket, this error would indicate that a previous send operation resulted in an ICMP
            "Port Unreachable" message.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>recv</c> function is used to read incoming data on connection-oriented sockets, or connectionless sockets. When using a
            connection-oriented protocol, the sockets must be connected before calling <c>recv</c>. When using a connectionless protocol,
            the sockets must be bound before calling <c>recv</c>.
            </para>
            <para>
            The local address of the socket must be known. For server applications, use an explicit bind function or an implicit accept or
            WSAAccept function. Explicit binding is discouraged for client applications. For client applications, the socket can become
            bound implicitly to a local address using connect, WSAConnect, sendto, WSASendTo, or WSAJoinLeaf.
            </para>
            <para>
            For connected or connectionless sockets, the <c>recv</c> function restricts the addresses from which received messages are
            accepted. The function only returns messages from the remote address specified in the connection. Messages from other addresses
            are (silently) discarded.
            </para>
            <para>
            For connection-oriented sockets (type SOCK_STREAM for example), calling <c>recv</c> will return as much data as is currently
            availableup to the size of the buffer specified. If the socket has been configured for in-line reception of OOB data (socket
            option SO_OOBINLINE) and OOB data is yet unread, only OOB data will be returned. The application can use the ioctlsocket or
            WSAIoctl <c>SIOCATMARK</c> command to determine whether any more OOB data remains to be read.
            </para>
            <para>
            For connectionless sockets (type SOCK_DGRAM or other message-oriented sockets), data is extracted from the first enqueued
            datagram (message) from the destination address specified by the connect function.
            </para>
            <para>
            If the datagram or message is larger than the buffer specified, the buffer is filled with the first part of the datagram, and
            <c>recv</c> generates the error WSAEMSGSIZE. For unreliable protocols (for example, UDP) the excess data is lost; for reliable
            protocols, the data is retained by the service provider until it is successfully read by calling <c>recv</c> with a large enough buffer.
            </para>
            <para>
            If no incoming data is available at the socket, the <c>recv</c> call blocks and waits for data to arrive according to the
            blocking rules defined for WSARecv with the MSG_PARTIAL flag not set unless the socket is nonblocking. In this case, a value of
            SOCKET_ERROR is returned with the error code set to WSAEWOULDBLOCK. The select, WSAAsyncSelect, or WSAEventSelect functions can
            be used to determine when more data arrives.
            </para>
            <para>
            If the socket is connection oriented and the remote side has shut down the connection gracefully, and all data has been
            received, a <c>recv</c> will complete immediately with zero bytes received. If the connection has been reset, a <c>recv</c> will
            fail with the error WSAECONNRESET.
            </para>
            <para>
            The flags parameter can be used to influence the behavior of the function invocation beyond the options specified for the
            associated socket. The semantics of this function are determined by the socket options and the flags parameter. The possible
            value of flags parameter is constructed by using the bitwise OR operator with any of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MSG_PEEK</term>
            <term>
            Peeks at the incoming data. The data is copied into the buffer, but is not removed from the input queue. The function
            subsequently returns the amount of data that can be read in a single call to the recv (or recvfrom) function, which may not be
            the same as the total amount of data queued on the socket. The amount of data that can actually be read in a single call to the
            recv (or recvfrom) function is limited to the data size written in the send or sendto function call.
            </term>
            </item>
            <item>
            <term>MSG_OOB</term>
            <term>Processes Out Of Band (OOB) data.</term>
            </item>
            <item>
            <term>MSG_WAITALL</term>
            <term>
            The receive request will complete only when one of the following events occurs:Note that if the underlying transport does not
            support MSG_WAITALL, or if the socket is in a non-blocking mode, then this call will fail with WSAEOPNOTSUPP. Also, if
            MSG_WAITALL is specified along with MSG_OOB, MSG_PEEK, or MSG_PARTIAL, then this call will fail with WSAEOPNOTSUPP. This flag is
            not supported on datagram sockets or message-oriented sockets.
            </term>
            </item>
            </list>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>recv</c>, Winsock may need to wait for a network event before the
            call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure
            call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing
            blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients.
            </para>
            <para>Example Code</para>
            <para>The following code example shows the use of the <c>recv</c> function.</para>
            <para>Example Code</para>
            <para>For more information, and another example of the <c>recv</c> function, see Getting Started With Winsock.</para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.recvfrom(Vanara.PInvoke.Ws2_32.SOCKET,System.IntPtr,System.Int32,System.Int32,Vanara.PInvoke.Ws2_32.SOCKADDR,System.Int32@)">
            <summary>The <c>recvfrom</c> function receives a datagram and stores the source address.</summary>
            <param name="s">A descriptor identifying a bound socket.</param>
            <param name="buf">A buffer for the incoming data.</param>
            <param name="len">The length, in bytes, of the buffer pointed to by the buf parameter.</param>
            <param name="flags">
            A set of options that modify the behavior of the function call beyond the options specified for the associated socket. See the
            Remarks below for more details.
            </param>
            <param name="from">An optional pointer to a buffer in a sockaddr structure that will hold the source address upon return.</param>
            <param name="fromlen">An optional pointer to the size, in bytes, of the buffer pointed to by the from parameter.</param>
            <returns>
            <para>
            If no error occurs, <c>recvfrom</c> returns the number of bytes received. If the connection has been gracefully closed, the
            return value is zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The buffer pointed to by the buf or from parameters are not in the user address space, or the fromlen parameter is too small to
            accommodate the source address of the peer address.
            </term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>The (blocking) call was canceled through WSACancelBlockingCall.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            The socket has not been bound with bind, or an unknown flag was specified, or MSG_OOB was specified for a socket with
            SO_OOBINLINE enabled, or (for byte stream-style sockets only) len was zero or negative.
            </term>
            </item>
            <item>
            <term>WSAEISCONN</term>
            <term>
            The socket is connected. This function is not permitted with a connected socket, whether the socket is connection oriented or connectionless.
            </term>
            </item>
            <item>
            <term>WSAENETRESET</term>
            <term>For a datagram socket, this error indicates that the time to live has expired.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor in the s parameter is not a socket.</term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>
            MSG_OOB was specified, but the socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the
            communication domain associated with this socket, or the socket is unidirectional and supports only send operations.
            </term>
            </item>
            <item>
            <term>WSAESHUTDOWN</term>
            <term>
            The socket has been shut down; it is not possible to recvfrom on a socket after shutdown has been invoked with how set to
            SD_RECEIVE or SD_BOTH.
            </term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>The socket is marked as nonblocking and the recvfrom operation would block.</term>
            </item>
            <item>
            <term>WSAEMSGSIZE</term>
            <term>The message was too large to fit into the buffer pointed to by the buf parameter and was truncated.</term>
            </item>
            <item>
            <term>WSAETIMEDOUT</term>
            <term>
            The connection has been dropped, because of a network failure or because the system on the other end went down without notice.
            </term>
            </item>
            <item>
            <term>WSAECONNRESET</term>
            <term>
            The virtual circuit was reset by the remote side executing a hard or abortive close. The application should close the socket; it
            is no longer usable. On a UDP-datagram socket this error indicates a previous send operation resulted in an ICMP Port
            Unreachable message.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>recvfrom</c> function reads incoming data on both connected and unconnected sockets and captures the address from which
            the data was sent. This function is typically used with connectionless sockets. The local address of the socket must be known.
            For server applications, this is usually done explicitly through bind. Explicit binding is discouraged for client applications.
            For client applications using this function, the socket can become bound implicitly to a local address through sendto,
            WSASendTo, or WSAJoinLeaf.
            </para>
            <para>
            For stream-oriented sockets such as those of type SOCK_STREAM, a call to <c>recvfrom</c> returns as much information as is
            currently availableup to the size of the buffer specified. If the socket has been configured for inline reception of OOB data
            (socket option SO_OOBINLINE) and OOB data is yet unread, only OOB data will be returned. The application can use the ioctlsocket
            or WSAIoctl <c>SIOCATMARK</c> command to determine whether any more OOB data remains to be read. The from and fromlen parameters
            are ignored for connection-oriented sockets.
            </para>
            <para>
            For message-oriented sockets, data is extracted from the first enqueued message, up to the size of the buffer specified. If the
            datagram or message is larger than the buffer specified, the buffer is filled with the first part of the datagram, and
            <c>recvfrom</c> generates the error WSAEMSGSIZE. For unreliable protocols (for example, UDP) the excess data is lost. For UDP if
            the packet received contains no data (empty), the return value from the <c>recvfrom</c> function function is zero.
            </para>
            <para>
            If the from parameter is nonzero and the socket is not connection oriented, (type SOCK_DGRAM for example), the network address
            of the peer that sent the data is copied to the corresponding sockaddr structure. The value pointed to by fromlen is initialized
            to the size of this structure and is modified, on return, to indicate the actual size of the address stored in the
            <c>sockaddr</c> structure.
            </para>
            <para>
            If no incoming data is available at the socket, the <c>recvfrom</c> function blocks and waits for data to arrive according to
            the blocking rules defined for WSARecv with the MSG_PARTIAL flag not set unless the socket is nonblocking. In this case, a value
            of SOCKET_ERROR is returned with the error code set to WSAEWOULDBLOCK. The select, WSAAsyncSelect, or WSAEventSelect can be used
            to determine when more data arrives.
            </para>
            <para>
            If the socket is connection oriented and the remote side has shut down the connection gracefully, the call to <c>recvfrom</c>
            will complete immediately with zero bytes received. If the connection has been reset <c>recvfrom</c> will fail with the error WSAECONNRESET.
            </para>
            <para>
            The flags parameter can be used to influence the behavior of the function invocation beyond the options specified for the
            associated socket. The semantics of this function are determined by the socket options and the flags parameter. The latter is
            constructed by using the bitwise OR operator with any of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MSG_PEEK</term>
            <term>
            Peeks at the incoming data. The data is copied into the buffer but is not removed from the input queue. The function
            subsequently returns the amount of data that can be read in a single call to the recvfrom (or recv) function, which may not be
            the same as the total amount of data queued on the socket. The amount of data that can actually be read in a single call to the
            recvfrom (or recv) function is limited to the data size written in the send or sendto function call.
            </term>
            </item>
            <item>
            <term>MSG_OOB</term>
            <term>Processes Out Of Band (OOB) data.</term>
            </item>
            </list>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>recvfrom</c>, Winsock may need to wait for a network event before
            the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous
            procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an
            ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients.
            </para>
            <para>Example Code</para>
            <para>The following example demonstrates the use of the <c>recvfrom</c> function.</para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.send(Vanara.PInvoke.Ws2_32.SOCKET,System.IntPtr,System.Int32,System.Int32)">
            <summary>The <c>send</c> function sends data on a connected socket.</summary>
            <param name="s">A descriptor identifying a connected socket.</param>
            <param name="buf">A pointer to a buffer containing the data to be transmitted.</param>
            <param name="len">The length, in bytes, of the data in buffer pointed to by the buf parameter.</param>
            <param name="flags">
            <para>
            A set of flags that specify the way in which the call is made. This parameter is constructed by using the bitwise OR operator
            with any of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MSG_DONTROUTE</term>
            <term>
            Specifies that the data should not be subject to routing. A Windows Sockets service provider can choose to ignore this flag.
            </term>
            </item>
            <item>
            <term>MSG_OOB</term>
            <term>Sends OOB data (stream-style socket such as SOCK_STREAM only.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>
            If no error occurs, <c>send</c> returns the total number of bytes sent, which can be less than the number requested to be sent
            in the len parameter. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEACCES</term>
            <term>
            The requested address is a broadcast address, but the appropriate flag was not set. Call setsockopt with the SO_BROADCAST socket
            option to enable use of the broadcast address.
            </term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>A blocking Windows Sockets 1.1 call was canceled through WSACancelBlockingCall.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The buf parameter is not completely contained in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAENETRESET</term>
            <term>The connection has been broken due to the keep-alive activity detecting a failure while the operation was in progress.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>No buffer space is available.</term>
            </item>
            <item>
            <term>WSAENOTCONN</term>
            <term>The socket is not connected.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>
            MSG_OOB was specified, but the socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the
            communication domain associated with this socket, or the socket is unidirectional and supports only receive operations.
            </term>
            </item>
            <item>
            <term>WSAESHUTDOWN</term>
            <term>
            The socket has been shut down; it is not possible to send on a socket after shutdown has been invoked with how set to SD_SEND or SD_BOTH.
            </term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>The socket is marked as nonblocking and the requested operation would block.</term>
            </item>
            <item>
            <term>WSAEMSGSIZE</term>
            <term>The socket is message oriented, and the message is larger than the maximum supported by the underlying transport.</term>
            </item>
            <item>
            <term>WSAEHOSTUNREACH</term>
            <term>The remote host cannot be reached from this host at this time.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            The socket has not been bound with bind, or an unknown flag was specified, or MSG_OOB was specified for a socket with
            SO_OOBINLINE enabled.
            </term>
            </item>
            <item>
            <term>WSAECONNABORTED</term>
            <term>
            The virtual circuit was terminated due to a time-out or other failure. The application should close the socket as it is no
            longer usable.
            </term>
            </item>
            <item>
            <term>WSAECONNRESET</term>
            <term>
            The virtual circuit was reset by the remote side executing a hard or abortive close. For UDP sockets, the remote host was unable
            to deliver a previously sent UDP datagram and responded with a "Port Unreachable" ICMP packet. The application should close the
            socket as it is no longer usable.
            </term>
            </item>
            <item>
            <term>WSAETIMEDOUT</term>
            <term>
            The connection has been dropped, because of a network failure or because the system on the other end went down without notice.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>send</c> function is used to write outgoing data on a connected socket.</para>
            <para>
            For message-oriented sockets (address family of <c>AF_INET</c> or <c>AF_INET6</c>, type of <c>SOCK_DGRAM</c>, and protocol of
            <c>IPPROTO_UDP</c>, for example), care must be taken not to exceed the maximum packet size of the underlying provider. The
            maximum message packet size for a provider can be obtained by calling getsockopt with the optname parameter set to
            <c>SO_MAX_MSG_SIZE</c> to retrieve the value of socket option. If the data is too long to pass atomically through the underlying
            protocol, the error WSAEMSGSIZE is returned, and no data is transmitted.
            </para>
            <para>
            The successful completion of a <c>send</c> function does not indicate that the data was successfully delivered and received to
            the recipient. This function only indicates the data was successfully sent.
            </para>
            <para>
            If no buffer space is available within the transport system to hold the data to be transmitted, <c>send</c> will block unless
            the socket has been placed in nonblocking mode. On nonblocking stream oriented sockets, the number of bytes written can be
            between 1 and the requested length, depending on buffer availability on both the client and server computers. The select,
            WSAAsyncSelect or WSAEventSelect functions can be used to determine when it is possible to send more data.
            </para>
            <para>
            Calling <c>send</c> with a len parameter of zero is permissible and will be treated by implementations as successful. In such
            cases, <c>send</c> will return zero as a valid value. For message-oriented sockets, a zero-length transport datagram is sent.
            </para>
            <para>
            The flags parameter can be used to influence the behavior of the function beyond the options specified for the associated
            socket. The semantics of the <c>send</c> function are determined by any options previously set on the socket specified in the s
            parameter and the flags parameter passed to the <c>send</c> function.
            </para>
            <para>
            The order of calls made to <c>send</c> is also the order in which the buffers are transmitted to the transport layer.
            <c>send</c> should not be called on the same stream-oriented socket concurrently from different threads, because some Winsock
            providers may split a large send request into multiple transmissions, and this may lead to unintended data interleaving from
            multiple concurrent send requests on the same stream-oriented socket.
            </para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>send</c>, Winsock may need to wait for a network event before the
            call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure
            call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing
            blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients.
            </para>
            <para>Example Code</para>
            <para>The following example demonstrates the use of the <c>send</c> function.</para>
            <para>Example Code</para>
            <para>For a another example that uses the <c>send</c> function, see Getting Started With Winsock.</para>
            <para>Notes for IrDA Sockets</para>
            <list type="bullet">
            <item>
            <term>The Af_irda.h header file must be explicitly included.</term>
            </item>
            </list>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.sendto(Vanara.PInvoke.Ws2_32.SOCKET,System.IntPtr,System.Int32,System.Int32,Vanara.PInvoke.Ws2_32.SOCKADDR,System.Int32)">
            <summary>The <c>sendto</c> function sends data to a specific destination.</summary>
            <param name="s">A descriptor identifying a (possibly connected) socket.</param>
            <param name="buf">A pointer to a buffer containing the data to be transmitted.</param>
            <param name="len">The length, in bytes, of the data pointed to by the buf parameter.</param>
            <param name="flags">A set of flags that specify the way in which the call is made.</param>
            <param name="to">An optional pointer to a sockaddr structure that contains the address of the target socket.</param>
            <param name="tolen">The size, in bytes, of the address pointed to by the to parameter.</param>
            <returns>
            <para>
            If no error occurs, <c>sendto</c> returns the total number of bytes sent, which can be less than the number indicated by len.
            Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEACCES</term>
            <term>
            The requested address is a broadcast address, but the appropriate flag was not set. Call setsockopt with the SO_BROADCAST
            parameter to allow the use of the broadcast address.
            </term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>An unknown flag was specified, or MSG_OOB was specified for a socket with SO_OOBINLINE enabled.</term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>A blocking Windows Sockets 1.1 call was canceled through WSACancelBlockingCall.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The buf or to parameters are not part of the user address space, or the tolen parameter is too small.</term>
            </item>
            <item>
            <term>WSAENETRESET</term>
            <term>The connection has been broken due to keep-alive activity detecting a failure while the operation was in progress.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>No buffer space is available.</term>
            </item>
            <item>
            <term>WSAENOTCONN</term>
            <term>The socket is not connected (connection-oriented sockets only).</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>
            MSG_OOB was specified, but the socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the
            communication domain associated with this socket, or the socket is unidirectional and supports only receive operations.
            </term>
            </item>
            <item>
            <term>WSAESHUTDOWN</term>
            <term>
            The socket has been shut down; it is not possible to sendto on a socket after shutdown has been invoked with how set to SD_SEND
            or SD_BOTH.
            </term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>The socket is marked as nonblocking and the requested operation would block.</term>
            </item>
            <item>
            <term>WSAEMSGSIZE</term>
            <term>The socket is message oriented, and the message is larger than the maximum supported by the underlying transport.</term>
            </item>
            <item>
            <term>WSAEHOSTUNREACH</term>
            <term>The remote host cannot be reached from this host at this time.</term>
            </item>
            <item>
            <term>WSAECONNABORTED</term>
            <term>
            The virtual circuit was terminated due to a time-out or other failure. The application should close the socket as it is no
            longer usable.
            </term>
            </item>
            <item>
            <term>WSAECONNRESET</term>
            <term>
            The virtual circuit was reset by the remote side executing a hard or abortive close. For UPD sockets, the remote host was unable
            to deliver a previously sent UDP datagram and responded with a "Port Unreachable" ICMP packet. The application should close the
            socket as it is no longer usable.
            </term>
            </item>
            <item>
            <term>WSAEADDRNOTAVAIL</term>
            <term>The remote address is not a valid address, for example, ADDR_ANY.</term>
            </item>
            <item>
            <term>WSAEAFNOSUPPORT</term>
            <term>Addresses in the specified family cannot be used with this socket.</term>
            </item>
            <item>
            <term>WSAEDESTADDRREQ</term>
            <term>A destination address is required.</term>
            </item>
            <item>
            <term>WSAENETUNREACH</term>
            <term>The network cannot be reached from this host at this time.</term>
            </item>
            <item>
            <term>WSAEHOSTUNREACH</term>
            <term>A socket operation was attempted to an unreachable host.</term>
            </item>
            <item>
            <term>WSAETIMEDOUT</term>
            <term>
            The connection has been dropped, because of a network failure or because the system on the other end went down without notice.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>sendto</c> function is used to write outgoing data on a socket. For message-oriented sockets, care must be taken not to
            exceed the maximum packet size of the underlying subnets, which can be obtained by using getsockopt to retrieve the value of
            socket option SO_MAX_MSG_SIZE. If the data is too long to pass atomically through the underlying protocol, the error WSAEMSGSIZE
            is returned and no data is transmitted.
            </para>
            <para>
            The to parameter can be any valid address in the socket's address family, including a broadcast or any multicast address. To
            send to a broadcast address, an application must have used setsockopt with SO_BROADCAST enabled. Otherwise, <c>sendto</c> will
            fail with the error code WSAEACCES. For TCP/IP, an application can send to any multicast address (without becoming a group member).
            </para>
            <para>
            <c>Note</c> If a socket is opened, a setsockopt call is made, and then a <c>sendto</c> call is made, Windows Sockets performs an
            implicit <c>bind</c> function call.
            </para>
            <para>
            If the socket is unbound, unique values are assigned to the local association by the system, and the socket is then marked as
            bound. If the socket is connected, the getsockname function can be used to determine the local IP address and port associated
            with the socket.
            </para>
            <para>
            If the socket is not connected, the getsockname function can be used to determine the local port number associated with the
            socket but the IP address returned is set to the wildcard address for the given protocol (for example, INADDR_ANY or "0.0.0.0"
            for IPv4 and IN6ADDR_ANY_INIT or "::" for IPv6).
            </para>
            <para>The successful completion of a <c>sendto</c> does not indicate that the data was successfully delivered.</para>
            <para>
            The <c>sendto</c> function is normally used on a connectionless socket to send a datagram to a specific peer socket identified
            by the to parameter. Even if the connectionless socket has been previously connected to a specific address, the to parameter
            overrides the destination address for that particular datagram only. On a connection-oriented socket, the to and tolen
            parameters are ignored, making <c>sendto</c> equivalent to send.
            </para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>sendto</c>, Winsock may need to wait for a network event before the
            call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous procedure
            call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an ongoing
            blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients.
            </para>
            <para>Example Code</para>
            <para>The following example demonstrates the use of the <c>sendto</c> function.</para>
            <para>For Sockets Using IP (Version 4)</para>
            <para>
            To send a broadcast (on a SOCK_DGRAM only), the address pointed to by the to parameter can be constructed to contain the special
            IPv4 address INADDR_BROADCAST (defined in Winsock2.h), together with the intended port number. If the address pointed to by the
            to parameter contains the INADDR_BROADCAST address and intended port, then the broadcast will be sent out on all interfaces to
            that port.
            </para>
            <para>
            If the broadcast should be sent out only on a specific interface, then the address pointed to by the to parameter should contain
            the subnet broadcast address for the interface and the intended port. For example, an IPv4 network address of 192.168.1.0 with a
            subnet mask of 255.255.255.0 would use a subnet broadcast address of 192.168.1.255.
            </para>
            <para>
            It is generally inadvisable for a broadcast datagram to exceed the size at which fragmentation can occur, which implies that the
            data portion of the datagram (excluding headers) should not exceed 512 bytes.
            </para>
            <para>
            If no buffer space is available within the transport system to hold the data to be transmitted, <c>sendto</c> will block unless
            the socket has been placed in a nonblocking mode. On nonblocking, stream oriented sockets, the number of bytes written can be
            between 1 and the requested length, depending on buffer availability on both the client and server systems. The select,
            WSAAsyncSelect or WSAEventSelect function can be used to determine when it is possible to send more data.
            </para>
            <para>
            Calling <c>sendto</c> with a len of zero is permissible and will return zero as a valid value. For message-oriented sockets, a
            zero-length transport datagram is sent.
            </para>
            <para>
            The flags parameter can be used to influence the behavior of the function invocation beyond the options specified for the
            associated socket. The semantics of this function are determined by the socket options and the flags parameter. The latter is
            constructed by using the bitwise OR operator with any of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MSG_DONTROUTE</term>
            <term>
            Specifies that the data should not be subject to routing. A Windows Sockets service provider can choose to ignore this flag.
            </term>
            </item>
            <item>
            <term>MSG_OOB</term>
            <term>Sends OOB data (stream-style socket such as SOCK_STREAM only).</term>
            </item>
            </list>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.setsockopt(Vanara.PInvoke.Ws2_32.SOCKET,System.Int32,System.Int32,System.IntPtr,System.Int32)">
            <summary>The <c>setsockopt</c> function sets a socket option.</summary>
            <param name="s">A descriptor that identifies a socket.</param>
            <param name="level">The level at which the option is defined (for example, SOL_SOCKET).</param>
            <param name="optname">
            The socket option for which the value is to be set (for example, SO_BROADCAST). The optname parameter must be a socket option
            defined within the specified level, or behavior is undefined.
            </param>
            <param name="optval">A pointer to the buffer in which the value for the requested option is specified.</param>
            <param name="optlen">The size, in bytes, of the buffer pointed to by the optval parameter.</param>
            <returns>
            <para>
            If no error occurs, <c>setsockopt</c> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code
            can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The buffer pointed to by the optval parameter is not in a valid part of the process address space or the optlen parameter is too small.
            </term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>The level parameter is not valid, or the information in the buffer pointed to by the optval parameter is not valid.</term>
            </item>
            <item>
            <term>WSAENETRESET</term>
            <term>The connection has timed out when SO_KEEPALIVE is set.</term>
            </item>
            <item>
            <term>WSAENOPROTOOPT</term>
            <term>The option is unknown or unsupported for the specified provider or socket (see SO_GROUP_PRIORITY limitations).</term>
            </item>
            <item>
            <term>WSAENOTCONN</term>
            <term>The connection has been reset when SO_KEEPALIVE is set.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>setsockopt</c> function sets the current value for a socket option associated with a socket of any type, in any state.
            Although options can exist at multiple protocol levels, they are always present at the uppermost socket level. Options affect
            socket operations, such as whether expedited data (OOB data for example) is received in the normal data stream, and whether
            broadcast messages can be sent on the socket.
            </para>
            <para>
            <c>Note</c> If the <c>setsockopt</c> function is called before the bind function, TCP/IP options will not be checked by using
            TCP/IP until the <c>bind</c> occurs. In this case, the <c>setsockopt</c> function call will always succeed, but the <c>bind</c>
            function call can fail because of an early <c>setsockopt</c> call failing.
            </para>
            <para>
            <c>Note</c> If a socket is opened, a <c>setsockopt</c> call is made, and then a sendto call is made, Windows Sockets performs an
            implicit bind function call.
            </para>
            <para>
            There are two types of socket options: Boolean options that enable or disable a feature or behavior, and options that require an
            integer value or structure. To enable a Boolean option, the optval parameter points to a nonzero integer. To disable the option
            optval points to an integer equal to zero. The optlen parameter should be equal to for Boolean options. For other options,
            optval points to an integer or structure that contains the desired value for the option, and optlen is the length of the integer
            or structure.
            </para>
            <para>
            The following tables list some of the common options supported by the <c>setsockopt</c> function. The Type column identifies the
            type of data addressed by optval parameter. The Description column provides some basic information about the socket option. For
            more complete lists of socket options and more detailed information (default values, for example), see the detailed topics under
            Socket Options.
            </para>
            <para>level = <c>SOL_SOCKET</c></para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Type</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>SO_BROADCAST</term>
            <term>BOOL</term>
            <term>Configures a socket for sending broadcast data.</term>
            </item>
            <item>
            <term>SO_CONDITIONAL_ACCEPT</term>
            <term>BOOL</term>
            <term>Enables incoming connections are to be accepted or rejected by the application, not by the protocol stack.</term>
            </item>
            <item>
            <term>SO_DEBUG</term>
            <term>BOOL</term>
            <term>Enables debug output. Microsoft providers currently do not output any debug information.</term>
            </item>
            <item>
            <term>SO_DONTLINGER</term>
            <term>BOOL</term>
            <term>
            Does not block close waiting for unsent data to be sent. Setting this option is equivalent to setting SO_LINGER with l_onoff set
            to zero.
            </term>
            </item>
            <item>
            <term>SO_DONTROUTE</term>
            <term>BOOL</term>
            <term>
            Sets whether outgoing data should be sent on interface the socket is bound to and not a routed on some other interface. This
            option is not supported on ATM sockets (results in an error).
            </term>
            </item>
            <item>
            <term>SO_GROUP_PRIORITY</term>
            <term>int</term>
            <term>Reserved.</term>
            </item>
            <item>
            <term>SO_KEEPALIVE</term>
            <term>BOOL</term>
            <term>Enables sending keep-alive packets for a socket connection. Not supported on ATM sockets (results in an error).</term>
            </item>
            <item>
            <term>SO_LINGER</term>
            <term>LINGER</term>
            <term>Lingers on close if unsent data is present.</term>
            </item>
            <item>
            <term>SO_OOBINLINE</term>
            <term>BOOL</term>
            <term>
            Indicates that out-of-bound data should be returned in-line with regular data. This option is only valid for connection-oriented
            protocols that support out-of-band data. For a discussion of this topic, see Protocol Independent Out-Of-band Data.
            </term>
            </item>
            <item>
            <term>SO_RCVBUF</term>
            <term>int</term>
            <term>Specifies the total per-socket buffer space reserved for receives.</term>
            </item>
            <item>
            <term>SO_REUSEADDR</term>
            <term>BOOL</term>
            <term>
            Allows the socket to be bound to an address that is already in use. For more information, see bind. Not applicable on ATM sockets.
            </term>
            </item>
            <item>
            <term>SO_EXCLUSIVEADDRUSE</term>
            <term>BOOL</term>
            <term>Enables a socket to be bound for exclusive access. Does not require administrative privilege.</term>
            </item>
            <item>
            <term>SO_RCVTIMEO</term>
            <term>DWORD</term>
            <term>Sets the timeout, in milliseconds, for blocking receive calls.</term>
            </item>
            <item>
            <term>SO_SNDBUF</term>
            <term>int</term>
            <term>Specifies the total per-socket buffer space reserved for sends.</term>
            </item>
            <item>
            <term>SO_SNDTIMEO</term>
            <term>DWORD</term>
            <term>The timeout, in milliseconds, for blocking send calls.</term>
            </item>
            <item>
            <term>SO_UPDATE_ACCEPT_CONTEXT</term>
            <term>int</term>
            <term>Updates the accepting socket with the context of the listening socket.</term>
            </item>
            <item>
            <term>PVD_CONFIG</term>
            <term>Service Provider Dependent</term>
            <term>
            This object stores the configuration information for the service provider associated with socket s. The exact format of this
            data structure is service provider specific.
            </term>
            </item>
            </list>
            <para>For more complete and detailed information about socket options for level = <c>SOL_SOCKET</c>, see SOL_SOCKET Socket Options.</para>
            <para>level = <c>IPPROTO_TCP</c></para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Type</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>TCP_NODELAY</term>
            <term>BOOL</term>
            <term>
            Disables the Nagle algorithm for send coalescing.This socket option is included for backward compatibility with Windows Sockets 1.1
            </term>
            </item>
            </list>
            <para>
            For more complete and detailed information about socket options for level = <c>IPPROTO_TCP</c>, see IPPROTO_TCP Socket Options.
            </para>
            <para>level = <c>NSPROTO_IPX</c></para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Type</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>IPX_PTYPE</term>
            <term>int</term>
            <term>Sets the IPX packet type.</term>
            </item>
            <item>
            <term>IPX_FILTERPTYPE</term>
            <term>int</term>
            <term>Sets the receive filter packet type</term>
            </item>
            <item>
            <term>IPX_STOPFILTERPTYPE</term>
            <term>int</term>
            <term>Stops filtering the filter type set with IPX_FILTERTYPE</term>
            </item>
            <item>
            <term>IPX_DSTYPE</term>
            <term>int</term>
            <term>Sets the value of the data stream field in the SPX header on every packet sent.</term>
            </item>
            <item>
            <term>IPX_EXTENDED_ADDRESS</term>
            <term>BOOL</term>
            <term>Sets whether extended addressing is enabled.</term>
            </item>
            <item>
            <term>IPX_RECVHDR</term>
            <term>BOOL</term>
            <term>Sets whether the protocol header is sent up on all receive headers.</term>
            </item>
            <item>
            <term>IPX_RECEIVE_BROADCAST</term>
            <term>BOOL</term>
            <term>
            Indicates broadcast packets are likely on the socket. Set to TRUE by default. Applications that do not use broadcasts should set
            this to FALSE for better system performance.
            </term>
            </item>
            <item>
            <term>IPX_IMMEDIATESPXACK</term>
            <term>BOOL</term>
            <term>
            Directs SPX connections not to delay before sending an ACK. Applications without back-and-forth traffic should set this to TRUE
            to increase performance.
            </term>
            </item>
            </list>
            <para>
            For more complete and detailed information about socket options for level = <c>NSPROTO_IPX</c>, see NSPROTO_IPX Socket Options.
            </para>
            <para>BSD options not supported for <c>setsockopt</c> are shown in the following table.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Type</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>SO_ACCEPTCONN</term>
            <term>BOOL</term>
            <term>
            Returns whether a socket is in listening mode. This option is only Valid for connection-oriented protocols. This socket option
            is not supported for the setting.
            </term>
            </item>
            <item>
            <term>SO_RCVLOWAT</term>
            <term>int</term>
            <term>
            A socket option from BSD UNIX included for backward compatibility. This option sets the minimum number of bytes to process for
            socket input operations.
            </term>
            </item>
            <item>
            <term>SO_SNDLOWAT</term>
            <term>int</term>
            <term>
            A socket option from BSD UNIX included for backward compatibility. This option sets the minimum number of bytes to process for
            socket output operations.
            </term>
            </item>
            <item>
            <term>SO_TYPE</term>
            <term>int</term>
            <term>
            Returns the socket type for the given socket (SOCK_STREAM or SOCK_DGRAM, for example This socket option is not supported for the
            setting the socket type.
            </term>
            </item>
            </list>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>setsockopt</c>, Winsock may need to wait for a network event before
            the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous
            procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an
            ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients.
            </para>
            <para>Example Code</para>
            <para>The following example demonstrates the <c>setsockopt</c> function.</para>
            <para>Notes for IrDA Sockets</para>
            <para>When developing applications using Windows sockets for IrDA, note the following:</para>
            <list type="bullet">
            <item>
            <term>The Af_irda.h header file must be explicitly included.</term>
            </item>
            <item>
            <term>IrDA provides the following socket option:</term>
            </item>
            </list>
            <para>
            The IRLMP_IAS_SET socket option enables the application to set a single attribute of a single class in the local IAS. The
            application specifies the class to set, the attribute, and attribute type. The application is expected to allocate a buffer of
            the necessary size for the passed parameters.
            </para>
            <para>
            IrDA provides an IAS database that stores IrDA-based information. Limited access to the IAS database is available through the
            Windows Sockets 2 interface, but such access is not normally used by applications, and exists primarily to support connections
            to non-Windows devices that are not compliant with the Windows Sockets 2 IrDA conventions.
            </para>
            <para>The following structure, <c>IAS_SET</c>, is used with the IRLMP_IAS_SET setsockopt option to manage the local IAS database:</para>
            <para>The following structure, <c>IAS_QUERY</c>, is used with the IRLMP_IAS_QUERY setsockopt option to query a peer's IAS database:</para>
            <para>Many SO_ level socket options are not meaningful to IrDA. Only SO_LINGER is specifically supported.</para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.shutdown(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.SD)">
            <summary>The <c>shutdown</c> function disables sends or receives on a socket.</summary>
            <param name="s">A descriptor identifying a socket.</param>
            <param name="how">
            <para>
            A flag that describes what types of operation will no longer be allowed. Possible values for this flag are listed in the
            Winsock2.h header file.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SD_RECEIVE 0</term>
            <term>Shutdown receive operations.</term>
            </item>
            <item>
            <term>SD_SEND 1</term>
            <term>Shutdown send operations.</term>
            </item>
            <item>
            <term>SD_BOTH 2</term>
            <term>Shutdown both send and receive operations.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>
            If no error occurs, <c>shutdown</c> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can
            be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAECONNABORTED</term>
            <term>
            The virtual circuit was terminated due to a time-out or other failure. The application should close the socket as it is no
            longer usable. This error applies only to a connection-oriented socket.
            </term>
            </item>
            <item>
            <term>WSAECONNRESET</term>
            <term>
            The virtual circuit was reset by the remote side executing a hard or abortive close. The application should close the socket as
            it is no longer usable. This error applies only to a connection-oriented socket.
            </term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            The how parameter is not valid, or is not consistent with the socket type. For example, SD_SEND is used with a UNI_RECV socket type.
            </term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENOTCONN</term>
            <term>The socket is not connected. This error applies only to a connection-oriented socket.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term/>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>shutdown</c> function is used on all types of sockets to disable reception, transmission, or both.</para>
            <para>
            If the how parameter is SD_RECEIVE, subsequent calls to the recv function on the socket will be disallowed. This has no effect
            on the lower protocol layers. For TCP sockets, if there is still data queued on the socket waiting to be received, or data
            arrives subsequently, the connection is reset, since the data cannot be delivered to the user. For UDP sockets, incoming
            datagrams are accepted and queued. In no case will an ICMP error packet be generated.
            </para>
            <para>
            If the how parameter is SD_SEND, subsequent calls to the send function are disallowed. For TCP sockets, a FIN will be sent after
            all data is sent and acknowledged by the receiver.
            </para>
            <para>Setting how to SD_BOTH disables both sends and receives as described above.</para>
            <para>
            The <c>shutdown</c> function does not close the socket. Any resources attached to the socket will not be freed until closesocket
            is invoked.
            </para>
            <para>
            To assure that all data is sent and received on a connected socket before it is closed, an application should use
            <c>shutdown</c> to close connection before calling closesocket. One method to wait for notification that the remote end has sent
            all its data and initiated a graceful disconnect uses the WSAEventSelect function as follows :
            </para>
            <list type="number">
            <item>
            <term>Call WSAEventSelect to register for FD_CLOSE notification.</term>
            </item>
            <item>
            <term>Call <c>shutdown</c> with how=SD_SEND.</term>
            </item>
            <item>
            <term>
            When FD_CLOSE received, call the recv or WSARecv until the function completes with success and indicates that zero bytes were
            received. If SOCKET_ERROR is returned, then the graceful disconnect is not possible.
            </term>
            </item>
            <item>
            <term>Call closesocket.</term>
            </item>
            </list>
            <para>
            Another method to wait for notification that the remote end has sent all its data and initiated a graceful disconnect uses
            overlapped receive calls follows :
            </para>
            <list type="number">
            <item>
            <term>Call <c>shutdown</c> with how=SD_SEND.</term>
            </item>
            <item>
            <term>
            Call recv or WSARecv until the function completes with success and indicates zero bytes were received. If SOCKET_ERROR is
            returned, then the graceful disconnect is not possible.
            </term>
            </item>
            <item>
            <term>Call closesocket.</term>
            </item>
            </list>
            <para><c>Note</c> The <c>shutdown</c> function does not block regardless of the SO_LINGER setting on the socket.</para>
            <para>For more information, see the section on Graceful Shutdown, Linger Options, and Socket Closure.</para>
            <para>
            Once the <c>shutdown</c> function is called to disable send, receive, or both, there is no method to re-enable send or receive
            for the existing socket connection.
            </para>
            <para>
            An application should not rely on being able to reuse a socket after it has been shut down. In particular, a Windows Sockets
            provider is not required to support the use of connect on a socket that has been shut down.
            </para>
            <para>
            If an application wants to reuse a socket, then the DisconnectEx function should be called with the dwFlags parameter set to
            <c>TF_REUSE_SOCKET</c> to close a connection on a socket and prepare the socket handle to be reused. When the
            <c>DisconnectEx</c> request completes, the socket handle can be passed to the AcceptEx or ConnectEx function.
            </para>
            <para>
            If an application wants to reuse a socket, the TransmitFile or TransmitPackets functions can be called with the dwFlags
            parameter set with <c>TF_DISCONNECT</c> and <c>TF_REUSE_SOCKET</c> to disconnect after all the data has been queued for
            transmission and prepare the socket handle to be reused. When the <c>TransmitFile</c> request completes, the socket handle can
            be passed to the function call previously used to establish the connection, such as AcceptEx or ConnectEx. When the
            <c>TransmitPackets</c> function completes, the socket handle can be passed to the <c>AcceptEx</c> function.
            </para>
            <para>
            <c>Note</c> The socket level disconnect is subject to the behavior of the underlying transport. For example, a TCP socket may be
            subject to the TCP TIME_WAIT state, causing the DisconnectEx, TransmitFile, or TransmitPackets call to be delayed.
            </para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>shutdown</c>, Winsock may need to wait for a network event before
            the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous
            procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an
            ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients.
            </para>
            <para>Notes for ATM</para>
            <para>
            There are important issues associated with connection teardown when using Asynchronous Transfer Mode (ATM) and Windows Sockets
            2. For more information about these important considerations, see the section titled Notes for ATM in the Remarks section of the
            closesocket function reference.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.socket(Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY,Vanara.PInvoke.Ws2_32.SOCK,Vanara.PInvoke.Ws2_32.IPPROTO)">
            <summary>The <c>socket</c> function creates a socket that is bound to a specific transport service provider.</summary>
            <param name="af">
            <para>The address family specification. Possible values for the address family are defined in the Winsock2.h header file.</para>
            <para>
            On the Windows SDK released for Windows Vista and later, the organization of header files has changed and the possible values
            for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in
            Winsock2.h, and should never be used directly.
            </para>
            <para>
            The values currently supported are AF_INET or AF_INET6, which are the Internet address family formats for IPv4 and IPv6. Other
            options for address family (AF_NETBIOS for use with NetBIOS, for example) are supported if a Windows Sockets service provider
            for the address family is installed. Note that the values for the AF_ address family and PF_ protocol family constants are
            identical (for example, <c>AF_INET</c> and <c>PF_INET</c>), so either constant can be used.
            </para>
            <para>The table below lists common values for address family although many other values are possible.</para>
            <list type="table">
            <listheader>
            <term>Af</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AF_UNSPEC 0</term>
            <term>The address family is unspecified.</term>
            </item>
            <item>
            <term>AF_INET 2</term>
            <term>The Internet Protocol version 4 (IPv4) address family.</term>
            </item>
            <item>
            <term>AF_IPX 6</term>
            <term>
            The IPX/SPX address family. This address family is only supported if the NWLink IPX/SPX NetBIOS Compatible Transport protocol is
            installed. This address family is not supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AF_APPLETALK 16</term>
            <term>
            The AppleTalk address family. This address family is only supported if the AppleTalk protocol is installed. This address family
            is not supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AF_NETBIOS 17</term>
            <term>
            The NetBIOS address family. This address family is only supported if the Windows Sockets provider for NetBIOS is installed. The
            Windows Sockets provider for NetBIOS is supported on 32-bit versions of Windows. This provider is installed by default on 32-bit
            versions of Windows. The Windows Sockets provider for NetBIOS is not supported on 64-bit versions of windows including Windows
            7, Windows Server 2008, Windows Vista, Windows Server 2003, or Windows XP. The Windows Sockets provider for NetBIOS only
            supports sockets where the type parameter is set to SOCK_DGRAM. The Windows Sockets provider for NetBIOS is not directly related
            to the NetBIOS programming interface. The NetBIOS programming interface is not supported on Windows Vista, Windows Server 2008,
            and later.
            </term>
            </item>
            <item>
            <term>AF_INET6 23</term>
            <term>The Internet Protocol version 6 (IPv6) address family.</term>
            </item>
            <item>
            <term>AF_IRDA 26</term>
            <term>
            The Infrared Data Association (IrDA) address family. This address family is only supported if the computer has an infrared port
            and driver installed.
            </term>
            </item>
            <item>
            <term>AF_BTH 32</term>
            <term>
            The Bluetooth address family. This address family is supported on Windows XP with SP2 or later if the computer has a Bluetooth
            adapter and driver installed.
            </term>
            </item>
            </list>
            </param>
            <param name="type">
            <para>The type specification for the new socket.</para>
            <para>Possible values for the socket type are defined in the Winsock2.h header file.</para>
            <para>The following table lists the possible values for the type parameter supported for Windows Sockets 2:</para>
            <list type="table">
            <listheader>
            <term>Type</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SOCK_STREAM 1</term>
            <term>
            A socket type that provides sequenced, reliable, two-way, connection-based byte streams with an OOB data transmission mechanism.
            This socket type uses the Transmission Control Protocol (TCP) for the Internet address family (AF_INET or AF_INET6).
            </term>
            </item>
            <item>
            <term>SOCK_DGRAM 2</term>
            <term>
            A socket type that supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length.
            This socket type uses the User Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).
            </term>
            </item>
            <item>
            <term>SOCK_RAW 3</term>
            <term>
            A socket type that provides a raw socket that allows an application to manipulate the next upper-layer protocol header. To
            manipulate the IPv4 header, the IP_HDRINCL socket option must be set on the socket. To manipulate the IPv6 header, the
            IPV6_HDRINCL socket option must be set on the socket.
            </term>
            </item>
            <item>
            <term>SOCK_RDM 4</term>
            <term>
            A socket type that provides a reliable message datagram. An example of this type is the Pragmatic General Multicast (PGM)
            multicast protocol implementation in Windows, often referred to as reliable multicast programming. This type value is only
            supported if the Reliable Multicast Protocol is installed.
            </term>
            </item>
            <item>
            <term>SOCK_SEQPACKET 5</term>
            <term>A socket type that provides a pseudo-stream packet based on datagrams.</term>
            </item>
            </list>
            <para>
            In Windows Sockets 2, new socket types were introduced. An application can dynamically discover the attributes of each available
            transport protocol through the WSAEnumProtocols function. So an application can determine the possible socket type and protocol
            options for an address family and use this information when specifying this parameter. Socket type definitions in the Winsock2.h
            and Ws2def.h header files will be periodically updated as new socket types, address families, and protocols are defined.
            </para>
            <para>In Windows Sockets 1.1, the only possible socket types are <c>SOCK_DGRAM</c> and <c>SOCK_STREAM</c>.</para>
            </param>
            <param name="protocol">
            <para>
            The protocol to be used. The possible options for the protocol parameter are specific to the address family and socket type
            specified. Possible values for the protocol are defined in the Winsock2.h and Wsrm.h header files.
            </para>
            <para>
            On the Windows SDK released for Windows Vista and later, the organization of header files has changed and this parameter can be
            one of the values from the <c>IPPROTO</c> enumeration type defined in the Ws2def.h header file. Note that the Ws2def.h header
            file is automatically included in Winsock2.h, and should never be used directly.
            </para>
            <para>
            If a value of 0 is specified, the caller does not wish to specify a protocol and the service provider will choose the protocol
            to use.
            </para>
            <para>
            When the af parameter is AF_INET or AF_INET6 and the type is <c>SOCK_RAW</c>, the value specified for the protocol is set in the
            protocol field of the IPv6 or IPv4 packet header.
            </para>
            <para>The table below lists common values for the protocol although many other values are possible.</para>
            <list type="table">
            <listheader>
            <term>protocol</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>IPPROTO_ICMP 1</term>
            <term>
            The Internet Control Message Protocol (ICMP). This is a possible value when the af parameter is AF_UNSPEC, AF_INET, or AF_INET6
            and the type parameter is SOCK_RAW or unspecified. This protocol value is supported on Windows XP and later.
            </term>
            </item>
            <item>
            <term>IPPROTO_IGMP 2</term>
            <term>
            The Internet Group Management Protocol (IGMP). This is a possible value when the af parameter is AF_UNSPEC, AF_INET, or AF_INET6
            and the type parameter is SOCK_RAW or unspecified. This protocol value is supported on Windows XP and later.
            </term>
            </item>
            <item>
            <term>BTHPROTO_RFCOMM 3</term>
            <term>
            The Bluetooth Radio Frequency Communications (Bluetooth RFCOMM) protocol. This is a possible value when the af parameter is
            AF_BTH and the type parameter is SOCK_STREAM. This protocol value is supported on Windows XP with SP2 or later.
            </term>
            </item>
            <item>
            <term>IPPROTO_TCP 6</term>
            <term>
            The Transmission Control Protocol (TCP). This is a possible value when the af parameter is AF_INET or AF_INET6 and the type
            parameter is SOCK_STREAM.
            </term>
            </item>
            <item>
            <term>IPPROTO_UDP 17</term>
            <term>
            The User Datagram Protocol (UDP). This is a possible value when the af parameter is AF_INET or AF_INET6 and the type parameter
            is SOCK_DGRAM.
            </term>
            </item>
            <item>
            <term>IPPROTO_ICMPV6 58</term>
            <term>
            The Internet Control Message Protocol Version 6 (ICMPv6). This is a possible value when the af parameter is AF_UNSPEC, AF_INET,
            or AF_INET6 and the type parameter is SOCK_RAW or unspecified. This protocol value is supported on Windows XP and later.
            </term>
            </item>
            <item>
            <term>IPPROTO_RM 113</term>
            <term>
            The PGM protocol for reliable multicast. This is a possible value when the af parameter is AF_INET and the type parameter is
            SOCK_RDM. On the Windows SDK released for Windows Vista and later, this protocol is also called IPPROTO_PGM. This protocol value
            is only supported if the Reliable Multicast Protocol is installed.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>
            If no error occurs, <c>socket</c> returns a descriptor referencing the new socket. Otherwise, a value of INVALID_SOCKET is
            returned, and a specific error code can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem or the associated service provider has failed.</term>
            </item>
            <item>
            <term>WSAEAFNOSUPPORT</term>
            <term>
            The specified address family is not supported. For example, an application tried to create a socket for the AF_IRDA address
            family but an infrared adapter and device driver is not installed on the local computer.
            </term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEMFILE</term>
            <term>No more socket descriptors are available.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            An invalid argument was supplied. This error is returned if the af parameter is set to AF_UNSPEC and the type and protocol
            parameter are unspecified.
            </term>
            </item>
            <item>
            <term>WSAEINVALIDPROVIDER</term>
            <term>The service provider returned a version other than 2.2.</term>
            </item>
            <item>
            <term>WSAEINVALIDPROCTABLE</term>
            <term>The service provider returned an invalid or incomplete procedure table to the WSPStartup.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>No buffer space is available. The socket cannot be created.</term>
            </item>
            <item>
            <term>WSAEPROTONOSUPPORT</term>
            <term>The specified protocol is not supported.</term>
            </item>
            <item>
            <term>WSAEPROTOTYPE</term>
            <term>The specified protocol is the wrong type for this socket.</term>
            </item>
            <item>
            <term>WSAEPROVIDERFAILEDINIT</term>
            <term>
            The service provider failed to initialize. This error is returned if a layered service provider (LSP) or namespace provider was
            improperly installed or the provider fails to operate correctly.
            </term>
            </item>
            <item>
            <term>WSAESOCKTNOSUPPORT</term>
            <term>The specified socket type is not supported in this address family.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>socket</c> function causes a socket descriptor and any related resources to be allocated and bound to a specific
            transport-service provider. Winsock will utilize the first available service provider that supports the requested combination of
            address family, socket type and protocol parameters. The socket that is created will have the overlapped attribute as a default.
            For Windows, the Microsoft-specific socket option, SO_OPENTYPE, defined in Mswsock.h can affect this default. See
            Microsoft-specific documentation for a detailed description of SO_OPENTYPE.
            </para>
            <para>
            Sockets without the overlapped attribute can be created by using WSASocket. All functions that allow overlapped operation
            (WSASend, WSARecv, WSASendTo, WSARecvFrom, and WSAIoctl) also support nonoverlapped usage on an overlapped socket if the values
            for parameters related to overlapped operation are <c>NULL</c>.
            </para>
            <para>
            When selecting a protocol and its supporting service provider this procedure will only choose a base protocol or a protocol
            chain, not a protocol layer by itself. Unchained protocol layers are not considered to have partial matches on type or af
            either. That is, they do not lead to an error code of WSAEAFNOSUPPORT or WSAEPROTONOSUPPORT if no suitable protocol is found.
            </para>
            <para>
            <c>Note</c> The manifest constant <c>AF_UNSPEC</c> continues to be defined in the header file but its use is strongly
            discouraged, as this can cause ambiguity in interpreting the value of the protocol parameter.
            </para>
            <para>
            Applications are encouraged to use <c>AF_INET6</c> for the af parameter and create a dual-mode socket that can be used with both
            IPv4 and IPv6.
            </para>
            <para>
            Connection-oriented sockets such as <c>SOCK_STREAM</c> provide full-duplex connections, and must be in a connected state before
            any data can be sent or received on it. A connection to another socket is created with a connect call. Once connected, data can
            be transferred using send and recv calls. When a session has been completed, a closesocket must be performed.
            </para>
            <para>
            The communications protocols used to implement a reliable, connection-oriented socket ensure that data is not lost or
            duplicated. If data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable length
            of time, the connection is considered broken and subsequent calls will fail with the error code set to WSAETIMEDOUT.
            </para>
            <para>
            Connectionless, message-oriented sockets allow sending and receiving of datagrams to and from arbitrary peers using sendto and
            recvfrom. If such a socket is connected to a specific peer, datagrams can be sent to that peer using send and can be received
            only from this peer using recv.
            </para>
            <para>
            IPv6 and IPv4 operate differently when receiving a socket with a type of <c>SOCK_RAW</c>. The IPv4 receive packet includes the
            packet payload, the next upper-level header (for example, the IP header for a TCP or UDP packet), and the IPv4 packet header.
            The IPv6 receive packet includes the packet payload and the next upper-level header. The IPv6 receive packet never includes the
            IPv6 packet header.
            </para>
            <para><c>Note</c> On Windows NT, raw socket support requires administrative privileges.</para>
            <para>
            A socket with a type parameter of <c>SOCK_SEQPACKET</c> is based on datagrams, but functions as a pseudo-stream protocol. For
            both send and receive packets, separate datagrams are used. However, Windows Sockets can coalesce multiple receive packets into
            a single packet. So an application can issue a receive call (for example, recv or WSARecvEx) and retrieve the data from several
            coalesced multiple packets in single call. The AF_NETBIOS address family supports a type parameter of <c>SOCK_SEQPACKET</c>.
            </para>
            <para>
            When the af parameter is <c>AF_NETBIOS</c> for NetBIOS over TCP/IP, the type parameter can be <c>SOCK_DGRAM</c> or
            <c>SOCK_SEQPACKET</c>. For the <c>AF_NETBIOS</c> address family, the protocol parameter is the LAN adapter number represented as
            a negative number.
            </para>
            <para>
            On Windows XP and later, the following command can be used to list the Windows Sockets catalog to determine the service
            providers installed and the address family, socket type, and protocols that are supported.
            </para>
            <para><c>netsh winsock show catalog</c></para>
            <para>
            Support for sockets with type <c>SOCK_RAW</c> is not required, but service providers are encouraged to support raw sockets as practicable.
            </para>
            <para>Notes for IrDA Sockets</para>
            <para>Keep the following in mind:</para>
            <list type="bullet">
            <item>
            <term>The Af_irda.h header file must be explicitly included.</term>
            </item>
            <item>
            <term>Only <c>SOCK_STREAM</c> is supported; the <c>SOCK_DGRAM</c> type is not supported by IrDA.</term>
            </item>
            <item>
            <term>The protocol parameter is always set to 0 for IrDA.</term>
            </item>
            </list>
            <para>
            A socket for use with the AF_IRDA address family can only be created if the local computer has an infrared port and driver
            installed. Otherwise, a call to the <c>socket</c> function with af parameter set to AF_IRDA will fail and WSAGetLastError
            returns WSAEPROTONOSUPPORT.
            </para>
            <para>Example Code</para>
            <para>
            The following example demonstrates the use of the <c>socket</c> function to create a socket that is bound to a specific
            transport service provider..
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.socket(Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY,Vanara.PInvoke.Ws2_32.SOCK,System.UInt32)">
            <summary>The <c>socket</c> function creates a socket that is bound to a specific transport service provider.</summary>
            <param name="af">
            <para>The address family specification. Possible values for the address family are defined in the Winsock2.h header file.</para>
            <para>
            On the Windows SDK released for Windows Vista and later, the organization of header files has changed and the possible values
            for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in
            Winsock2.h, and should never be used directly.
            </para>
            <para>
            The values currently supported are AF_INET or AF_INET6, which are the Internet address family formats for IPv4 and IPv6. Other
            options for address family (AF_NETBIOS for use with NetBIOS, for example) are supported if a Windows Sockets service provider
            for the address family is installed. Note that the values for the AF_ address family and PF_ protocol family constants are
            identical (for example, <c>AF_INET</c> and <c>PF_INET</c>), so either constant can be used.
            </para>
            <para>The table below lists common values for address family although many other values are possible.</para>
            <list type="table">
            <listheader>
            <term>Af</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AF_UNSPEC 0</term>
            <term>The address family is unspecified.</term>
            </item>
            <item>
            <term>AF_INET 2</term>
            <term>The Internet Protocol version 4 (IPv4) address family.</term>
            </item>
            <item>
            <term>AF_IPX 6</term>
            <term>
            The IPX/SPX address family. This address family is only supported if the NWLink IPX/SPX NetBIOS Compatible Transport protocol is
            installed. This address family is not supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AF_APPLETALK 16</term>
            <term>
            The AppleTalk address family. This address family is only supported if the AppleTalk protocol is installed. This address family
            is not supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AF_NETBIOS 17</term>
            <term>
            The NetBIOS address family. This address family is only supported if the Windows Sockets provider for NetBIOS is installed. The
            Windows Sockets provider for NetBIOS is supported on 32-bit versions of Windows. This provider is installed by default on 32-bit
            versions of Windows. The Windows Sockets provider for NetBIOS is not supported on 64-bit versions of windows including Windows
            7, Windows Server 2008, Windows Vista, Windows Server 2003, or Windows XP. The Windows Sockets provider for NetBIOS only
            supports sockets where the type parameter is set to SOCK_DGRAM. The Windows Sockets provider for NetBIOS is not directly related
            to the NetBIOS programming interface. The NetBIOS programming interface is not supported on Windows Vista, Windows Server 2008,
            and later.
            </term>
            </item>
            <item>
            <term>AF_INET6 23</term>
            <term>The Internet Protocol version 6 (IPv6) address family.</term>
            </item>
            <item>
            <term>AF_IRDA 26</term>
            <term>
            The Infrared Data Association (IrDA) address family. This address family is only supported if the computer has an infrared port
            and driver installed.
            </term>
            </item>
            <item>
            <term>AF_BTH 32</term>
            <term>
            The Bluetooth address family. This address family is supported on Windows XP with SP2 or later if the computer has a Bluetooth
            adapter and driver installed.
            </term>
            </item>
            </list>
            </param>
            <param name="type">
            <para>The type specification for the new socket.</para>
            <para>Possible values for the socket type are defined in the Winsock2.h header file.</para>
            <para>The following table lists the possible values for the type parameter supported for Windows Sockets 2:</para>
            <list type="table">
            <listheader>
            <term>Type</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SOCK_STREAM 1</term>
            <term>
            A socket type that provides sequenced, reliable, two-way, connection-based byte streams with an OOB data transmission mechanism.
            This socket type uses the Transmission Control Protocol (TCP) for the Internet address family (AF_INET or AF_INET6).
            </term>
            </item>
            <item>
            <term>SOCK_DGRAM 2</term>
            <term>
            A socket type that supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length.
            This socket type uses the User Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).
            </term>
            </item>
            <item>
            <term>SOCK_RAW 3</term>
            <term>
            A socket type that provides a raw socket that allows an application to manipulate the next upper-layer protocol header. To
            manipulate the IPv4 header, the IP_HDRINCL socket option must be set on the socket. To manipulate the IPv6 header, the
            IPV6_HDRINCL socket option must be set on the socket.
            </term>
            </item>
            <item>
            <term>SOCK_RDM 4</term>
            <term>
            A socket type that provides a reliable message datagram. An example of this type is the Pragmatic General Multicast (PGM)
            multicast protocol implementation in Windows, often referred to as reliable multicast programming. This type value is only
            supported if the Reliable Multicast Protocol is installed.
            </term>
            </item>
            <item>
            <term>SOCK_SEQPACKET 5</term>
            <term>A socket type that provides a pseudo-stream packet based on datagrams.</term>
            </item>
            </list>
            <para>
            In Windows Sockets 2, new socket types were introduced. An application can dynamically discover the attributes of each available
            transport protocol through the WSAEnumProtocols function. So an application can determine the possible socket type and protocol
            options for an address family and use this information when specifying this parameter. Socket type definitions in the Winsock2.h
            and Ws2def.h header files will be periodically updated as new socket types, address families, and protocols are defined.
            </para>
            <para>In Windows Sockets 1.1, the only possible socket types are <c>SOCK_DGRAM</c> and <c>SOCK_STREAM</c>.</para>
            </param>
            <param name="protocol">
            <para>
            The protocol to be used. The possible options for the protocol parameter are specific to the address family and socket type
            specified. Possible values for the protocol are defined in the Winsock2.h and Wsrm.h header files.
            </para>
            <para>
            On the Windows SDK released for Windows Vista and later, the organization of header files has changed and this parameter can be
            one of the values from the <c>IPPROTO</c> enumeration type defined in the Ws2def.h header file. Note that the Ws2def.h header
            file is automatically included in Winsock2.h, and should never be used directly.
            </para>
            <para>
            If a value of 0 is specified, the caller does not wish to specify a protocol and the service provider will choose the protocol
            to use.
            </para>
            <para>
            When the af parameter is AF_INET or AF_INET6 and the type is <c>SOCK_RAW</c>, the value specified for the protocol is set in the
            protocol field of the IPv6 or IPv4 packet header.
            </para>
            <para>The table below lists common values for the protocol although many other values are possible.</para>
            <list type="table">
            <listheader>
            <term>protocol</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>IPPROTO_ICMP 1</term>
            <term>
            The Internet Control Message Protocol (ICMP). This is a possible value when the af parameter is AF_UNSPEC, AF_INET, or AF_INET6
            and the type parameter is SOCK_RAW or unspecified. This protocol value is supported on Windows XP and later.
            </term>
            </item>
            <item>
            <term>IPPROTO_IGMP 2</term>
            <term>
            The Internet Group Management Protocol (IGMP). This is a possible value when the af parameter is AF_UNSPEC, AF_INET, or AF_INET6
            and the type parameter is SOCK_RAW or unspecified. This protocol value is supported on Windows XP and later.
            </term>
            </item>
            <item>
            <term>BTHPROTO_RFCOMM 3</term>
            <term>
            The Bluetooth Radio Frequency Communications (Bluetooth RFCOMM) protocol. This is a possible value when the af parameter is
            AF_BTH and the type parameter is SOCK_STREAM. This protocol value is supported on Windows XP with SP2 or later.
            </term>
            </item>
            <item>
            <term>IPPROTO_TCP 6</term>
            <term>
            The Transmission Control Protocol (TCP). This is a possible value when the af parameter is AF_INET or AF_INET6 and the type
            parameter is SOCK_STREAM.
            </term>
            </item>
            <item>
            <term>IPPROTO_UDP 17</term>
            <term>
            The User Datagram Protocol (UDP). This is a possible value when the af parameter is AF_INET or AF_INET6 and the type parameter
            is SOCK_DGRAM.
            </term>
            </item>
            <item>
            <term>IPPROTO_ICMPV6 58</term>
            <term>
            The Internet Control Message Protocol Version 6 (ICMPv6). This is a possible value when the af parameter is AF_UNSPEC, AF_INET,
            or AF_INET6 and the type parameter is SOCK_RAW or unspecified. This protocol value is supported on Windows XP and later.
            </term>
            </item>
            <item>
            <term>IPPROTO_RM 113</term>
            <term>
            The PGM protocol for reliable multicast. This is a possible value when the af parameter is AF_INET and the type parameter is
            SOCK_RDM. On the Windows SDK released for Windows Vista and later, this protocol is also called IPPROTO_PGM. This protocol value
            is only supported if the Reliable Multicast Protocol is installed.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>
            If no error occurs, <c>socket</c> returns a descriptor referencing the new socket. Otherwise, a value of INVALID_SOCKET is
            returned, and a specific error code can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem or the associated service provider has failed.</term>
            </item>
            <item>
            <term>WSAEAFNOSUPPORT</term>
            <term>
            The specified address family is not supported. For example, an application tried to create a socket for the AF_IRDA address
            family but an infrared adapter and device driver is not installed on the local computer.
            </term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEMFILE</term>
            <term>No more socket descriptors are available.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            An invalid argument was supplied. This error is returned if the af parameter is set to AF_UNSPEC and the type and protocol
            parameter are unspecified.
            </term>
            </item>
            <item>
            <term>WSAEINVALIDPROVIDER</term>
            <term>The service provider returned a version other than 2.2.</term>
            </item>
            <item>
            <term>WSAEINVALIDPROCTABLE</term>
            <term>The service provider returned an invalid or incomplete procedure table to the WSPStartup.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>No buffer space is available. The socket cannot be created.</term>
            </item>
            <item>
            <term>WSAEPROTONOSUPPORT</term>
            <term>The specified protocol is not supported.</term>
            </item>
            <item>
            <term>WSAEPROTOTYPE</term>
            <term>The specified protocol is the wrong type for this socket.</term>
            </item>
            <item>
            <term>WSAEPROVIDERFAILEDINIT</term>
            <term>
            The service provider failed to initialize. This error is returned if a layered service provider (LSP) or namespace provider was
            improperly installed or the provider fails to operate correctly.
            </term>
            </item>
            <item>
            <term>WSAESOCKTNOSUPPORT</term>
            <term>The specified socket type is not supported in this address family.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>socket</c> function causes a socket descriptor and any related resources to be allocated and bound to a specific
            transport-service provider. Winsock will utilize the first available service provider that supports the requested combination of
            address family, socket type and protocol parameters. The socket that is created will have the overlapped attribute as a default.
            For Windows, the Microsoft-specific socket option, SO_OPENTYPE, defined in Mswsock.h can affect this default. See
            Microsoft-specific documentation for a detailed description of SO_OPENTYPE.
            </para>
            <para>
            Sockets without the overlapped attribute can be created by using WSASocket. All functions that allow overlapped operation
            (WSASend, WSARecv, WSASendTo, WSARecvFrom, and WSAIoctl) also support nonoverlapped usage on an overlapped socket if the values
            for parameters related to overlapped operation are <c>NULL</c>.
            </para>
            <para>
            When selecting a protocol and its supporting service provider this procedure will only choose a base protocol or a protocol
            chain, not a protocol layer by itself. Unchained protocol layers are not considered to have partial matches on type or af
            either. That is, they do not lead to an error code of WSAEAFNOSUPPORT or WSAEPROTONOSUPPORT if no suitable protocol is found.
            </para>
            <para>
            <c>Note</c> The manifest constant <c>AF_UNSPEC</c> continues to be defined in the header file but its use is strongly
            discouraged, as this can cause ambiguity in interpreting the value of the protocol parameter.
            </para>
            <para>
            Applications are encouraged to use <c>AF_INET6</c> for the af parameter and create a dual-mode socket that can be used with both
            IPv4 and IPv6.
            </para>
            <para>
            Connection-oriented sockets such as <c>SOCK_STREAM</c> provide full-duplex connections, and must be in a connected state before
            any data can be sent or received on it. A connection to another socket is created with a connect call. Once connected, data can
            be transferred using send and recv calls. When a session has been completed, a closesocket must be performed.
            </para>
            <para>
            The communications protocols used to implement a reliable, connection-oriented socket ensure that data is not lost or
            duplicated. If data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable length
            of time, the connection is considered broken and subsequent calls will fail with the error code set to WSAETIMEDOUT.
            </para>
            <para>
            Connectionless, message-oriented sockets allow sending and receiving of datagrams to and from arbitrary peers using sendto and
            recvfrom. If such a socket is connected to a specific peer, datagrams can be sent to that peer using send and can be received
            only from this peer using recv.
            </para>
            <para>
            IPv6 and IPv4 operate differently when receiving a socket with a type of <c>SOCK_RAW</c>. The IPv4 receive packet includes the
            packet payload, the next upper-level header (for example, the IP header for a TCP or UDP packet), and the IPv4 packet header.
            The IPv6 receive packet includes the packet payload and the next upper-level header. The IPv6 receive packet never includes the
            IPv6 packet header.
            </para>
            <para><c>Note</c> On Windows NT, raw socket support requires administrative privileges.</para>
            <para>
            A socket with a type parameter of <c>SOCK_SEQPACKET</c> is based on datagrams, but functions as a pseudo-stream protocol. For
            both send and receive packets, separate datagrams are used. However, Windows Sockets can coalesce multiple receive packets into
            a single packet. So an application can issue a receive call (for example, recv or WSARecvEx) and retrieve the data from several
            coalesced multiple packets in single call. The AF_NETBIOS address family supports a type parameter of <c>SOCK_SEQPACKET</c>.
            </para>
            <para>
            When the af parameter is <c>AF_NETBIOS</c> for NetBIOS over TCP/IP, the type parameter can be <c>SOCK_DGRAM</c> or
            <c>SOCK_SEQPACKET</c>. For the <c>AF_NETBIOS</c> address family, the protocol parameter is the LAN adapter number represented as
            a negative number.
            </para>
            <para>
            On Windows XP and later, the following command can be used to list the Windows Sockets catalog to determine the service
            providers installed and the address family, socket type, and protocols that are supported.
            </para>
            <para><c>netsh winsock show catalog</c></para>
            <para>
            Support for sockets with type <c>SOCK_RAW</c> is not required, but service providers are encouraged to support raw sockets as practicable.
            </para>
            <para>Notes for IrDA Sockets</para>
            <para>Keep the following in mind:</para>
            <list type="bullet">
            <item>
            <term>The Af_irda.h header file must be explicitly included.</term>
            </item>
            <item>
            <term>Only <c>SOCK_STREAM</c> is supported; the <c>SOCK_DGRAM</c> type is not supported by IrDA.</term>
            </item>
            <item>
            <term>The protocol parameter is always set to 0 for IrDA.</term>
            </item>
            </list>
            <para>
            A socket for use with the AF_IRDA address family can only be created if the local computer has an infrared port and driver
            installed. Otherwise, a call to the <c>socket</c> function with af parameter set to AF_IRDA will fail and WSAGetLastError
            returns WSAEPROTONOSUPPORT.
            </para>
            <para>Example Code</para>
            <para>
            The following example demonstrates the use of the <c>socket</c> function to create a socket that is bound to a specific
            transport service provider..
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.PROTOENT">
            <summary>
            The <c>protoent</c> structure contains the name and protocol numbers that correspond to a given protocol name. Applications must
            never attempt to modify this structure or to free any of its components. Furthermore, only one copy of this structure is
            allocated per thread, and therefore, the application should copy any information it needs before issuing any other Windows
            Sockets function calls.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.PROTOENT.p_name">
            <summary>Official name of the protocol.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.PROTOENT.p_aliases">
            <summary>Null-terminated array of alternate names.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.PROTOENT.p_proto">
            <summary>Protocol number, in host byte order.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.PROTOENT.Aliases">
            <summary>Array of alternate names extracted from <see cref="F:Vanara.PInvoke.Ws2_32.PROTOENT.p_aliases"/>.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SERVENT">
            <summary>The <c>servent</c> structure is used to store or return the name and service number for a given service name.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SERVENT.s_name">
            <summary>The official name of the service.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SERVENT.s_aliases">
            <summary>A <c>NULL</c>-terminated array of alternate names.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SERVENT.s_port">
            <summary>The port number at which the service can be contacted. Port numbers are returned in network byte order.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SERVENT.s_proto">
            <summary>The name of the protocol to use when contacting the service.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SERVENT.FromIntPtr(System.IntPtr)">
            <summary>Use this method to address different structure layouts on 64-bit systems.</summary>
            <param name="ptr">The ptr to convert.</param>
            <returns>A SERVENT structure aligned correctly.</returns>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.LPWSAOVERLAPPED_COMPLETION_ROUTINE">
            <summary>The CompletionRoutine is a placeholder for an application-defined or library-defined function name.</summary>
            <param name="dwError">Specifies the completion status for the overlapped operation as indicated by lpOverlapped.</param>
            <param name="cbTransferred">Specifies the number of bytes received.</param>
            <param name="lpOverlapped">The overlapped operation.</param>
            <param name="dwFlags">Contains information that would have appeared in lpFlags if the receive operation had completed immediately.</param>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.FD">
            <summary>Network events.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.FD.FD_READ">
            <summary>Wants to receive notification of readiness for reading.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.FD.FD_WRITE">
            <summary>Wants to receive notification of readiness for writing.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.FD.FD_OOB">
            <summary>Wants to receive notification of the arrival of OOB data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.FD.FD_ACCEPT">
            <summary>Wants to receive notification of incoming connections.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.FD.FD_CONNECT">
            <summary>Wants to receive notification of completed connection or multipoint join operation.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.FD.FD_CLOSE">
            <summary>Wants to receive notification of socket closure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.FD.FD_QOS">
            <summary>Wants to receive notification of socket (QoS changes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.FD.FD_GROUP_QOS">
            <summary>Reserved for future use with socket groups. Want to receive notification of socket group QoS changes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.FD.FD_ROUTING_INTERFACE_CHANGE">
            <summary>Wants to receive notification of routing interface changes for the specified destination.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.FD.FD_ADDRESS_LIST_CHANGE">
            <summary>Wants to receive notification of local address list changes for the address family of the socket.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.FD.FD_ALL_EVENTS">
            <summary>All events.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.JL">
            <summary>Flags to indicate that the socket is acting as a sender (JL_SENDER_ONLY), receiver (JL_RECEIVER_ONLY), or both (JL_BOTH).</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.JL.JL_SENDER_ONLY">
            <summary>Acting as a sender.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.JL.JL_RECEIVER_ONLY">
            <summary>Acting as a receiver.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.JL.JL_BOTH">
            <summary>Acting as both sender and receiver.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.LUP">
            <summary>Flags that control the depth of the search.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_DEEP">
            <summary>Queries deep as opposed to just the first level.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_CONTAINERS">
            <summary>Returns containers only.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_NOCONTAINERS">
            <summary>Do not return containers.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_NEAREST">
            <summary>If possible, returns results in the order of distance. The measure of distance is provider specific.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_RETURN_NAME">
            <summary>Retrieves the name as lpszServiceInstanceName.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_RETURN_TYPE">
            <summary>Retrieves the type as lpServiceClassId.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_RETURN_VERSION">
            <summary>Retrieves the version as lpVersion.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_RETURN_COMMENT">
            <summary>Retrieves the comment as lpszComment.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_RETURN_ADDR">
            <summary>Retrieves the addresses as lpcsaBuffer.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_RETURN_BLOB">
            <summary>Retrieves the private data as lpBlob.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_RETURN_ALIASES">
            <summary>
            Any available alias information is to be returned in successive calls to WSALookupServiceNext, and each alias returned will
            have the RESULT_IS_ALIAS flag set.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_RETURN_QUERY_STRING">
            <summary>Retrieves the query string used for the request.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_RETURN_ALL">
            <summary>A set of flags that retrieves all of the LUP_RETURN_* values.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_FLUSHCACHE">
            <summary>If the provider has cached information, ignore the cache and query the namespace itself.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_FLUSHPREVIOUS">
            <summary>
            Used as a value for the dwControlFlags parameter in NSPLookupServiceNext. Setting this flag instructs the provider to
            discard the last result set, which was too large for the supplied buffer, and move on to the next result set.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_NON_AUTHORITATIVE">
            <summary>Indicates that the namespace provider should included non-authoritative results for names.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_RES_SERVICE">
            <summary>
            Indicates whether prime response is in the remote or local part of CSADDR_INFO structure. The other part must be usable in
            either case. This option applies only to service instance requests.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_SECURE">
            <summary>Indicates that the namespace provider should use a secure query. This option only applies to name query requests.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_RETURN_PREFERRED_NAMES">
            <summary>Indicates that the namespace provider should return only preferred names.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_ADDRCONFIG">
            <summary>Indicates that the namespace provider should return the address configuration.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_DUAL_ADDR">
            <summary>
            Indicates that the namespace provider should return the dual addresses. This option only applies to dual-mode sockets (IPv6
            and IPv4 mapped addresses).
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_DNS_ONLY">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_FILESERVER">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_DISABLE_IDN_ENCODING">
            <summary>
            Indicates that the namespace provider should disable automatic International Domain Names encoding. This value is supported
            on Windows 8 and Windows Server 2012
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_API_ANSI">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.LUP.LUP_RESOLUTION_HANDLE">
            <summary/>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.MsgFlags">
            <summary>
            The lpFlags parameter can be used to influence the behavior of the function invocation beyond the options specified for the
            associated socket. That is, the semantics of this function are determined by the socket options and the lpFlags parameter.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.MsgFlags.MSG_OOB">
            <summary>Processes OOB data.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.MsgFlags.MSG_PEEK">
            <summary>
            Peeks at the incoming data. The data is copied into the buffer, but is not removed from the input queue. This flag is valid
            only for nonoverlapped sockets.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.MsgFlags.MSG_DONTROUTE">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.MsgFlags.MSG_WAITALL">
            <summary>
            The receive request will complete only when one of the following events occurs: Be aware that if the underlying transport
            provider does not support MSG_WAITALL, or if the socket is in a non-blocking mode, then this call will fail with
            WSAEOPNOTSUPP. Also, if MSG_WAITALL is specified along with MSG_OOB, MSG_PEEK, or MSG_PARTIAL, then this call will fail with
            WSAEOPNOTSUPP. This flag is not supported on datagram sockets or message-oriented sockets.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.MsgFlags.MSG_PUSH_IMMEDIATE">
            <summary>
            This flag is for stream-oriented sockets only. This flag allows an application that uses stream sockets to tell the
            transport provider not to delay completion of partially filled pending receive requests. This is a hint to the transport
            provider that the application is willing to receive any incoming data as soon as possible without necessarily waiting for
            the remainder of the data that might still be in transit. What constitutes a partially filled pending receive request is a
            transport-specific matter. In the case of TCP, this refers to the case of incoming TCP segments being placed into the
            receive request data buffer where none of the TCP segments indicated a PUSH bit value of 1. In this case, TCP may hold the
            partially filled receive request a little longer to allow the remainder of the data to arrive with a TCP segment that has
            the PUSH bit set to 1. This flag tells TCP not to hold the receive request but to complete it immediately. Using this flag
            for large block transfers is not recommended since processing partial blocks is often not optimal. This flag is useful only
            for cases where receiving and processing the partial data immediately helps decrease processing latency. This flag is a hint
            rather than an actual guarantee. This flag is supported on Windows 8.1, Windows Server 2012 R2, and later.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.MsgFlags.MSG_PARTIAL">
            <summary>
            This flag is for message-oriented sockets only. On output, this flag indicates that the data specified is a portion of the
            message transmitted by the sender. Remaining portions of the message will be specified in subsequent receive operations. A
            subsequent receive operation with the MSG_PARTIAL flag cleared indicates end of sender's message. As an input parameter,
            this flag indicates that the receive operation should complete even if only part of a message has been received by the
            transport provider.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.MsgFlags.MSG_INTERRUPT">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.MsgFlags.MSG_TRUNC">
            <summary>The datagram was truncated. More data was present than the process allocated room for.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.MsgFlags.MSG_CTRUNC">
            <summary>The control (ancillary) data was truncated. More control data was present than the process allocated room for.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.MsgFlags.MSG_BCAST">
            <summary>The datagram was received as a link-layer broadcast or with a destination IP address that is a broadcast address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.MsgFlags.MSG_MCAST">
            <summary>The datagram was received with a destination IP address that is a multicast address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.MsgFlags.MSG_ERRQUEUE">
            <summary>
            This flag specifies that queued errors should be received from the socket error queue. The error is passed in an ancillary
            message with a type dependent on the protocol (for IPv4 IP_RECVERR). The user should supply a buffer of sufficient size.See
            cmsg(3) and ip(7) for more information.The payload of the original packet that caused the error is passed as normal data via
            msg_iovec. The original destination address of the datagram that caused the error is supplied via msg_name.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.PollFlags">
            <summary>
            A set of flags that indicate the type of status being requested or, upon return from the WSAPoll function call, the results of
            the status query.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.PollFlags.POLLRDNORM">
            <summary>Normal data may be read without blocking.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.PollFlags.POLLRDBAND">
            <summary>Priority band (out-of-band) data may be read without blocking.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.PollFlags.POLLIN">
            <summary>POLLRDNORM | POLLRDBAND</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.PollFlags.POLLPRI">
            <summary>Priority data may be read without blocking. This flag is not returned by the Microsoft Winsock provider.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.PollFlags.POLLWRNORM">
            <summary>Normal data may be written without blocking.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.PollFlags.POLLOUT">
            <summary>Normal data may be written without blocking.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.PollFlags.POLLWRBAND">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.PollFlags.POLLERR">
            <summary>An error has occurred.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.PollFlags.POLLHUP">
            <summary>A stream-oriented connection was either disconnected or aborted.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.PollFlags.POLLNVAL">
            <summary>An invalid socket was used.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.ServiceInstallFlags">
            <summary>Service install flags value that further controls the operation performed of the WSASetServicefunction.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ServiceInstallFlags.SERVICE_MULTIPLE">
            <summary>
            Controls scope of operation. When this flag is not set, service addresses are managed as a group. A register or removal from
            the registry invalidates all existing addresses before adding the given address set. When set, the action is only performed
            on the given address set. A register does not invalidate existing addresses and a removal from the registry only invalidates
            the given set of addresses.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WSA_FLAG">
            <summary>A set of flags used to specify additional socket attributes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSA_FLAG.WSA_FLAG_OVERLAPPED">
            <term>
            Create a socket that supports overlapped I/O operations. Most sockets should be created with this flag set. Overlapped
            sockets can utilize WSASend, WSASendTo, WSARecv, WSARecvFrom, and WSAIoctl for overlapped I/O operations, which allow
            multiple operations to be initiated and in progress simultaneously. All functions that allow overlapped operation (WSASend,
            WSARecv, WSASendTo, WSARecvFrom, WSAIoctl) also support nonoverlapped usage on an overlapped socket if the values for
            parameters related to overlapped operations are NULL.
            </term>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSA_FLAG.WSA_FLAG_MULTIPOINT_C_ROOT">
            <term>
            Create a socket that will be a c_root in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO
            structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the control
            plane for a multipoint session is rooted. This would be indicated by the dwServiceFlags1 member of the WSAPROTOCOL_INFO
            structure with the XP1_SUPPORT_MULTIPOINT and XP1_MULTIPOINT_CONTROL_PLANE flags set. When the lpProtocolInfo parameter is
            not NULL, the WSAPROTOCOL_INFO structure for the transport provider is pointed to by the lpProtocolInfo parameter. When the
            lpProtocolInfo parameter is NULL, the WSAPROTOCOL_INFO structure is based on the transport provider selected by the values
            specified for the af, type, and protocol parameters. Refer to Multipoint and Multicast Semantics for additional information
            on a multipoint session.
            </term>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSA_FLAG.WSA_FLAG_MULTIPOINT_C_LEAF">
            <term>
            Create a socket that will be a c_leaf in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO
            structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the control
            plane for a multipoint session is non-rooted. This would be indicated by the dwServiceFlags1 member of the WSAPROTOCOL_INFO
            structure with the XP1_SUPPORT_MULTIPOINT flag set and the XP1_MULTIPOINT_CONTROL_PLANE flag not set. When the
            lpProtocolInfo parameter is not NULL, the WSAPROTOCOL_INFO structure for the transport provider is pointed to by the
            lpProtocolInfo parameter. When the lpProtocolInfo parameter is NULL, the WSAPROTOCOL_INFO structure is based on the
            transport provider selected by the values specified for the af, type, and protocol parameters. Refer to Multipoint and
            Multicast Semantics for additional information on a multipoint session.
            </term>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSA_FLAG.WSA_FLAG_MULTIPOINT_D_ROOT">
            <term>
            Create a socket that will be a d_root in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO
            structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the data plane
            for a multipoint session is rooted. This would be indicated by the dwServiceFlags1 member of the WSAPROTOCOL_INFO structure
            with the XP1_SUPPORT_MULTIPOINT and XP1_MULTIPOINT_DATA_PLANE flags set. When the lpProtocolInfo parameter is not NULL, the
            WSAPROTOCOL_INFO structure for the transport provider is pointed to by the lpProtocolInfo parameter. When the lpProtocolInfo
            parameter is NULL, the WSAPROTOCOL_INFO structure is based on the transport provider selected by the values specified for
            the af, type, and protocol parameters. Refer to Multipoint and Multicast Semantics for additional information on a
            multipoint session.
            </term>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSA_FLAG.WSA_FLAG_MULTIPOINT_D_LEAF">
            <term>
            Create a socket that will be a d_leaf in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO
            structure for the transport provider that creates the socket supports a multipoint or multicast mechanism and the data plane
            for a multipoint session is non-rooted. This would be indicated by the dwServiceFlags1 member of the WSAPROTOCOL_INFO
            structure with the XP1_SUPPORT_MULTIPOINT flag set and the XP1_MULTIPOINT_DATA_PLANE flag not set. When the lpProtocolInfo
            parameter is not NULL, the WSAPROTOCOL_INFO structure for the transport provider is pointed to by the lpProtocolInfo
            parameter. When the lpProtocolInfo parameter is NULL, the WSAPROTOCOL_INFO structure is based on the transport provider
            selected by the values specified for the af, type, and protocol parameters. Refer to Multipoint and Multicast Semantics for
            additional information on a multipoint session.
            </term>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSA_FLAG.WSA_FLAG_ACCESS_SYSTEM_SECURITY">
            <term>
            Create a socket that allows the the ability to set a security descriptor on the socket that contains a security access
            control list (SACL) as opposed to just a discretionary access control list (DACL). SACLs are used for generating audits and
            alarms when an access check occurs on the object. For a socket, an access check occurs to determine whether the socket
            should be allowed to bind to a specific address specified to the bind function. The ACCESS_SYSTEM_SECURITY access right
            controls the ability to get or set the SACL in an object's security descriptor. The system grants this access right only if
            the SE_SECURITY_NAME privilege is enabled in the access token of the requesting thread.
            </term>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSA_FLAG.WSA_FLAG_NO_HANDLE_INHERIT">
            <term>
            Create a socket that is non-inheritable. A socket handle created by the WSASocket or the socket function is inheritable by
            default. When this flag is set, the socket handle is non-inheritable. The GetHandleInformation function can be used to
            determine if a socket handle was created with the WSA_FLAG_NO_HANDLE_INHERIT flag set. The GetHandleInformation function
            will return that the HANDLE_FLAG_INHERIT value is set. This flag is supported on Windows 7 with SP1, Windows Server 2008 R2
            with SP1, and later
            </term>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSA_FLAG.WSA_FLAG_REGISTERED_IO">
            <summary/>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.__WSAFDIsSet(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.fd_set@)">
            <summary>The <c>__WSAFDIsSet</c> function specifies whether a socket is included in a set of socket descriptors.</summary>
            <param name="arg1">TBD</param>
            <param name="arg2">
            Pointer to an fd_set structure containing the set of socket descriptors. The <c>__WSAFDIsSet</c> function determines whether the
            socket specified in the fd parameter is a member of that set.
            </param>
            <returns>None</returns>
            <remarks>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAAccept(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.SOCKADDR,System.Int32@,Vanara.PInvoke.Ws2_32.ConditionFunc,System.IntPtr)">
            <summary>
            The <c>WSAAccept</c> function conditionally accepts a connection based on the return value of a condition function, provides
            quality of service flow specifications, and allows the transfer of connection data.
            </summary>
            <param name="s">A descriptor that identifies a socket that is listening for connections after a call to the listen function.</param>
            <param name="addr">
            An optional pointer to an sockaddr structure that receives the address of the connecting entity, as known to the communications
            layer. The exact format of the addr parameter is determined by the address family established when the socket was created.
            </param>
            <param name="addrlen">
            An optional pointer to an integer that contains the length of the sockaddr structure pointed to by the addr parameter, in bytes.
            </param>
            <param name="lpfnCondition">
            The address of an optional, application-specified condition function that will make an accept/reject decision based on the
            caller information passed in as parameters, and optionally create or join a socket group by assigning an appropriate value to
            the result parameter g of this function. If this parameter is <c>NULL</c>, then no condition function is called.
            </param>
            <param name="dwCallbackData">
            Callback data passed back to the application-specified condition function as the value of the dwCallbackData parameter passed to
            the condition function. This parameter is only applicable if the lpfnCondition parameter is not <c>NULL</c>. This parameter is
            not interpreted by Windows Sockets.
            </param>
            <returns>
            <para>
            If no error occurs, <c>WSAAccept</c> returns a value of type SOCKET that is a descriptor for the accepted socket. Otherwise, a
            value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling WSAGetLastError.
            </para>
            <para>
            The integer referred to by addrlen initially contains the amount of space pointed to by addr. On return it will contain the
            actual length in bytes of the address returned.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEACCES</term>
            <term>
            An attempt was made to access a socket in a way forbidden by its access permissions. This error is returned if the connection
            request that was offered has timed out or been withdrawn.
            </term>
            </item>
            <item>
            <term>WSAECONNREFUSED</term>
            <term>
            No connection could be made because the target machine actively refused it. This error is returned if the connection request was
            forcefully rejected as indicated in the return value of the condition function (CF_REJECT).
            </term>
            </item>
            <item>
            <term>WSAECONNRESET</term>
            <term>
            An existing connection was forcibly closed by the remote host. This error is returned of an incoming connection was indicated,
            but was subsequently terminated by the remote peer prior to accepting the call.
            </term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The system detected an invalid pointer address in attempting to use a pointer argument in a call. This error is returned of the
            addrlen parameter is too small or the addr or lpfnCondition is not part of the user address space.
            </term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>
            A blocking operation was interrupted by a call to WSACancelBlockingCall. This error is returned if a blocking Windows Sockets
            1.1 call was canceled through WSACancelBlockingCall.
            </term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking operation is currently executing. This error is returned if a blocking Windows Sockets 1.1 call is in progress.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            An invalid argument was supplied. This error is returned if listen was not invoked prior to WSAAccept, the return value of the
            condition function is not a valid one, or any case where the specified socket is in an invalid state.
            </term>
            </item>
            <item>
            <term>WSAEMFILE</term>
            <term>
            Too many open sockets. This error is returned if the queue is nonempty upon entry to WSAAccept and there are no socket
            descriptors available.
            </term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>A socket operation encountered a dead network. This error is returned if the network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>
            An operation on a socket could not be performed because the system lacked sufficient buffer space or because a queue was full.
            This error is returned if no buffer space is available.
            </term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>
            An operation was attempted on something that is not a socket. This error is returned if the socket descriptor passed in the s
            parameter is not a socket.
            </term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>
            The protocol family has not been configured into the system or no implementation for it exists. This error is returned if the
            referenced socket is not a type that supports connection-oriented service.
            </term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>
            A non-blocking socket operation could not be completed immediately. This error is returned if the socket is marked as
            nonblocking and no connections are present to be accepted.
            </term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>
            Either the application has not called WSAStartup, or WSAStartup failed. This error is returned of a successful call to the
            WSAStartup function dit not occur before using this function.
            </term>
            </item>
            <item>
            <term>WSATRY_AGAIN</term>
            <term>
            This is usually a temporary error during hostname resolution and means that the local server did not receive a response from an
            authoritative server. This error is returned if the acceptance of the connection request was deferred as indicated in the return
            value of the condition function (CF_DEFER).
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAAccept</c> function extracts the first connection on the queue of pending connections on socket s, and checks it
            against the condition function, provided the condition function is specified (that is, not <c>NULL</c>). If the condition
            function returns CF_ACCEPT, <c>WSAAccept</c> creates a new socket. The newly created socket has the same properties as socket s
            including asynchronous events registered with WSAAsyncSelect or with WSAEventSelect. If the condition function returns
            CF_REJECT, <c>WSAAccept</c> rejects the connection request. The condition function runs in the same thread as this function
            does, and should return as soon as possible. If the decision cannot be made immediately, the condition function should return
            CF_DEFER to indicate that no decision has been made, and no action about this connection request should be taken by the service
            provider. When the application is ready to take action on the connection request, it will invoke <c>WSAAccept</c> again and
            return either CF_ACCEPT or CF_REJECT as a return value from the condition function.
            </para>
            <para>
            A socket in default mode (blocking) will block until a connection is present when an application calls <c>WSAAccept</c> and no
            connections are pending on the queue.
            </para>
            <para>
            A socket in nonblocking mode (blocking) fails with the error WSAEWOULDBLOCK when an application calls <c>WSAAccept</c> and no
            connections are pending on the queue. After <c>WSAAccept</c> succeeds and returns a new socket handle, the accepted socket
            cannot be used to accept any more connections. The original socket remains open and listens for new connection requests.
            </para>
            <para>
            The addr parameter is a result parameter that is filled in with the address of the connecting entity, as known to the
            communications layer. The exact format of the addr parameter is determined by the address family in which the communication is
            occurring. The addrlen is a value-result parameter; it should initially contain the amount of space pointed to by addr. On
            return, it will contain the actual length (in bytes) of the address returned. This call is used with connection-oriented socket
            types such as SOCK_STREAM. If addr and/or addrlen are equal to <c>NULL</c>, then no information about the remote address of the
            accepted socket is returned. Otherwise, these two parameters will be filled in if the connection is successfully accepted.
            </para>
            <para>A prototype of the condition function is defined in the Winsock2.h header file as the <c>LPCONDITIONPROC</c> as follows:</para>
            <para>
            The <c>ConditionFunc</c> is a placeholder for the application-specified callback function. The actual condition function must
            reside in a DLL or application module. It is exported in the module definition file.
            </para>
            <para>
            The lpCallerId parameter points to a WSABUF structure that contains the address of the connecting entity, where its len
            parameter is the length of the buffer in bytes, and its buf parameter is a pointer to the buffer. The lpCallerData is a value
            parameter that contains any user data. The information in these parameters is sent along with the connection request. If no
            caller identification or caller data is available, the corresponding parameters will be <c>NULL</c>. Many network protocols do
            not support connect-time caller data. Most conventional network protocols can be expected to support caller identifier
            information at connection-request time. The buf portion of the WSABUF pointed to by lpCallerId points to a sockaddr. The
            <c>sockaddr</c> structure is interpreted according to its address family (typically by casting the <c>sockaddr</c> to some type
            specific to the address family).
            </para>
            <para>
            The lpSQOS parameter references the FLOWSPEC structures for socket s specified by the caller, one for each direction, followed
            by any additional provider-specific parameters. The sending or receiving flow specification values will be ignored as
            appropriate for any unidirectional sockets. A <c>NULL</c> value indicates that there is no caller-supplied quality of service
            and that no negotiation is possible. A non- <c>NULL</c> lpSQOS pointer indicates that a quality of service negotiation is to
            occur or that the provider is prepared to accept the quality of service request without negotiation.
            </para>
            <para>
            The lpGQOS parameter is reserved, and should be <c>NULL</c>. (reserved for future use with socket groups) references the
            FLOWSPEC structure for the socket group the caller is to create, one for each direction, followed by any additional
            provider-specific parameters. A <c>NULL</c> value for lpGQOS indicates no caller-specified group quality of service. Quality of
            service information can be returned if negotiation is to occur.
            </para>
            <para>
            The lpCalleeId is a parameter that contains the local address of the connected entity. The buf portion of the WSABUF pointed to
            by lpCalleeId points to a sockaddr structure. The <c>sockaddr</c> structure is interpreted according to its address family
            (typically by casting the <c>sockaddr</c> to some type specific to the address family such as struct <c>sockaddr_in</c>).
            </para>
            <para>
            The lpCalleeData is a result parameter used by the condition function to supply user data back to the connecting entity. The
            lpCalleeData-&gt;len initially contains the length of the buffer allocated by the service provider and pointed to by
            lpCalleeData-&gt;buf. A value of zero means passing user data back to the caller is not supported. The condition function should
            copy up to lpCalleeData-&gt;len bytes of data into lpCalleeData-&gt;buf, and then update lpCalleeData-&gt;len to indicate the
            actual number of bytes transferred. If no user data is to be passed back to the caller, the condition function should set
            lpCalleeData-&gt;len to zero. The format of all address and user data is specific to the address family to which the socket belongs.
            </para>
            <para>The g parameter is assigned within the condition function to indicate any of the following actions:</para>
            <list type="bullet">
            <item>
            <term>
            If g is an existing socket group identifier, add s to this group, provided all the requirements set by this group are met.
            </term>
            </item>
            <item>
            <term>If g = SG_UNCONSTRAINED_GROUP, create an unconstrained socket group and have s as the first member.</term>
            </item>
            <item>
            <term>If g = SG_CONSTRAINED_GROUP, create a constrained socket group and have s as the first member.</term>
            </item>
            <item>
            <term>If g = zero, no group operation is performed.</term>
            </item>
            </list>
            <para>
            For unconstrained groups, any set of sockets can be grouped together as long as they are supported by a single service provider.
            A constrained socket group can consist only of connection-oriented sockets, and requires that connections on all grouped sockets
            be to the same address on the same host. For newly created socket groups, the new group identifier can be retrieved by using
            getsockopt function with level parameter set to SOL_SOCKET and the optname parameter set to <c>SO_GROUP_ID</c>. A socket group
            and its associated socket group ID remain valid until the last socket belonging to this socket group is closed. Socket group IDs
            are unique across all processes for a given service provider. A socket group and its associated identifier remain valid until
            the last socket belonging to this socket group is closed. Socket group identifiers are unique across all processes for a given
            service provider. For more information on socket groups, see the Remarks for the WSASocket functions.
            </para>
            <para>
            The dwCallbackData parameter value passed to the condition function is the value passed as the dwCallbackData parameter in the
            original <c>WSAAccept</c> call. This value is interpreted only by the Windows Socket version 2 client. This allows a client to
            pass some context information from the <c>WSAAccept</c> call site through to the condition function. This also provides the
            condition function with any additional information required to determine whether to accept the connection or not. A typical
            usage is to pass a (suitably cast) pointer to a data structure containing references to application-defined objects with which
            this socket is associated.
            </para>
            <para>
            <c>Note</c> To protect use of the <c>WSAAccept</c> function from SYN attacks, applications must perform full TCP handshakes
            (SYN-SYNACK-ACK) before reporting the connection request. Protecting against SYN attacks in this manner results in the
            SO_CONDITIONAL_ACCEPT socket option becoming inoperative; the conditional function is still called, and the <c>WSAAccept</c>
            function operates properly, but server applications that rely on clients being unable to perform the handshake will not operate properly.
            </para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>WSAAccept</c>, Winsock may need to wait for a network event before
            the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous
            procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an
            ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients.
            </para>
            <para>Example Code</para>
            <para>The following example demonstrates the use of the <c>WSAAccept</c> function.</para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAAddressToString(Vanara.PInvoke.Ws2_32.SOCKADDR,System.UInt32,Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO@,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            <para>
            The <c>WSAAddressToString</c> function converts all components of a sockaddr structure into a human-readable string
            representation of the address.
            </para>
            <para>
            This is intended to be used mainly for display purposes. If the caller requires that the translation to be performed by a
            particular provider, it should supply the corresponding WSAPROTOCOL_INFO structure in the lpProtocolInfo parameter.
            </para>
            </summary>
            <param name="lpsaAddress">A pointer to the sockaddr structure to translate into a string.</param>
            <param name="dwAddressLength">
            The length, in bytes, of the address in the sockaddr structure pointed to by the lpsaAddress parameter. The dwAddressLength
            parameter may vary in size with different protocols.
            </param>
            <param name="lpProtocolInfo">
            A pointer to the WSAPROTOCOL_INFO structure for a particular provider. If this is parameter is <c>NULL</c>, the call is routed
            to the provider of the first protocol supporting the address family indicated in the lpsaAddress parameter.
            </param>
            <param name="lpszAddressString">A pointer to the buffer that receives the human-readable address string.</param>
            <param name="lpdwAddressStringLength">
            On input, this parameter specifies the length of the buffer pointed to by the lpszAddressString parameter. The length is
            represented in bytes for ANSI strings, and in WCHARs for Unicode strings. On output, this parameter returns the length of the
            string including the <c>NULL</c> terminator actually copied into the buffer pointed to by the lpszAddressString parameter. If
            the specified buffer is not large enough, the function fails with a specific error of WSAEFAULT and this parameter is updated
            with the required size.
            </param>
            <returns>
            <para>
            If no error occurs, <c>WSAAddressToString</c> returns a value of zero. Otherwise, the value SOCKET_ERROR is returned, and a
            specific error number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The specified lpcsAddress, lpProtocolInfo, and lpszAddressString parameters point to memory that is not all in the address space
            of the process, or the buffer pointed to by the lpszAddressString parameter is too small. Pass in a larger buffer.
            </term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            An invalid parameter was passed. This error is returned if the lpsaAddress, dwAddressLength, or lpdwAddressStringLength
            parameter are NULL. This error is also returned if the specified address is not a valid socket address, or no transport provider
            supports the indicated address family.
            </term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>No buffer space is available.</term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>
            The Winsock 2 DLL has not been initialized. The application must first call WSAStartup before calling any Windows Sockets functions.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAAddressToString</c> function provides a protocol-independent address-to-string translation. The
            <c>WSAAddressToString</c> function takes a socket address structure pointed to by the lpsaAddress parameter and returns a
            pointer to <c>NULL</c>-terminated string that represents the socket address in the lpszAddressString parameter. While the
            inet_ntoa function works only with IPv4 addresses, the <c>WSAAddressToString</c> function works with any socket address
            supported by a Winsock provider on the local computer including IPv6 addresses.
            </para>
            <para>
            If the lpsaAddress parameter points to an IPv4 socket address (the address family is <c>AF_INET</c>), then the address string
            returned in the buffer pointed to by the lpszAddressString parameter is in dotted-decimal notation as in "192.168.16.0", an
            example of an IPv4 address in dotted-decimal notation.
            </para>
            <para>
            If the lpsaAddress parameter points to an IPv6 socket address (the address family is <c>AF_INET6</c>), then the address string
            returned in the buffer pointed to by the lpszAddressString parameter is in Internet standard format. The basic string
            representation consists of 8 hexadecimal numbers separated by colons. A string of consecutive zero numbers is replaced with a
            double-colon. There can only be one double-colon in the string representation of the IPv6 address.
            </para>
            <para>
            If the length of the buffer pointed to by the lpszAddressString parameter is not large enough to receive the string
            representation of the socket address, <c>WSAAddressToString</c> returns WSAEFAULT.
            </para>
            <para>
            Support for IPv6 addresses using the <c>WSAAddressToString</c> function was added on Windows XP with Service Pack 1 (SP1)and
            later. IPv6 must also be installed on the local computer for the <c>WSAAddressToString</c> function to support IPv6 addresses.
            </para>
            <para>
            <c>Windows Phone 8:</c> The <c>WSAAddressToStringW</c> function is supported for Windows Phone Store apps on Windows Phone 8 and later.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>WSAAddressToStringW</c> function is supported for Windows Store
            apps on Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAAddressToString(Vanara.PInvoke.Ws2_32.SOCKADDR,System.UInt32,System.IntPtr,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            <para>
            The <c>WSAAddressToString</c> function converts all components of a sockaddr structure into a human-readable string
            representation of the address.
            </para>
            <para>
            This is intended to be used mainly for display purposes. If the caller requires that the translation to be performed by a
            particular provider, it should supply the corresponding WSAPROTOCOL_INFO structure in the lpProtocolInfo parameter.
            </para>
            </summary>
            <param name="lpsaAddress">A pointer to the sockaddr structure to translate into a string.</param>
            <param name="dwAddressLength">
            The length, in bytes, of the address in the sockaddr structure pointed to by the lpsaAddress parameter. The dwAddressLength
            parameter may vary in size with different protocols.
            </param>
            <param name="lpProtocolInfo">
            A pointer to the WSAPROTOCOL_INFO structure for a particular provider. If this is parameter is <c>NULL</c>, the call is routed
            to the provider of the first protocol supporting the address family indicated in the lpsaAddress parameter.
            </param>
            <param name="lpszAddressString">A pointer to the buffer that receives the human-readable address string.</param>
            <param name="lpdwAddressStringLength">
            On input, this parameter specifies the length of the buffer pointed to by the lpszAddressString parameter. The length is
            represented in bytes for ANSI strings, and in WCHARs for Unicode strings. On output, this parameter returns the length of the
            string including the <c>NULL</c> terminator actually copied into the buffer pointed to by the lpszAddressString parameter. If
            the specified buffer is not large enough, the function fails with a specific error of WSAEFAULT and this parameter is updated
            with the required size.
            </param>
            <returns>
            <para>
            If no error occurs, <c>WSAAddressToString</c> returns a value of zero. Otherwise, the value SOCKET_ERROR is returned, and a
            specific error number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The specified lpcsAddress, lpProtocolInfo, and lpszAddressString parameters point to memory that is not all in the address space
            of the process, or the buffer pointed to by the lpszAddressString parameter is too small. Pass in a larger buffer.
            </term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            An invalid parameter was passed. This error is returned if the lpsaAddress, dwAddressLength, or lpdwAddressStringLength
            parameter are NULL. This error is also returned if the specified address is not a valid socket address, or no transport provider
            supports the indicated address family.
            </term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>No buffer space is available.</term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>
            The Winsock 2 DLL has not been initialized. The application must first call WSAStartup before calling any Windows Sockets functions.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAAddressToString</c> function provides a protocol-independent address-to-string translation. The
            <c>WSAAddressToString</c> function takes a socket address structure pointed to by the lpsaAddress parameter and returns a
            pointer to <c>NULL</c>-terminated string that represents the socket address in the lpszAddressString parameter. While the
            inet_ntoa function works only with IPv4 addresses, the <c>WSAAddressToString</c> function works with any socket address
            supported by a Winsock provider on the local computer including IPv6 addresses.
            </para>
            <para>
            If the lpsaAddress parameter points to an IPv4 socket address (the address family is <c>AF_INET</c>), then the address string
            returned in the buffer pointed to by the lpszAddressString parameter is in dotted-decimal notation as in "192.168.16.0", an
            example of an IPv4 address in dotted-decimal notation.
            </para>
            <para>
            If the lpsaAddress parameter points to an IPv6 socket address (the address family is <c>AF_INET6</c>), then the address string
            returned in the buffer pointed to by the lpszAddressString parameter is in Internet standard format. The basic string
            representation consists of 8 hexadecimal numbers separated by colons. A string of consecutive zero numbers is replaced with a
            double-colon. There can only be one double-colon in the string representation of the IPv6 address.
            </para>
            <para>
            If the length of the buffer pointed to by the lpszAddressString parameter is not large enough to receive the string
            representation of the socket address, <c>WSAAddressToString</c> returns WSAEFAULT.
            </para>
            <para>
            Support for IPv6 addresses using the <c>WSAAddressToString</c> function was added on Windows XP with Service Pack 1 (SP1)and
            later. IPv6 must also be installed on the local computer for the <c>WSAAddressToString</c> function to support IPv6 addresses.
            </para>
            <para>
            <c>Windows Phone 8:</c> The <c>WSAAddressToStringW</c> function is supported for Windows Phone Store apps on Windows Phone 8 and later.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>WSAAddressToStringW</c> function is supported for Windows Store
            apps on Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAAsyncGetHostByAddr(Vanara.PInvoke.HWND,System.UInt32,System.IntPtr,System.Int32,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            <para>The <c>WSAAsyncGetHostByAddr</c> function asynchronously retrieves host information that corresponds to an address.</para>
            <para>
            <c>Note</c> The <c>WSAAsyncGetHostByAddr</c> function is not designed to provide parallel resolution of several addresses.
            Therefore, applications that issue several requests should not expect them to be executed concurrently. Alternatively,
            applications can start another thread and use the getnameinfo function to resolve addresses in an IP-version agnostic manner.
            Developers creating Windows Sockets 2 applications are urged to use the <c>getnameinfo</c> function to enable smooth transition
            to IPv6 compatibility.
            </para>
            </summary>
            <param name="hWnd">[in] The handle of the window which should receive a message when the asynchronous request completes.</param>
            <param name="wMsg">[in] The message to be received when the asynchronous request completes.</param>
            <param name="addr">[in] A pointer to the network address for the host. Host addresses are stored in network byte order.</param>
            <param name="len">[in] The length of the address.</param>
            <param name="type">[in] The type of the address.</param>
            <param name="buf">
            [out] A pointer to the data area to receive the hostent data. Note that this must be larger than the size of a hostent
            structure. This is because the data area supplied is used by Windows Sockets to contain not only a hostent structure but any and
            all of the data which is referenced by members of the hostent structure. It is recommended that you supply a buffer of
            MAXGETHOSTSTRUCT bytes.
            </param>
            <param name="buflen">[in] The size of data area buf above.</param>
            <returns>
            <para>
            The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or
            failure of the operation itself.
            </para>
            <para>
            If no error occurs, <c>WSAAsyncGetHostByAddr</c> returns a nonzero value of type HANDLE that is the asynchronous task handle
            (not to be confused with a Windows HTASK) for the request. This value can be used in two ways. It can be used to cancel the
            operation using WSACancelAsyncRequest, or it can be used to match up asynchronous operations and completion messages by
            examining the wParam message parameter.
            </para>
            <para>
            If the asynchronous operation could not be initiated, <c>WSAAsyncGetHostByAddr</c> returns a zero value, and a specific error
            number can be retrieved by calling WSAGetLastError.
            </para>
            <para>
            The following error codes can be set when an application window receives a message. As described above, they can be extracted
            from the lParam in the reply message using the <c>WSAGETASYNCERROR</c> macro.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>Insufficient buffer space is available.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The addr or buf parameter is not in a valid part of the process address space.</term>
            </item>
            <item>
            <term>WSAHOST_NOT_FOUND</term>
            <term>Authoritative answer host not found.</term>
            </item>
            <item>
            <term>WSATRY_AGAIN</term>
            <term>Nonauthoritative host not found, or SERVERFAIL.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>Nonrecoverable errors: FORMERR, REFUSED, NOTIMP.</term>
            </item>
            <item>
            <term>WSANO_DATA</term>
            <term>Valid name, no data record of requested type.</term>
            </item>
            </list>
            <para>
            The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.
            </para>
            <list type="table">
            <listheader>
            <term>Error Code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>
            The asynchronous operation cannot be scheduled at this time due to resource or other constraints within the Windows Sockets implementation.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAAsyncGetHostByAddr</c> function is an asynchronous version of gethostbyaddr. It is used to retrieve the host name and
            address information that corresponds to a network address. Windows Sockets initiates the operation and returns to the caller
            immediately, passing back an opaque, asynchronous task handle that the application can use to identify the operation. When the
            operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the
            application's window.
            </para>
            <para>
            When the asynchronous operation has completed, the application window indicated by the hWnd parameter receives message in the
            wMsg parameter. The wParam parameter contains the asynchronous task handle as returned by the original function call. The high
            16 bits of lParam contain any error code. The error code can be any error as defined in Winsock2.h. An error code of zero
            indicates successful completion of the asynchronous operation.
            </para>
            <para>
            On successful completion, the buffer specified to the original function call contains a hostent structure. To access the members
            of this structure, the original buffer address is cast to a <c>hostent</c> structure pointer and accessed as appropriate.
            </para>
            <para>
            If the error code is WSAENOBUFS, the size of the buffer specified by buflen in the original call was too small to contain all
            the resulting information. In this case, the low 16 bits of lParam contain the size of buffer required to supply all the
            requisite information. If the application decides that the partial data is inadequate, it can reissue the
            <c>WSAAsyncGetHostByAddr</c> function call with a buffer large enough to receive all the desired information (that is, no
            smaller than the low 16 bits of lParam).
            </para>
            <para>
            The buffer specified to this function is used by Windows Sockets to construct a structure together with the contents of data
            areas referenced by members of the same hostent structure. To avoid the WSAENOBUFS error, the application should provide a
            buffer of at least MAXGETHOSTSTRUCT bytes (as defined in Winsock2.h).
            </para>
            <para>
            The error code and buffer length should be extracted from the lParam using the macros <c>WSAGETASYNCERROR</c> and
            <c>WSAGETASYNCBUFLEN</c>, defined in Winsock2.h as:
            </para>
            <para>The use of these macros will maximize the portability of the source code for the application.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAAsyncGetHostByName(Vanara.PInvoke.HWND,System.UInt32,System.String,System.IntPtr,System.Int32)">
            <summary>
            <para>The <c>WSAAsyncGetHostByName</c> function asynchronously retrieves host information that corresponds to a host name.</para>
            <para>
            <c>Note</c> The <c>WSAAsyncGetHostByName</c> function is not designed to provide parallel resolution of several names.
            Therefore, applications that issue several requests should not expect them to be executed concurrently. Alternatively,
            applications can start another thread and use the getaddrinfo function to resolve names in an IP-version agnostic manner.
            Developers creating Windows Sockets 2 applications are urged to use the <c>getaddrinfo</c> function to enable smooth transition
            to IPv6 compatibility.
            </para>
            </summary>
            <param name="hWnd">[in] The handle of the window which should receive a message when the asynchronous request completes.</param>
            <param name="wMsg">[in] The message to be received when the asynchronous request completes.</param>
            <param name="name">[in] A pointer to the null terminated name of the host.</param>
            <param name="buf">
            [out] A pointer to the data area to receive the hostent data. Note that this must be larger than the size of a hostent
            structure. This is because the data area supplied is used by Windows Sockets to contain not only a hostent structure but any and
            all of the data which is referenced by members of the hostent structure. It is recommended that you supply a buffer of
            MAXGETHOSTSTRUCT bytes.
            </param>
            <param name="buflen">[in] The size of data area buf above.</param>
            <returns>
            The return value specifies whether or not the asynchronous operation was successfully initiated. Note that it does not imply
            success or failure of the operation itself.
            <para>
            If the operation was successfully initiated, WSAAsyncGetHostByName returns a nonzero value of type HANDLE which is the
            asynchronous task handle(not to be confused with a Windows HTASK) for the request.This value can be used in two ways. It can be
            used to cancel the operation using WSACancelAsyncRequest. It can also be used to match up asynchronous operations and completion
            messages, by examining the wParam message argument.
            </para>
            <para>
            If the asynchronous operation could not be initiated, WSAAsyncGetHostByName returns a zero value, and a specific error number
            can be retrieved by calling WSAGetLastError.
            </para>
            </returns>
            <remarks>
            <para>
            The <c>WSAAsyncGetHostByName</c> function is an asynchronous version of gethostbyname, and is used to retrieve host name and
            address information corresponding to a host name. Windows Sockets initiates the operation and returns to the caller immediately,
            passing back an opaque asynchronous task handle that which the application can use to identify the operation. When the operation
            is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window.
            </para>
            <para>
            When the asynchronous operation has completed, the application window indicated by the hWnd parameter receives message in the
            wMsg parameter. The wParam parameter contains the asynchronous task handle as returned by the original function call. The high
            16 bits of lParam contain any error code. The error code can be any error as defined in Winsock2.h. An error code of zero
            indicates successful completion of the asynchronous operation.
            </para>
            <para>
            On successful completion, the buffer specified to the original function call contains a hostent structure. To access the
            elements of this structure, the original buffer address should be cast to a <c>hostent</c> structure pointer and accessed as appropriate.
            </para>
            <para>
            If the error code is WSAENOBUFS, the size of the buffer specified by buflen in the original call was too small to contain all
            the resulting information. In this case, the low 16 bits of lParam contain the size of buffer required to supply all the
            requisite information. If the application decides that the partial data is inadequate, it can reissue the
            <c>WSAAsyncGetHostByName</c> function call with a buffer large enough to receive all the desired information (that is, no
            smaller than the low 16 bits of lParam).
            </para>
            <para>
            The buffer specified to this function is used by Windows Sockets to construct a hostent structure together with the contents of
            data areas referenced by members of the same <c>hostent</c> structure. To avoid the WSAENOBUFS error, the application should
            provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in Winsock2.h).
            </para>
            <para>
            The error code and buffer length should be extracted from the lParam using the macros <c>WSAGETASYNCERROR</c> and
            <c>WSAGETASYNCBUFLEN</c>, defined in Winsock2.h as:
            </para>
            <para>The use of these macros will maximize the portability of the source code for the application.</para>
            <para><c>WSAAsyncGetHostByName</c> is guaranteed to resolve the string returned by a successful call to gethostname.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAAsyncGetProtoByName(Vanara.PInvoke.HWND,System.UInt32,System.String,System.IntPtr,System.Int32)">
            <summary>
            The <c>WSAAsyncGetProtoByName</c> function asynchronously retrieves protocol information that corresponds to a protocol name.
            </summary>
            <param name="hWnd">Handle of the window that will receive a message when the asynchronous request completes.</param>
            <param name="wMsg">Message to be received when the asynchronous request completes.</param>
            <param name="name">Pointer to the null-terminated protocol name to be resolved.</param>
            <param name="buf">
            Pointer to the data area to receive the protoent data. The data area must be larger than the size of a <c>protoent</c> structure
            because the data area is used by Windows Sockets to contain a <c>protoent</c> structure and all of the data that is referenced
            by members of the <c>protoent</c> structure. A buffer of MAXGETHOSTSTRUCT bytes is recommended.
            </param>
            <param name="buflen">Size of data area for the buf parameter, in bytes.</param>
            <returns>
            <para>
            The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or
            failure of the operation itself.
            </para>
            <para>
            If no error occurs, <c>WSAAsyncGetProtoByName</c> returns a nonzero value of type HANDLE that is the asynchronous task handle
            for the request (not to be confused with a Windows HTASK). This value can be used in two ways. It can be used to cancel the
            operation using WSACancelAsyncRequest, or it can be used to match up asynchronous operations and completion messages, by
            examining the wParam message parameter.
            </para>
            <para>
            If the asynchronous operation could not be initiated, <c>WSAAsyncGetProtoByName</c> returns a zero value, and a specific error
            number can be retrieved by calling WSAGetLastError.
            </para>
            <para>
            The following error codes can be set when an application window receives a message. As described above, they can be extracted
            from the lParam in the reply message using the <c>WSAGETASYNCERROR</c> macro.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>Insufficient buffer space is available.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The name or buf parameter is not in a valid part of the process address space.</term>
            </item>
            <item>
            <term>WSAHOST_NOT_FOUND</term>
            <term>Authoritative answer protocol not found.</term>
            </item>
            <item>
            <term>WSATRY_AGAIN</term>
            <term>A nonauthoritative protocol not found, or server failure.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>Nonrecoverable errors, the protocols database is not accessible.</term>
            </item>
            <item>
            <term>WSANO_DATA</term>
            <term>Valid name, no data record of requested type.</term>
            </item>
            </list>
            <para>
            The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>
            The asynchronous operation cannot be scheduled at this time due to resource or other constraints within the Windows Sockets implementation.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAAsyncGetProtoByName</c> function is an asynchronous version of getprotobyname. It is used to retrieve the protocol
            name and number from the Windows Sockets database corresponding to a given protocol name. Windows Sockets initiates the
            operation and returns to the caller immediately, passing back an opaque, asynchronous task handle that the application can use
            to identify the operation. When the operation is completed, the results (if any) are copied into the buffer provided by the
            caller and a message is sent to the application's window.
            </para>
            <para>
            When the asynchronous operation has completed, the application window indicated by the hWnd parameter receives message in the
            wMsg parameter. The wParam parameter contains the asynchronous task handle as returned by the original function call. The high
            16 bits of lParam contain any error code. The error code can be any error as defined in Winsock2.h. An error code of zero
            indicates successful completion of the asynchronous operation.
            </para>
            <para>
            On successful completion, the buffer specified to the original function call contains a protoent structure. To access the
            members of this structure, the original buffer address should be cast to a <c>protoent</c> structure pointer and accessed as appropriate.
            </para>
            <para>
            If the error code is WSAENOBUFS, the size of the buffer specified by buflen in the original call was too small to contain all
            the resulting information. In this case, the low 16 bits of lParam contain the size of buffer required to supply all the
            requisite information. If the application decides that the partial data is inadequate, it can reissue the
            <c>WSAAsyncGetProtoByName</c> function call with a buffer large enough to receive all the desired information (that is, no
            smaller than the low 16 bits of lParam).
            </para>
            <para>
            The buffer specified to this function is used by Windows Sockets to construct a protoent structure together with the contents of
            data areas referenced by members of the same <c>protoent</c> structure. To avoid the WSAENOBUFS error noted above, the
            application should provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in Winsock2.h).
            </para>
            <para>
            The error code and buffer length should be extracted from the lParam using the macros <c>WSAGETASYNCERROR</c> and
            <c>WSAGETASYNCBUFLEN</c>, defined in Winsock2.h as:
            </para>
            <para>The use of these macros will maximize the portability of the source code for the application.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAAsyncGetProtoByNumber(Vanara.PInvoke.HWND,System.UInt32,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            The <c>WSAAsyncGetProtoByNumber</c> function asynchronously retrieves protocol information that corresponds to a protocol number.
            </summary>
            <param name="hWnd">Handle of the window that will receive a message when the asynchronous request completes.</param>
            <param name="wMsg">Message to be received when the asynchronous request completes.</param>
            <param name="number">Protocol number to be resolved, in host byte order.</param>
            <param name="buf">
            Pointer to the data area to receive the protoent data. The data area must be larger than the size of a <c>protoent</c> structure
            because the data area is used by Windows Sockets to contain a <c>protoent</c> structure and all of the data that is referenced
            by members of the <c>protoent</c> structure. A buffer of MAXGETHOSTSTRUCT bytes is recommended.
            </param>
            <param name="buflen">Size of data area for the buf parameter, in bytes.</param>
            <returns>
            <para>
            The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or
            failure of the operation itself.
            </para>
            <para>
            If no error occurs, <c>WSAAsyncGetProtoByNumber</c> returns a nonzero value of type <c>HANDLE</c> that is the asynchronous task
            handle for the request (not to be confused with a Windows HTASK). This value can be used in two ways. It can be used to cancel
            the operation using WSACancelAsyncRequest, or it can be used to match up asynchronous operations and completion messages, by
            examining the wParam message parameter.
            </para>
            <para>
            If the asynchronous operation could not be initiated, <c>WSAAsyncGetProtoByNumber</c> returns a zero value, and a specific error
            number can be retrieved by calling WSAGetLastError.
            </para>
            <para>
            The following error codes can be set when an application window receives a message. As described above, they can be extracted
            from the lParam in the reply message using the <c>WSAGETASYNCERROR</c> macro.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>Insufficient buffer space is available.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The buf parameter is not in a valid part of the process address space.</term>
            </item>
            <item>
            <term>WSAHOST_NOT_FOUND</term>
            <term>Authoritative answer protocol not found.</term>
            </item>
            <item>
            <term>WSATRY_AGAIN</term>
            <term>Nonauthoritative protocol not found, or server failure.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>Nonrecoverable errors, the protocols database is not accessible.</term>
            </item>
            <item>
            <term>WSANO_DATA</term>
            <term>Valid name, no data record of requested type.</term>
            </item>
            </list>
            <para>
            The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>
            The asynchronous operation cannot be scheduled at this time due to resource or other constraints within the Windows Sockets implementation.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAAsyncGetProtoByNumber</c> function is an asynchronous version of getprotobynumber, and is used to retrieve the
            protocol name and number corresponding to a protocol number. Windows Sockets initiates the operation and returns to the caller
            immediately, passing back an opaque, asynchronous task handle that the application can use to identify the operation. When the
            operation is completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the
            application's window.
            </para>
            <para>
            When the asynchronous operation has completed, the application window indicated by the hWnd parameter receives message in the
            wMsg parameter. The wParam parameter contains the asynchronous task handle as returned by the original function call. The high
            16 bits of lParam contain any error code. The error code can be any error as defined in Winsock2.h. An error code of zero
            indicates successful completion of the asynchronous operation.
            </para>
            <para>
            On successful completion, the buffer specified to the original function call contains a protoent structure. To access the
            members of this structure, the original buffer address is cast to a <c>protoent</c> structure pointer and accessed as appropriate.
            </para>
            <para>
            If the error code is WSAENOBUFS, the size of the buffer specified by buflen in the original call was too small to contain all
            the resulting information. In this case, the low 16 bits of lParam contain the size of buffer required to supply all the
            requisite information. If the application decides that the partial data is inadequate, it can reissue the
            <c>WSAAsyncGetProtoByNumber</c> function call with a buffer large enough to receive all the desired information (that is, no
            smaller than the low 16 bits of lParam).
            </para>
            <para>
            The buffer specified to this function is used by Windows Sockets to construct a protoent structure together with the contents of
            data areas referenced by members of the same <c>protoent</c> structure. To avoid the WSAENOBUFS error noted above, the
            application should provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in Winsock2.h).
            </para>
            <para>
            The error code and buffer length should be extracted from the lParam using the macros <c>WSAGETASYNCERROR</c> and
            <c>WSAGETASYNCBUFLEN</c>, defined in Winsock2.h as:
            </para>
            <para>The use of these macros will maximize the portability of the source code for the application.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAAsyncGetServByName(Vanara.PInvoke.HWND,System.UInt32,System.String,System.String,System.IntPtr,System.Int32)">
            <summary>
            The <c>WSAAsyncGetServByName</c> function asynchronously retrieves service information that corresponds to a service name and port.
            </summary>
            <param name="hWnd">Handle of the window that should receive a message when the asynchronous request completes.</param>
            <param name="wMsg">Message to be received when the asynchronous request completes.</param>
            <param name="name">Pointer to a <c>null</c>-terminated service name.</param>
            <param name="proto">
            Pointer to a protocol name. This can be <c>NULL</c>, in which case <c>WSAAsyncGetServByName</c> will search for the first
            service entry for which s_name or one of the s_aliases matches the given name. Otherwise, <c>WSAAsyncGetServByName</c> matches
            both name and proto.
            </param>
            <param name="buf">
            Pointer to the data area to receive the servent data. The data area must be larger than the size of a <c>servent</c> structure
            because the data area is used by Windows Sockets to contain a <c>servent</c> structure and all of the data that is referenced by
            members of the <c>servent</c> structure. A buffer of MAXGETHOSTSTRUCT bytes is recommended.
            </param>
            <param name="buflen">Size of data area for the buf parameter, in bytes.</param>
            <returns>
            <para>
            The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or
            failure of the operation itself.
            </para>
            <para>
            If no error occurs, <c>WSAAsyncGetServByName</c> returns a nonzero value of type <c>HANDLE</c> that is the asynchronous task
            handle for the request (not to be confused with a Windows HTASK). This value can be used in two ways. It can be used to cancel
            the operation using WSACancelAsyncRequest, or it can be used to match up asynchronous operations and completion messages, by
            examining the wParam message parameter.
            </para>
            <para>
            If the asynchronous operation could not be initiated, <c>WSAAsyncServByName</c> returns a zero value, and a specific error
            number can be retrieved by calling WSAGetLastError.
            </para>
            <para>
            The following error codes can be set when an application window receives a message. As described above, they can be extracted
            from the lParam in the reply message using the <c>WSAGETASYNCERROR</c> macro.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>Insufficient buffer space is available.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The buf parameter is not in a valid part of the process address space.</term>
            </item>
            <item>
            <term>WSAHOST_NOT_FOUND</term>
            <term>Authoritative answer host not found.</term>
            </item>
            <item>
            <term>WSATRY_AGAIN</term>
            <term>Nonauthoritative service not found, or server failure.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>Nonrecoverable errors, the services database is not accessible.</term>
            </item>
            <item>
            <term>WSANO_DATA</term>
            <term>Valid name, no data record of requested type.</term>
            </item>
            </list>
            <para>
            The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>
            The asynchronous operation cannot be scheduled at this time due to resource or other constraints within the Windows Sockets implementation.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAAsyncGetServByName</c> function is an asynchronous version of getservbyname and is used to retrieve service
            information corresponding to a service name. Windows Sockets initiates the operation and returns to the caller immediately,
            passing back an opaque, asynchronous task handle that the application can use to identify the operation. When the operation is
            completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window.
            </para>
            <para>
            When the asynchronous operation has completed, the application window indicated by the hWnd parameter receives message in the
            wMsg parameter. The wParam parameter contains the asynchronous task handle as returned by the original function call. The high
            16 bits of lParam contain any error code. The error code can be any error as defined in Winsock2.h. An error code of zero
            indicates successful completion of the asynchronous operation.
            </para>
            <para>
            On successful completion, the buffer specified to the original function call contains a servent structure. To access the members
            of this structure, the original buffer address should be cast to a <c>servent</c> structure pointer and accessed as appropriate.
            </para>
            <para>
            If the error code is WSAENOBUFS, the size of the buffer specified by buflen in the original call was too small to contain all
            the resulting information. In this case, the low 16 bits of lParam contain the size of buffer required to supply all the
            requisite information. If the application decides that the partial data is inadequate, it can reissue the
            <c>WSAAsyncGetServByName</c> function call with a buffer large enough to receive all the desired information (that is, no
            smaller than the low 16 bits of lParam).
            </para>
            <para>
            The buffer specified to this function is used by Windows Sockets to construct a servent structure together with the contents of
            data areas referenced by members of the same <c>servent</c> structure. To avoid the WSAENOBUFS error, the application should
            provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in Winsock2.h).
            </para>
            <para>
            The error code and buffer length should be extracted from the lParam using the macros <c>WSAGETASYNCERROR</c> and
            <c>WSAGETASYNCBUFLEN</c>, defined in Winsock2.h as:
            </para>
            <para>The use of these macros will maximize the portability of the source code for the application.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAAsyncGetServByPort(Vanara.PInvoke.HWND,System.UInt32,System.Int32,System.String,System.IntPtr,System.Int32)">
            <summary>
            The <c>WSAAsyncGetServByPort</c> function asynchronously retrieves service information that corresponds to a port and protocol.
            </summary>
            <param name="hWnd">Handle of the window that should receive a message when the asynchronous request completes.</param>
            <param name="wMsg">Message to be received when the asynchronous request completes.</param>
            <param name="port">Port for the service, in network byte order.</param>
            <param name="proto">
            Pointer to a protocol name. This can be <c>NULL</c>, in which case <c>WSAAsyncGetServByPort</c> will search for the first
            service entry for which s_port match the given port. Otherwise, <c>WSAAsyncGetServByPort</c> matches both port and proto.
            </param>
            <param name="buf">
            Pointer to the data area to receive the servent data. The data area must be larger than the size of a <c>servent</c> structure
            because the data area is used by Windows Sockets to contain a <c>servent</c> structure and all of the data that is referenced by
            members of the <c>servent</c> structure. A buffer of MAXGETHOSTSTRUCT bytes is recommended.
            </param>
            <param name="buflen">Size of data area for the buf parameter, in bytes.</param>
            <returns>
            <para>
            The return value specifies whether or not the asynchronous operation was successfully initiated. It does not imply success or
            failure of the operation itself.
            </para>
            <para>
            If no error occurs, <c>WSAAsyncGetServByPort</c> returns a nonzero value of type <c>HANDLE</c> that is the asynchronous task
            handle for the request (not to be confused with a Windows HTASK). This value can be used in two ways. It can be used to cancel
            the operation using WSACancelAsyncRequest, or it can be used to match up asynchronous operations and completion messages, by
            examining the wParam message parameter.
            </para>
            <para>
            If the asynchronous operation could not be initiated, <c>WSAAsyncGetServByPort</c> returns a zero value, and a specific error
            number can be retrieved by calling WSAGetLastError.
            </para>
            <para>
            The following error codes can be set when an application window receives a message. As described above, they can be extracted
            from the lParam in the reply message using the <c>WSAGETASYNCERROR</c> macro.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>Insufficient buffer space is available.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The proto or buf parameter is not in a valid part of the process address space.</term>
            </item>
            <item>
            <term>WSAHOST_NOT_FOUND</term>
            <term>Authoritative answer port not found.</term>
            </item>
            <item>
            <term>WSATRY_AGAIN</term>
            <term>Nonauthoritative port not found, or server failure.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>Nonrecoverable errors, the services database is not accessible.</term>
            </item>
            <item>
            <term>WSANO_DATA</term>
            <term>Valid name, no data record of requested type.</term>
            </item>
            </list>
            <para>
            The following errors can occur at the time of the function call, and indicate that the asynchronous operation could not be initiated.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>
            The asynchronous operation cannot be scheduled at this time due to resource or other constraints within the Windows Sockets implementation.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAAsyncGetServByPort</c> function is an asynchronous version of getservbyport, and is used to retrieve service
            information corresponding to a port number. Windows Sockets initiates the operation and returns to the caller immediately,
            passing back an opaque, asynchronous task handle that the application can use to identify the operation. When the operation is
            completed, the results (if any) are copied into the buffer provided by the caller and a message is sent to the application's window.
            </para>
            <para>
            When the asynchronous operation has completed, the application window indicated by the hWnd parameter receives message in the
            wMsg parameter. The wParam parameter contains the asynchronous task handle as returned by the original function call. The high
            16 bits of lParam contain any error code. The error code can be any error as defined in Winsock2.h. An error code of zero
            indicates successful completion of the asynchronous operation.
            </para>
            <para>
            On successful completion, the buffer specified to the original function call contains a servent structure. To access the members
            of this structure, the original buffer address should be cast to a <c>servent</c> structure pointer and accessed as appropriate.
            </para>
            <para>
            If the error code is WSAENOBUFS, the size of the buffer specified by buflen in the original call was too small to contain all
            the resulting information. In this case, the low 16 bits of lParam contain the size of buffer required to supply all the
            requisite information. If the application decides that the partial data is inadequate, it can reissue the
            <c>WSAAsyncGetServByPort</c> function call with a buffer large enough to receive all the desired information (that is, no
            smaller than the low 16 bits of lParam).
            </para>
            <para>
            The buffer specified to this function is used by Windows Sockets to construct a servent structure together with the contents of
            data areas referenced by members of the same <c>servent</c> structure. To avoid the WSAENOBUFS error, the application should
            provide a buffer of at least MAXGETHOSTSTRUCT bytes (as defined in Winsock2.h).
            </para>
            <para>
            The error code and buffer length should be extracted from the lParam using the macros <c>WSAGETASYNCERROR</c> and
            <c>WSAGETASYNCBUFLEN</c>, defined in Winsock2.h as:
            </para>
            <para>The use of these macros will maximize the portability of the source code for the application.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAAsyncSelect(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.HWND,System.UInt32,System.Int32)">
            <summary>
            <para>
            [The <c>WSAAsyncSelect</c> function is available for use in the operating systems specified in the Requirements section. It may
            be altered or unavailable in subsequent versions. Rather than use Select-style I/O, use Overlapped I/O and Event Objects with WinSock2.]
            </para>
            <para>The <c>WSAAsyncSelect</c> function requests Windows message-based notification of network events for a socket.</para>
            </summary>
            <param name="s">A descriptor that identifies the socket for which event notification is required.</param>
            <param name="hWnd">A handle that identifies the window that will receive a message when a network event occurs.</param>
            <param name="wMsg">A message to be received when a network event occurs.</param>
            <param name="lEvent">A bitmask that specifies a combination of network events in which the application is interested.</param>
            <returns>
            <para>
            If the <c>WSAAsyncSelect</c> function succeeds, the return value is zero, provided that the application's declaration of
            interest in the network event set was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can
            be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem failed.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            One of the specified parameters was invalid, such as the window handle not referring to an existing window, or the specified
            socket is in an invalid state.
            </term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            </list>
            <para>
            Additional error codes can be set when an application window receives a message. This error code is extracted from the lParam in
            the reply message using the <c>WSAGETSELECTERROR</c> macro. Possible error codes for each network event are listed in the
            following table.
            </para>
            <para>Event: FD_CONNECT</para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEAFNOSUPPORT</term>
            <term>Addresses in the specified family cannot be used with this socket.</term>
            </item>
            <item>
            <term>WSAECONNREFUSED</term>
            <term>The attempt to connect was rejected.</term>
            </item>
            <item>
            <term>WSAENETUNREACH</term>
            <term>The network cannot be reached from this host at this time.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The namelen parameter is invalid.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>The socket is already bound to an address.</term>
            </item>
            <item>
            <term>WSAEISCONN</term>
            <term>The socket is already connected.</term>
            </item>
            <item>
            <term>WSAEMFILE</term>
            <term>No more file descriptors are available.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>No buffer space is available. The socket cannot be connected.</term>
            </item>
            <item>
            <term>WSAENOTCONN</term>
            <term>The socket is not connected.</term>
            </item>
            <item>
            <term>WSAETIMEDOUT</term>
            <term>Attempt to connect timed out without establishing a connection.</term>
            </item>
            </list>
            <para>Event: FD_CLOSE</para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem failed.</term>
            </item>
            <item>
            <term>WSAECONNRESET</term>
            <term>The connection was reset by the remote side.</term>
            </item>
            <item>
            <term>WSAECONNABORTED</term>
            <term>The connection was terminated due to a time-out or other failure.</term>
            </item>
            </list>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem failed.</term>
            </item>
            </list>
            <para>Event: FD_ROUTING_INTERFACE_CHANGE</para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAENETUNREACH</term>
            <term>The specified destination is no longer reachable.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem failed.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAAsyncSelect</c> function is used to request that WS2_32.DLL should send a message to the window hWnd when it detects
            any network event specified by the lEvent parameter. The message that should be sent is specified by the wMsg parameter. The
            socket for which notification is required is identified by the s parameter.
            </para>
            <para>
            The <c>WSAAsyncSelect</c> function automatically sets socket s to nonblocking mode, regardless of the value of lEvent. To set
            socket s back to blocking mode, it is first necessary to clear the event record associated with socket s via a call to
            <c>WSAAsyncSelect</c> with lEvent set to zero. You can then call ioctlsocket or WSAIoctl to set the socket back to blocking
            mode. For more information about how to set the nonblocking socket back to blocking mode, see the <c>ioctlsocket</c> and
            <c>WSAIoctl</c> functions.
            </para>
            <para>The lEvent parameter is constructed by using the bitwise OR operator with any value listed in the following table.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>FD_READ</term>
            <term>Set to receive notification of readiness for reading.</term>
            </item>
            <item>
            <term>FD_WRITE</term>
            <term>Wants to receive notification of readiness for writing.</term>
            </item>
            <item>
            <term>FD_OOB</term>
            <term>Wants to receive notification of the arrival of OOB data.</term>
            </item>
            <item>
            <term>FD_ACCEPT</term>
            <term>Wants to receive notification of incoming connections.</term>
            </item>
            <item>
            <term>FD_CONNECT</term>
            <term>Wants to receive notification of completed connection or multipoint join operation.</term>
            </item>
            <item>
            <term>FD_CLOSE</term>
            <term>Wants to receive notification of socket closure.</term>
            </item>
            <item>
            <term>FD_QOS</term>
            <term>Wants to receive notification of socket Quality of Service (QoS) changes.</term>
            </item>
            <item>
            <term>FD_GROUP_QOS</term>
            <term>
            Wants to receive notification of socket group Quality of Service (QoS) changes (reserved for future use with socket groups). Reserved.
            </term>
            </item>
            <item>
            <term>FD_ROUTING_INTERFACE_CHANGE</term>
            <term>Wants to receive notification of routing interface changes for the specified destination(s).</term>
            </item>
            <item>
            <term>FD_ADDRESS_LIST_CHANGE</term>
            <term>Wants to receive notification of local address list changes for the socket protocol family.</term>
            </item>
            </list>
            <para>
            Issuing a <c>WSAAsyncSelect</c> for a socket cancels any previous <c>WSAAsyncSelect</c> or WSAEventSelect for the same socket.
            For example, to receive notification for both reading and writing, the application must call <c>WSAAsyncSelect</c> with both
            <c>FD_READ</c> and <c>FD_WRITE</c>, as follows:
            </para>
            <para>
            It is not possible to specify different messages for different events. The following code will not work; the second call will
            cancel the effects of the first, and only <c>FD_WRITE</c> events will be reported with message wMsg2:
            </para>
            <para>
            To cancel all notification indicating that Windows Sockets should send no further messages related to network events on the
            socket, lEvent is set to zero.
            </para>
            <para>
            Although <c>WSAAsyncSelect</c> immediately disables event message posting for the socket in this instance, it is possible that
            messages could be waiting in the application message queue. Therefore, the application must be prepared to receive network event
            messages even after cancellation. Closing a socket with closesocket also cancels <c>WSAAsyncSelect</c> message sending, but the
            same caveat about messages in the queue still applies.
            </para>
            <para>
            The socket created by the accept function has the same properties as the listening socket used to accept it. Consequently,
            <c>WSAAsyncSelect</c> events set for the listening socket also apply to the accepted socket. For example, if a listening socket
            has <c>WSAAsyncSelect</c> events <c>FD_ACCEPT</c>, <c>FD_READ</c>, and <c>FD_WRITE</c>, then any socket accepted on that
            listening socket will also have <c>FD_ACCEPT</c>, <c>FD_READ</c>, and <c>FD_WRITE</c> events with the same wMsg value used for
            messages. If a different wMsg or events are desired, the application should call <c>WSAAsyncSelect</c>, passing the accepted
            socket and the desired new data.
            </para>
            <para>
            When one of the nominated network events occurs on the specified socket s, the application window hWnd receives message wMsg.
            The wParam parameter identifies the socket on which a network event has occurred. The low word of lParam specifies the network
            event that has occurred. The high word of lParam contains any error code. The error code be any error as defined in Winsock2.h.
            </para>
            <para>
            <c>Note</c> Upon receipt of an event notification message, the WSAGetLastError function cannot be used to check the error value
            because the error value returned can differ from the value in the high word of lParam.
            </para>
            <para>
            The error and event codes can be extracted from the lParam using the macros <c>WSAGETSELECTERROR</c> and
            <c>WSAGETSELECTEVENT</c>, defined in Winsock2.h as:
            </para>
            <para>The use of these macros will maximize the portability of the source code for the application.</para>
            <para>The possible network event codes that can be returned are listed in the following table.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>FD_READ</term>
            <term>Socket s ready for reading.</term>
            </item>
            <item>
            <term>FD_WRITE</term>
            <term>Socket s ready for writing.</term>
            </item>
            <item>
            <term>FD_OOB</term>
            <term>OOB data ready for reading on socket s</term>
            </item>
            <item>
            <term>FD_ACCEPT</term>
            <term>Socket s ready for accepting a new incoming connection.</term>
            </item>
            <item>
            <term>FD_CONNECT</term>
            <term>Connection or multipoint join operation initiated on socket s completed.</term>
            </item>
            <item>
            <term>FD_CLOSE</term>
            <term>Connection identified by socket s has been closed.</term>
            </item>
            <item>
            <term>FD_QOS</term>
            <term>Quality of Service associated with socket s has changed.</term>
            </item>
            <item>
            <term>FD_GROUP_QOS</term>
            <term>
            Reserved. Quality of Service associated with the socket group to which s belongs has changed (reserved for future use with
            socket groups).
            </term>
            </item>
            <item>
            <term>FD_ROUTING_INTERFACE_CHANGE</term>
            <term>Local interface that should be used to send to the specified destination has changed.</term>
            </item>
            <item>
            <term>FD_ADDRESS_LIST_CHANGE</term>
            <term>The list of addresses of the socket protocol family to which the application client can bind has changed.</term>
            </item>
            </list>
            <para>
            Although <c>WSAAsyncSelect</c> can be called with interest in multiple events, the application window will receive a single
            message for each network event.
            </para>
            <para>
            As in the case of the select function, <c>WSAAsyncSelect</c> will frequently be used to determine when a data transfer operation
            (send or recv) can be issued with the expectation of immediate success. Nevertheless, a robust application must be prepared for
            the possibility that it can receive a message and issue a Windows Sockets 2 call that returns WSAEWOULDBLOCK immediately. For
            example, the following sequence of events is possible:
            </para>
            <list type="number">
            <item>
            <term>Data arrives on socket s; Windows Sockets 2 posts <c>WSAAsyncSelect</c> message</term>
            </item>
            <item>
            <term>Application processes some other message</term>
            </item>
            <item>
            <term>While processing, application issues an and notices that there is data ready to be read</term>
            </item>
            <item>
            <term>Application issues a to read the data</term>
            </item>
            <item>
            <term>
            Application loops to process next message, eventually reaching the <c>WSAAsyncSelect</c> message indicating that data is ready
            to read
            </term>
            </item>
            <item>
            <term>Application issues , which fails with the error WSAEWOULDBLOCK.</term>
            </item>
            </list>
            <para>Other sequences are also possible.</para>
            <para>
            The WS2_32.DLL will not continually flood an application with messages for a particular network event. Having successfully
            posted notification of a particular event to an application window, no further message(s) for that network event will be posted
            to the application window until the application makes the function call that implicitly reenables notification of that network event.
            </para>
            <list type="table">
            <listheader>
            <term>Event</term>
            <term>Reenabling function</term>
            </listheader>
            <item>
            <term>FD_READ</term>
            <term>recv, recvfrom, WSARecv, or WSARecvFrom.</term>
            </item>
            <item>
            <term>FD_WRITE</term>
            <term>send, sendto, WSASend, or WSASendTo.</term>
            </item>
            <item>
            <term>FD_OOB</term>
            <term>recv, recvfrom, WSARecv, or WSARecvFrom.</term>
            </item>
            <item>
            <term>FD_ACCEPT</term>
            <term>accept or WSAAccept unless the error code is WSATRY_AGAIN indicating that the condition function returned CF_DEFER.</term>
            </item>
            <item>
            <term>FD_CONNECT</term>
            <term>None.</term>
            </item>
            <item>
            <term>FD_CLOSE</term>
            <term>None.</term>
            </item>
            <item>
            <term>FD_QOS</term>
            <term>WSAIoctl with command SIO_GET_QOS.</term>
            </item>
            <item>
            <term>FD_GROUP_QOS</term>
            <term>Reserved. WSAIoctl with command SIO_GET_GROUP_QOS (reserved for future use with socket groups).</term>
            </item>
            <item>
            <term>FD_ROUTING_INTERFACE_CHANGE</term>
            <term>WSAIoctl with command SIO_ROUTING_INTERFACE_CHANGE.</term>
            </item>
            <item>
            <term>FD_ADDRESS_LIST_CHANGE</term>
            <term>WSAIoctl with command SIO_ADDRESS_LIST_CHANGE.</term>
            </item>
            </list>
            <para>Any call to the reenabling routine, even one that fails, results in reenabling of message posting for the relevant event.</para>
            <para>
            For <c>FD_READ</c>, <c>FD_OOB</c>, and <c>FD_ACCEPT</c> events, message posting is level-triggered. This means that if the
            reenabling routine is called and the relevant condition is still met after the call, a <c>WSAAsyncSelect</c> message is posted
            to the application. This allows an application to be event-driven and not be concerned with the amount of data that arrives at
            any one time. Consider the following sequence:
            </para>
            <list type="number">
            <item>
            <term>
            Network transport stack receives 100 bytes of data on socket s and causes Windows Sockets 2 to post an <c>FD_READ</c> message.
            </term>
            </item>
            <item>
            <term>The application issues recv( s, buffptr, 50, 0) to read 50 bytes.</term>
            </item>
            <item>
            <term>Another <c>FD_READ</c> message is posted because there is still data to be read.</term>
            </item>
            </list>
            <para>
            With these semantics, an application need not read all available data in response to an <c>FD_READ</c> messagea single recv in
            response to each <c>FD_READ</c> message is appropriate. If an application issues multiple <c>recv</c> calls in response to a
            single <c>FD_READ</c>, it can receive multiple <c>FD_READ</c> messages. Such an application can require disabling <c>FD_READ</c>
            messages before starting the <c>recv</c> calls by calling <c>WSAAsyncSelect</c> with the <c>FD_READ</c> event not set.
            </para>
            <para>
            The <c>FD_QOS</c> and <c>FD_GROUP_QOS</c> events are considered edge triggered. A message will be posted exactly once when a
            quality of service change occurs. Further messages will not be forthcoming until either the provider detects a further change in
            quality of service or the application renegotiates the quality of service for the socket.
            </para>
            <para>
            The <c>FD_ROUTING_INTERFACE_CHANGE</c> message is posted when the local interface that should be used to reach the destination
            specified in WSAIoctl with SIO_ROUTING_INTERFACE_CHANGE changes after such IOCTL has been issued.
            </para>
            <para>
            The <c>FD_ADDRESS_LIST_CHANGE</c> message is posted when the list of addresses to which the application can bind changes after
            WSAIoctl with SIO_ADDRESS_LIST_CHANGE has been issued.
            </para>
            <para>
            If any event has occurred when the application calls <c>WSAAsyncSelect</c> or when the reenabling function is called, then a
            message is posted as appropriate. For example, consider the following sequence:
            </para>
            <list type="number">
            <item>
            <term>An application calls listen.</term>
            </item>
            <item>
            <term>A connect request is received, but not yet accepted.</term>
            </item>
            <item>
            <term>
            The application calls <c>WSAAsyncSelect</c> specifying that it requires receiving <c>FD_ACCEPT</c> messages for the socket. Due
            to the persistence of events, Windows Sockets 2 posts an <c>FD_ACCEPT</c> message immediately.
            </term>
            </item>
            </list>
            <para>
            The <c>FD_WRITE</c> event is handled slightly differently. An <c>FD_WRITE</c> message is posted when a socket is first connected
            with connect or WSAConnect (after FD_CONNECT, if also registered) or accepted with accept or WSAAccept, and then after a send
            operation fails with WSAEWOULDBLOCK and buffer space becomes available. Therefore, an application can assume that sends are
            possible starting from the first <c>FD_WRITE</c> message and lasting until a send returns WSAEWOULDBLOCK. After such a failure
            the application will be notified that sends are again possible with an <c>FD_WRITE</c> message.
            </para>
            <para>
            The <c>FD_OOB</c> event is used only when a socket is configured to receive OOB data separately. If the socket is configured to
            receive OOB data inline, the OOB (expedited) data is treated as normal data and the application should register an interest in,
            and will receive, <c>FD_READ</c> events, not <c>FD_OOB</c> events. An application can set or inspect the way in which OOB data
            is to be handled by using setsockopt or getsockopt for the SO_OOBINLINE option.
            </para>
            <para>
            The error code in an <c>FD_CLOSE</c> message indicates whether the socket close was graceful or abortive. If the error code is
            zero, then the close was graceful; if the error code is WSAECONNRESET, then the socket's virtual circuit was reset. This only
            applies to connection-oriented sockets such as SOCK_STREAM.
            </para>
            <para>
            The <c>FD_CLOSE</c> message is posted when a close indication is received for the virtual circuit corresponding to the socket.
            In TCP terms, this means that the <c>FD_CLOSE</c> is posted when the connection goes into the TIME WAIT or CLOSE WAIT states.
            This results from the remote end performing a shutdown on the send side or a closesocket. <c>FD_CLOSE</c> should only be posted
            after all data is read from a socket, but an application should check for remaining data upon receipt of <c>FD_CLOSE</c> to
            avoid any possibility of losing data.
            </para>
            <para>
            Be aware that the application will only receive an <c>FD_CLOSE</c> message to indicate closure of a virtual circuit, and only
            when all the received data has been read if this is a graceful close. It will not receive an <c>FD_READ</c> message to indicate
            this condition.
            </para>
            <para>
            The <c>FD_QOS</c> or <c>FD_GROUP_QOS</c> message is posted when any parameter in the flow specification associated with socket s
            or the socket group that s belongs to has changed, respectively. Applications should use WSAIoctl with command SIO_GET_QOS or
            SIO_GET_GROUP_QOS to get the current quality of service for socket s or for the socket group s belongs to, respectively.
            </para>
            <para>
            The <c>FD_ROUTING_INTERFACE_CHANGE</c> and <c>FD_ADDRESS_LIST_CHANGE</c> events are considered edge triggered as well. A message
            will be posted exactly once when a change occurs after the application has requested the notification by issuing WSAIoctl with
            SIO_ROUTING_INTERFACE_CHANGE or SIO_ADDRESS_LIST_CHANGE correspondingly. Further messages will not be forthcoming until the
            application reissues the IOCTL and another change is detected because the IOCTL has been issued.
            </para>
            <para>Here is a summary of events and conditions for each asynchronous notification message.</para>
            <list type="bullet">
            <item>
            <term><c>FD_READ</c>:</term>
            </item>
            <item>
            <term><c>FD_WRITE</c>:</term>
            </item>
            <item>
            <term><c>FD_OOB</c>: Only valid when setsockopt SO_OOBINLINE is disabled (default).</term>
            </item>
            <item>
            <term><c>FD_ACCEPT</c>:</term>
            </item>
            <item>
            <term><c>FD_CONNECT</c>:</term>
            </item>
            <item>
            <term><c>FD_CLOSE</c>: Only valid on connection-oriented sockets (for example, SOCK_STREAM)</term>
            </item>
            <item>
            <term><c>FD_QOS</c>:</term>
            </item>
            <item>
            <term><c>FD_GROUP_QOS</c>: Reserved.</term>
            </item>
            <item>
            <term><c>FD_ROUTING_INTERFACE_CHANGE</c>:</term>
            </item>
            <item>
            <term><c>FD_ADDRESS_LIST_CHANGE</c>:</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSACancelAsyncRequest(Vanara.PInvoke.HANDLE)">
            <summary>The <c>WSACancelAsyncRequest</c> function cancels an incomplete asynchronous operation.</summary>
            <param name="hAsyncTaskHandle">Handle that specifies the asynchronous operation to be canceled.</param>
            <returns>
            <para>
            The value returned by <c>WSACancelAsyncRequest</c> is zero if the operation was successfully canceled. Otherwise, the value
            SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>Indicates that the specified asynchronous task handle was invalid.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEALREADY</term>
            <term>The asynchronous routine being canceled has already completed.</term>
            </item>
            </list>
            <para>
            <c>Note</c> It is unclear whether the application can usefully distinguish between WSAEINVAL and WSAEALREADY, since in both
            cases the error indicates that there is no asynchronous operation in progress with the indicated handle. (Trivial exception:
            zero is always an invalid asynchronous task handle.) The Windows Sockets specification does not prescribe how a conformant
            Windows Sockets provider should distinguish between the two cases. For maximum portability, a Windows Sockets application should
            treat the two errors as equivalent.
            </para>
            </returns>
            <remarks>
            <para>
            The <c>WSACancelAsyncRequest</c> function is used to cancel an asynchronous operation that was initiated by one of the
            <c>WSAAsyncGetXByY</c> functions such as WSAAsyncGetHostByName. The operation to be canceled is identified by the
            hAsyncTaskHandle parameter, which should be set to the asynchronous task handle as returned by the initiating
            <c>WSAAsyncGetXByY</c> function.
            </para>
            <para>
            An attempt to cancel an existing asynchronous <c>WSAAsyncGetXByY</c> operation can fail with an error code of WSAEALREADY for
            two reasons. First, the original operation has already completed and the application has dealt with the resultant message.
            Second, the original operation has already completed but the resultant message is still waiting in the application window queue.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSACleanup">
            <summary>The <c>WSACleanup</c> function terminates use of the Winsock 2 DLL (Ws2_32.dll).</summary>
            <returns>
            <para>
            The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error
            number can be retrieved by calling WSAGetLastError.
            </para>
            <para>In a multithreaded environment, <c>WSACleanup</c> terminates Windows Sockets operations for all threads.</para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            An application or DLL is required to perform a successful WSAStartup call before it can use Windows Sockets services. When it
            has completed the use of Windows Sockets, the application or DLL must call <c>WSACleanup</c> to deregister itself from a Windows
            Sockets implementation and allow the implementation to free any resources allocated on behalf of the application or DLL.
            </para>
            <para>
            When <c>WSACleanup</c> is called, any pending blocking or asynchronous Windows Sockets calls issued by any thread in this
            process are canceled without posting any notification messages or without signaling any event objects. Any pending overlapped
            send or receive operations (WSASend, WSASendTo, WSARecv, or WSARecvFrom with an overlapped socket, for example) issued by any
            thread in this process are also canceled without setting the event object or invoking the completion routine, if one was
            specified. In this case, the pending overlapped operations fail with the error status <c>WSA_OPERATION_ABORTED</c>.
            </para>
            <para>
            Sockets that were open when <c>WSACleanup</c> was called are reset and automatically deallocated as if closesocket were called.
            Sockets that have been closed with <c>closesocket</c> but that still have pending data to be sent can be affected when
            <c>WSACleanup</c> is called. In this case, the pending data can be lost if the WS2_32.DLL is unloaded from memory as the
            application exits. To ensure that all pending data is sent, an application should use shutdown to close the connection, then
            wait until the close completes before calling <c>closesocket</c> and <c>WSACleanup</c>. All resources and internal state, such
            as queued unposted or posted messages, must be deallocated so as to be available to the next user.
            </para>
            <para>
            There must be a call to <c>WSACleanup</c> for each successful call to WSAStartup. Only the final <c>WSACleanup</c> function call
            performs the actual cleanup. The preceding calls simply decrement an internal reference count in the WS2_32.DLL.
            </para>
            <para>
            <c>Note</c><c>WSACleanup</c> does not unregister names (peer names, for example) that may have been registered with a Windows
            Sockets namespace provider such as Peer Name Resolution Protocol (PNRP) namespace provider.
            </para>
            <para>
            In Windows Sockets 1.1, attempting to call <c>WSACleanup</c> from within a blocking hook and then failing to check the return
            code was a common programming error. If a Winsock 1.1 application needs to quit while a blocking call is outstanding, the
            application has to first cancel the blocking call with WSACancelBlockingCall then issue the <c>WSACleanup</c> call once control
            has been returned to the application. In Windows Sockets 2, this issue does not exist and the <c>WSACancelBlockingCall</c>
            function has been removed.
            </para>
            <para>
            The <c>WSACleanup</c> function typically leads to protocol-specific helper DLLs being unloaded. As a result, the
            <c>WSACleanup</c> function should not be called from the DllMain function in a application DLL. This can potentially cause
            deadlocks. For more information, please see the DLL Main Function.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSACloseEvent(Vanara.PInvoke.Ws2_32.WSAEVENT)">
            <summary>The <c>WSACloseEvent</c> function closes an open event object handle.</summary>
            <param name="hEvent">Object handle identifying the open event.</param>
            <returns>
            <para>If the function succeeds, the return value is <c>TRUE</c>.</para>
            <para>If the function fails, the return value is <c>FALSE</c>. To get extended error information, call WSAGetLastError.</para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSA_INVALID_HANDLE</term>
            <term>The hEvent is not a valid event object handle.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSACloseEvent</c> function closes the handle to an event object and frees resources associated with the event object.
            This function is used to close a handle created by the WSACreateEventfunction. Once the handle to the event object is closed,
            further references to this handle will fail with the error WSA_INVALID_HANDLE.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAConnect(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.SOCKADDR,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            The <c>WSAConnect</c> function establishes a connection to another socket application, exchanges connect data, and specifies
            required quality of service based on the specified FLOWSPEC structure.
            </summary>
            <param name="s">A descriptor identifying an unconnected socket.</param>
            <param name="name">
            A pointer to a sockaddr structure that specifies the address to which to connect. For IPv4, the <c>sockaddr</c> contains
            <c>AF_INET</c> for the address family, the destination IPv4 address, and the destination port. For IPv6, the <c>sockaddr</c>
            structure contains <c>AF_INET6</c> for the address family, the destination IPv6 address, the destination port, and may contain
            additional flow and scope-id information.
            </param>
            <param name="namelen">The length, in bytes, of the sockaddr structure pointed to by the name parameter.</param>
            <param name="lpCallerData">
            A pointer to the user data that is to be transferred to the other socket during connection establishment. See Remarks.
            </param>
            <param name="lpCalleeData">
            A pointer to the user data that is to be transferred back from the other socket during connection establishment. See Remarks.
            </param>
            <param name="lpSQOS">A pointer to the FLOWSPEC structures for socket s, one for each direction.</param>
            <param name="lpGQOS">
            Reserved for future use with socket groups. A pointer to the FLOWSPEC structures for the socket group (if applicable). This
            parameter should be <c>NULL</c>.
            </param>
            <returns>
            <para>
            If no error occurs, <c>WSAConnect</c> returns zero. Otherwise, it returns SOCKET_ERROR, and a specific error code can be
            retrieved by calling WSAGetLastError. On a blocking socket, the return value indicates success or failure of the connection attempt.
            </para>
            <para>
            With a nonblocking socket, the connection attempt cannot be completed immediately. In this case, <c>WSAConnect</c> will return
            SOCKET_ERROR, and WSAGetLastError will return WSAEWOULDBLOCK; the application could therefore:
            </para>
            <list type="bullet">
            <item>
            <term>Use select to determine the completion of the connection request by checking if the socket is writeable.</term>
            </item>
            <item>
            <term>
            If your application is using WSAAsyncSelect to indicate interest in connection events, then your application will receive an
            FD_CONNECT notification when the connect operation is complete(successful or not).
            </term>
            </item>
            <item>
            <term>
            If your application is using WSAEventSelect to indicate interest in connection events, then the associated event object will be
            signaled when the connect operation is complete (successful or not).
            </term>
            </item>
            </list>
            <para>
            For a nonblocking socket, until the connection attempt completes all subsequent calls to <c>WSAConnect</c> on the same socket
            will fail with the error code WSAEALREADY.
            </para>
            <para>
            If the return error code indicates the connection attempt failed (that is, WSAECONNREFUSED, WSAENETUNREACH, WSAETIMEDOUT) the
            application can call <c>WSAConnect</c> again for the same socket.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEADDRINUSE</term>
            <term>
            The local address of the socket is already in use and the socket was not marked to allow address reuse with SO_REUSEADDR. This
            error usually occurs during the execution of bind, but could be delayed until this function if the bind function operates on a
            partially wildcard address (involving ADDR_ANY) and if a specific address needs to be "committed" at the time of this function.
            </term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>The (blocking) Windows Socket 1.1 call was canceled through WSACancelBlockingCall.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEALREADY</term>
            <term>A nonblocking connect or WSAConnect call is in progress on the specified socket.</term>
            </item>
            <item>
            <term>WSAEADDRNOTAVAIL</term>
            <term>The remote address is not a valid address (such as ADDR_ANY).</term>
            </item>
            <item>
            <term>WSAEAFNOSUPPORT</term>
            <term>Addresses in the specified family cannot be used with this socket.</term>
            </item>
            <item>
            <term>WSAECONNREFUSED</term>
            <term>The attempt to connect was rejected.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The name or the namelen parameter is not a valid part of the user address space, the namelen parameter is too small, the buffer
            length for lpCalleeData, lpSQOS, and lpGQOS are too small, or the buffer length for lpCallerData is too large.
            </term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            The parameter s is a listening socket, or the destination address specified is not consistent with that of the constrained group
            to which the socket belongs, or the lpGQOS parameter is not NULL.
            </term>
            </item>
            <item>
            <term>WSAEISCONN</term>
            <term>The socket is already connected (connection-oriented sockets only).</term>
            </item>
            <item>
            <term>WSAENETUNREACH</term>
            <term>The network cannot be reached from this host at this time.</term>
            </item>
            <item>
            <term>WSAEHOSTUNREACH</term>
            <term>A socket operation was attempted to an unreachable host.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>No buffer space is available. The socket cannot be connected.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>The FLOWSPEC structures specified in lpSQOS and lpGQOS cannot be satisfied.</term>
            </item>
            <item>
            <term>WSAEPROTONOSUPPORT</term>
            <term>The lpCallerData parameter is not supported by the service provider.</term>
            </item>
            <item>
            <term>WSAETIMEDOUT</term>
            <term>Attempt to connect timed out without establishing a connection.</term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>The socket is marked as nonblocking and the connection cannot be completed immediately.</term>
            </item>
            <item>
            <term>WSAEACCES</term>
            <term>Attempt to connect datagram socket to broadcast address failed because setsockopt SO_BROADCAST is not enabled.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAConnect</c> function is used to create a connection to the specified destination, and to perform a number of other
            ancillary operations that occur at connect time. If the socket, s, is unbound, unique values are assigned to the local
            association by the system, and the socket is marked as bound.
            </para>
            <para>
            For applications targeted to Windows Vista and later, consider using the WSAConnectByList or WSAConnectByName function which
            greatly simplify client application design.
            </para>
            <para>
            For connection-oriented sockets (for example, type SOCK_STREAM), an active connection is initiated to the foreign host using
            name (an address in the namespace of the socket; for a detailed description, please see bind). When this call completes
            successfully, the socket is ready to send/receive data. If the address parameter of the name structure is all zeroes,
            <c>WSAConnect</c> will return the error WSAEADDRNOTAVAIL. Any attempt to reconnect an active connection will fail with the error
            code WSAEISCONN.
            </para>
            <para>
            <c>Note</c> If a socket is opened, a setsockopt call is made, and then a sendto call is made, Windows Sockets performs an
            implicit bind function call.
            </para>
            <para>
            For connection-oriented, nonblocking sockets, it is often not possible to complete the connection immediately. In such cases,
            this function returns the error WSAEWOULDBLOCK. However, the operation proceeds. When the success or failure outcome becomes
            known, it may be reported in one of several ways depending on how the client registers for notification. If the client uses
            select, success is reported in the writefds set and failure is reported in the exceptfds set. If the client uses WSAAsyncSelect
            or WSAEventSelect, the notification is announced with FD_CONNECT and the error code associated with the FD_CONNECT indicates
            either success or a specific reason for failure.
            </para>
            <para>
            For a connectionless socket (for example, type SOCK_DGRAM), the operation performed by <c>WSAConnect</c> is merely to establish
            a default destination address so that the socket can be used on subsequent connection-oriented send and receive operations
            (send, WSASend, recv, and WSARecv). Any datagrams received from an address other than the destination address specified will be
            discarded. If the entire name structure is all zeros (not just the address parameter of the name structure), then the socket
            will be disconnected. Then, the default remote address will be indeterminate, so <c>send</c>, <c>WSASend</c>, <c>recv</c>, and
            <c>WSARecv</c> calls will return the error code WSAENOTCONN. However, sendto, WSASendTo, recvfrom, and WSARecvFrom can still be
            used. The default destination can be changed by simply calling <c>WSAConnect</c> again, even if the socket is already connected.
            Any datagrams queued for receipt are discarded if name is different from the previous <c>WSAConnect</c>.
            </para>
            <para>
            For connectionless sockets, name can indicate any valid address, including a broadcast address. However, to connect to a
            broadcast address, a socket must have setsockopt SO_BROADCAST enabled. Otherwise, <c>WSAConnect</c> will fail with the error
            code WSAEACCES.
            </para>
            <para>
            On connectionless sockets, exchange of user-to-user data is not possible and the corresponding parameters will be silently ignored.
            </para>
            <para>
            The application is responsible for allocating any memory space pointed to directly or indirectly by any of the parameters it specifies.
            </para>
            <para>
            The lpCallerData parameter contains a pointer to any user data that is to be sent along with the connection request (called
            connect data). This is additional data, not in the normal network data stream, that is sent with network requests to establish a
            connection. This option is used by legacy protocols such as DECNet, OSI TP4, and others.
            </para>
            <para>
            If lpCallerData is <c>NULL</c>, no user data will be passed to the peer. The lpCalleeData is a result parameter that will
            contain any user data passed back from the other socket as part of the connection establishment in a WSABUF structure. The
            <c>len</c> member of the <c>WSABUF</c> structure pointed to by the lpCalleeData parameter initially contains the length of the
            buffer allocated by the application for the <c>buf</c> member of the <c>WSABUF</c> structure. The <c>len</c> member of the
            <c>WSABUF</c> structure pointed to by the lpCalleeData parameter will be set to zero if no user data has been passed back. The
            lpCalleeData information will be valid when the connection operation is complete. For blocking sockets, the connection operation
            completes when the <c>WSAConnect</c> function returns. For nonblocking sockets, completion will be after the FD_CONNECT
            notification has occurred. If lpCalleeData is <c>NULL</c>, no user data will be passed back. The exact format of the user data
            is specific to the address family to which the socket belongs.
            </para>
            <para>
            At connect time, an application can use the lpSQOS and lpGQOS parameter to override any previous quality of service
            specification made for the socket through WSAIoctl with either the SIO_SET_QOS or SIO_SET_GROUP_QOS opcode.
            </para>
            <para>
            The lpSQOS parameter specifies the FLOWSPEC structures for socket s, one for each direction, followed by any additional
            provider-specific parameters. If either the associated transport provider in general or the specific type of socket in
            particular cannot honor the quality of service request, an error will be returned as indicated in the following. The sending or
            receiving flow specification values will be ignored, respectively, for any unidirectional sockets. If no provider-specific
            parameters are specified, the <c>buf</c> and <c>len</c> members of the WSABUF structure pointed to by the lpCalleeData parameter
            should be set to <c>NULL</c> and zero, respectively. A <c>NULL</c> value for lpSQOS parameter indicates no application-supplied
            quality of service.
            </para>
            <para>
            Reserved for future use with socket groups lpGQOS specifies the FLOWSPEC structures for the socket group (if applicable), one
            for each direction, followed by any additional provider-specific parameters. If no provider-specific parameters are specified,
            the <c>buf</c> and <c>len</c> members of the WSABUF structure pointed to by the lpCalleeData parameter should be set to
            <c>NULL</c> and zero, respectively. A <c>NULL</c> value for lpGQOS indicates no application-supplied group quality of service.
            This parameter will be ignored if s is not the creator of the socket group.
            </para>
            <para>
            When connected sockets become closed for whatever reason, they should be discarded and recreated. It is safest to assume that
            when things go awry for any reason on a connected socket, the application must discard and recreate the needed sockets in order
            to return to a stable point.
            </para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>WSAConnect</c>, Winsock may need to wait for a network event before
            the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous
            procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an
            ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAConnectByList(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.SOCKET_ADDRESS_LIST@,System.UInt32@,Vanara.PInvoke.Ws2_32.SOCKADDR,System.UInt32@,Vanara.PInvoke.Ws2_32.SOCKADDR,System.IntPtr,System.IntPtr)">
            <summary>
            <para>
            The <c>WSAConnectByList</c> function establishes a connection to one out of a collection of possible endpoints represented by a
            set of destination addresses (host names and ports). This function takes all the destination addresses passed to it and all of
            the local computer's source addresses, and tries connecting using all possible address combinations before giving up.
            </para>
            <para>This function supports both IPv4 and IPv6 addresses.</para>
            </summary>
            <param name="s">
            A descriptor that identifies an unbound and unconnected socket. Note that unlike other Winsock calls to establish a connection
            (for example, WSAConnect), the <c>WSAConnectByList</c> function requires an unbound socket.
            </param>
            <param name="SocketAddress">
            A pointer to a SOCKET_ADDRESS_LIST structure that represents the possible destination address and port pairs to connect to a
            peer. It is the application's responsibility to fill in the port number in the each SOCKET_ADDRESS structure in the <c>SOCKET_ADDRESS_LIST</c>.
            </param>
            <param name="LocalAddressLength">
            On input, a pointer to the size, in bytes, of the LocalAddress buffer provided by the caller. On output, a pointer to the size,
            in bytes, of the <c>SOCKADDR</c> for the local address stored in the LocalAddress buffer filled in by the system upon successful
            completion of the call.
            </param>
            <param name="LocalAddress">
            A pointer to the <c>SOCKADDR</c> structure that receives the local address of the connection. The size of the parameter is
            exactly the size returned in LocalAddressLength. This is the same information that would be returned by the getsockname
            function. This parameter can be <c>NULL</c>, in which case, the LocalAddressLength parameter is ignored.
            </param>
            <param name="RemoteAddressLength">
            On input, a pointer to the size, in bytes, of the RemoteAddress buffer provided by the caller. On output, a pointer to the size,
            in bytes, of the <c>SOCKADDR</c> for the remote address stored in RemoteAddress buffer filled-in by the system upon successful
            completion of the call.
            </param>
            <param name="RemoteAddress">
            A pointer to the <c>SOCKADDR</c> structure that receives the remote address of the connection. This is the same information that
            would be returned by the <c>getpeername</c> function. This parameter can be <c>NULL</c>, in which case, the RemoteAddressLength
            is ignored.
            </param>
            <param name="timeout">
            The time, in milliseconds, to wait for a response from the remote application before aborting the call. This parameter can be
            <c>NULL</c> in which case <c>WSAConnectByList</c> will complete after either the connection is successfully established or after
            a connection was attempted and failed on all possible local-remote address pairs.
            </param>
            <param name="Reserved">Reserved for future implementation. This parameter must be set to <c>NULL</c>.</param>
            <returns>
            <para>
            If a connection is established, <c>WSAConnectByList</c> returns <c>TRUE</c> and LocalAddress and RemoteAddress parameters are
            filled in if these buffers were supplied by the caller.
            </para>
            <para>If the call fails, <c>FALSE</c> is returned. WSAGetLastError can then be called to get extended error information.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>WSAEHOSTUNREACH</term>
            <term>The host passed as the nodename parameter was unreachable.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>An invalid parameter was passed to the function. The Reserved parameter must be NULL.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>Sufficient memory could not be allocated.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>An invalid socket was passed to the function. The s parameter must not be INVALID_SOCKET or NULL.</term>
            </item>
            <item>
            <term>WSAETIMEDOUT</term>
            <term>A response from the remote application was not received before the timeout parameter was exceeded.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>WSAConnectByList</c> is similar to the WSAConnectByName function. Instead of taking a single host name and service name
            (port), <c>WSAConnectByList</c> takes a list of addresses (host addresses and ports) and connects to one of the addresses. The
            <c>WSAConnectByList</c> function is designed to support peer-to-peer collaboration scenarios where an application needs to
            connect to any available node out of a list of potential nodes. <c>WSAConnectByList</c> is compatible with both IPv6 and IPv4 versions.
            </para>
            <para>
            The set of possible destinations, represented by a list of addresses, is provided by the caller. <c>WSAConnectByList</c> does
            more than simply attempt to connect to one of possibly many destination addresses. Specifically, the function takes all remote
            addresses passed in by the caller, all local addresses, and then attempts a connection first using address pairs with the
            highest chance of success. As such, <c>WSAConnectByList</c> not only ensures that connection will be established if a connection
            is at all possible, but also minimizes the time to establish the connection.
            </para>
            <para>
            The caller can specify the LocalAddress and RemoteAddress buffers and lengths to determine the local and remote addresses for
            which the connection was successfully established.
            </para>
            <para>
            The timeout parameter allows the caller to limit the time spent by the function in establishing a connection. Internally,
            <c>WSAConnectByList</c> performs multiple operations (connection attempts). In between each operation, the timeout parameter is
            checked to see if the timeout has been exceeded and, if so, the call is aborted. Note that an individual operation (connect)
            will not be interrupted once the timeout is exceeded, so the <c>WSAConnectByList</c> call can take longer to time out than the
            value specified in the timeout parameter.
            </para>
            <para>
            <c>WSAConnectByList</c> has limitations: It works only for connection-oriented sockets, such as those of type SOCK_STREAM. The
            function does not support overlapped I/O or non-blocking behavior. <c>WSAConnectByList</c> will block even if the socket is in
            non-blocking mode. <c>WSAConnectByList</c> will try connecting (one-by-one) to the various addresses provided by the caller.
            Potentially, each of these connection attempts may fail with a different error code. Since only a single error code can be
            returned, the value returned is the error code from the last connection attempt.
            </para>
            <para>
            To enable both IPv6 and IPv4 addresses to be passed in the single address list accepted by the function, the following steps
            must be performed prior to calling the function:
            </para>
            <list type="bullet">
            <item>
            <term>
            The setsockopt function must be called on a socket created for the AF_INET6 address family to disable the <c>IPV6_V6ONLY</c>
            socket option before calling <c>WSAConnectByList</c>. This is accomplished by calling the <c>setsockopt</c> function on the
            socket with the level parameter set to <c>IPPROTO_IPV6</c> (see IPPROTO_IPV6 Socket Options), the optname parameter set to
            <c>IPV6_V6ONLY</c>, and the optvalue parameter value set to zero .
            </term>
            </item>
            <item>
            <term>
            Any IPv4 addresses must be represented in the IPv4-mapped IPv6 address format which enables an IPv6 only application to
            communicate with an IPv4 node. The IPv4-mapped IPv6 address format allows the IPv4 address of an IPv4 node to be represented as
            an IPv6 address. The IPv4 address is encoded into the low-order 32 bits of the IPv6 address, and the high-order 96 bits hold the
            fixed prefix 0:0:0:0:0:FFFF. The IPv4-mapped IPv6 address format is specified in RFC 4291. For more information, see
            www.ietf.org/rfc/rfc4291.txt. The IN6ADDR_SETV4MAPPED macro in Mstcpip.h can be used to convert an IPv4 address to the required
            IPv4-mapped IPv6 address format.
            </term>
            </item>
            </list>
            <para>
            The arrays of pointers passed in the SocketAddressList parameter point to an array of SOCKET_ADDRESS structures, which are a
            generic data type. The RemoteAddress and the LocalAddress parameters also point to <c>SOCKADDR</c> structures. When
            <c>WSAConnectByList</c> is called, it is expected that a socket address type specific to the network protocol or address family
            being used will actually be passed in these parameters. So for IPv4 addresses, a pointer to a <c>sockaddr_in</c> structure would
            be cast to a pointer to <c>SOCKADDR</c> when passed as a parameter. For IPv6 addresses, a pointer to a <c>sockaddr_in6</c>
            structure would be cast to a pointer to <c>SOCKADDR</c> when passed as a parameter. The SocketAddressList parameter can contain
            pointers to a mixture of IPv4 and IPv6 addresses. So some <c>SOCKET_ADDRESS</c> pointers can be to <c>sockaddr_in</c> structures
            and others can be to <c>sockaddr_in6</c> structures. If it is expected that IPv6 addresses can be used, then the RemoteAddress
            and LocalAddress parameters should point to <c>sockaddr_in6</c> structures and be cast to <c>SOCKADDR</c> structures. The
            RemoteAddressLength and the LocalAddressLength parameters must represent the length of these larger structures.
            </para>
            <para>
            When the WSAConnectByList function returns <c>TRUE</c>, the socket s is in the default state for a connected socket. The socket
            s does not enable previously set properties or options until SO_UPDATE_CONNECT_CONTEXT is set on the socket. Use the setsockopt
            function to set the SO_UPDATE_CONNECT_CONTEXT option.
            </para>
            <para>For example:</para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as WSAConnectByList with the timeout parameter set to <c>NULL</c>, Winsock
            may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which
            can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call
            inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must
            never be attempted by Winsock clients.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            <para>Examples</para>
            <para>Establish a connection using <c>WSAConnectByList</c>.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAConnectByName(Vanara.PInvoke.Ws2_32.SOCKET,System.String,System.String,System.UInt32@,Vanara.PInvoke.Ws2_32.SOCKADDR,System.UInt32@,Vanara.PInvoke.Ws2_32.SOCKADDR,System.IntPtr,System.IntPtr)">
            <summary>
            <para>
            The <c>WSAConnectByName</c> function establishes a connection to a specified host and port. This function is provided to allow a
            quick connection to a network endpoint given a host name and port.
            </para>
            <para>This function supports both IPv4 and IPv6 addresses.</para>
            </summary>
            <param name="s">
            <para>A descriptor that identifies an unconnected socket.</para>
            <para>
            <c>Note</c> On Windows 7, Windows Server 2008 R2, and earlier, the <c>WSAConnectByName</c> function requires an unbound and
            unconnected socket. This differs from other Winsock calls to establish a connection (for example, WSAConnect).
            </para>
            </param>
            <param name="nodename">
            A <c>NULL</c>-terminated string that contains the name of the host or the IP address of the host on which to connect for IPv4 or IPv6.
            </param>
            <param name="servicename">
            <para>
            A <c>NULL</c>-terminated string that contains the service name or destination port of the host on which to connect for IPv4 or IPv6.
            </para>
            <para>
            A service name is a string alias for a port number. For example, http is an alias for port 80 defined by the Internet
            Engineering Task Force (IETF) as the default port used by web servers for the HTTP protocol. Possible values for the servicename
            parameter when a port number is not specified are listed in the following file:
            </para>
            <para>%WINDIR%\system32\drivers\etc\services</para>
            </param>
            <param name="LocalAddressLength">
            On input, a pointer to the size, in bytes, of the LocalAddress buffer provided by the caller. On output, a pointer to the size,
            in bytes, of the <c>SOCKADDR</c> for the local address stored in the LocalAddress buffer filled in by the system upon successful
            completion of the call.
            </param>
            <param name="LocalAddress">
            A pointer to the <c>SOCKADDR</c> structure that receives the local address of the connection. The size of the parameter is
            exactly the size returned in LocalAddressLength. This is the same information that would be returned by the getsockname
            function. This parameter can be <c>NULL</c>, in which case, the LocalAddressLength parameter is ignored.
            </param>
            <param name="RemoteAddressLength">
            On input, a pointer to the size, in bytes, of the RemoteAddress buffer provided by the caller. On output, a pointer to the size,
            in bytes, of the <c>SOCKADDR</c> for the remote address stored in RemoteAddress buffer filled-in by the system upon successful
            completion of the call.
            </param>
            <param name="RemoteAddress">
            A pointer to the <c>SOCKADDR</c> structure that receives the remote address of the connection. This is the same information that
            would be returned by the <c>getpeername</c> function. This parameter can be <c>NULL</c>, in which case, the RemoteAddressLength
            is ignored.
            </param>
            <param name="timeout">The time, in milliseconds, to wait for a response from the remote application before aborting the call.</param>
            <param name="Reserved">Reserved for future implementation. This parameter must be set to <c>NULL</c>.</param>
            <returns>
            <para>
            If a connection is established, <c>WSAConnectByName</c> returns <c>TRUE</c> and LocalAddress and RemoteAddress parameters are
            filled in if these buffers were supplied by the caller.
            </para>
            <para>If the call fails, <c>FALSE</c> is returned. WSAGetLastError can then be called to get extended error information.</para>
            <list type="table">
            <listheader>
            <term>Return code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>WSAEHOSTUNREACH</term>
            <term>The host passed as the nodename parameter was unreachable.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            An invalid parameter was passed to the function. The nodename or the servicename parameter must not be NULL. The Reserved
            parameter must be NULL.
            </term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>Sufficient memory could not be allocated.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>An invalid socket was passed to the function. The s parameter must not be INVALID_SOCKET or NULL.</term>
            </item>
            <item>
            <term>WSAETIMEDOUT</term>
            <term>A response from the remote application was not received before the timeout parameter was exceeded.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>WSAConnectByName</c> is provided to enable quick and transparent connections to remote hosts on specific ports. It is
            compatible with both IPv6 and IPv4 versions.
            </para>
            <para>To enable both IPv6 and IPv4 communications, use the following method:</para>
            <list type="bullet">
            <item>
            <term>
            The setsockopt function must be called on a socket created for the AF_INET6 address family to disable the <c>IPV6_V6ONLY</c>
            socket option before calling <c>WSAConnectByName</c>. This is accomplished by calling the <c>setsockopt</c> function on the
            socket with the level parameter set to <c>IPPROTO_IPV6</c> (see IPPROTO_IPV6 Socket Options), the optname parameter set to
            <c>IPV6_V6ONLY</c>, and the optvalue parameter value set to zero .
            </term>
            </item>
            </list>
            <para>
            <c>WSAConnectByName</c> has limitations: It works only for connection-oriented sockets, such as those of type SOCK_STREAM. The
            function does not support overlapped I/O or non-blocking behavior. <c>WSAConnectByName</c> will block even if the socket is in
            non-blocking mode.
            </para>
            <para>
            <c>WSAConnectByName</c> does not support user-provided data during the establishment of a connection. This call does not support
            FLOWSPEC structures, either. In cases where these features are required, WSAConnect must be used instead.
            </para>
            <para>
            In versions before Windows 10, if an application needs to bind to a specific local address or port, then <c>WSAConnectByName</c>
            cannot be used since the socket parameter to <c>WSAConnectByName</c> must be an unbound socket.
            </para>
            <para>This restriction was removed Windows 10.</para>
            <para>
            The RemoteAddress and the LocalAddress parameters point to a <c>SOCKADDR</c> structure, which is a generic data type. When
            <c>WSAConnectByName</c> is called, it is expected that a socket address type specific to the network protocol or address family
            being used will actually be passed in these parameters. So for IPv4 addresses, a pointer to a <c>sockaddr_in</c> structure would
            be cast to a pointer to <c>SOCKADDR</c> as the RemoteAddress and LocalAddressparameters. For IPv6 addresses, a pointer to a
            <c>sockaddr_in6</c> structure would be cast to a pointer to <c>SOCKADDR</c> as the RemoteAddress and LocalAddressparameters.
            </para>
            <para>
            When the <c>WSAConnectByName</c> function returns <c>TRUE</c>, the socket s is in the default state for a connected socket. The
            socket s does not enable previously set properties or options until SO_UPDATE_CONNECT_CONTEXT is set on the socket. Use the
            setsockopt function to set the SO_UPDATE_CONNECT_CONTEXT option.
            </para>
            <para>For example:</para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>WSAConnectByName</c> with the timeout parameter set to <c>NULL</c>,
            Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation,
            which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock
            call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and
            must never be attempted by Winsock clients.
            </para>
            <para>
            <c>Windows Phone 8:</c> The <c>WSAConnectByNameW</c> function is supported for Windows Phone Store apps on Windows Phone 8 and later.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>WSAConnectByNameW</c> function is supported for Windows Store apps
            on Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            <para>Examples</para>
            <para>Establish a connection using <c>WSAConnectByName</c>.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSACreateEvent">
            <summary>The <c>WSACreateEvent</c> function creates a new event object.</summary>
            <returns>
            <para>
            If no error occurs, <c>WSACreateEvent</c> returns the handle of the event object. Otherwise, the return value is
            WSA_INVALID_EVENT. To get extended error information, call WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>Not enough free memory available to create the event object.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSACreateEvent</c> function creates a manual-reset event object with an initial state of nonsignaled. The handle of the
            event object returned cannot be inherited by child processes. The event object is unnamed.
            </para>
            <para>
            The WSASetEvent function can be called to set the state of the event object to signaled. The WSAResetEvent function can be
            called to set the state of the event object to nonsignaled. When an event object is no longer needed, the WSACloseEvent function
            should be called to free the resources associated with the event object.
            </para>
            <para>
            Windows Sockets 2 event objects are system objects in Windows environments. Therefore, if a Windows application wants to use an
            auto-reset event rather than a manual-reset event, the application can call the CreateEvent function directly. The scope of an
            event object is limited to the process in which it is created.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSADuplicateSocket(Vanara.PInvoke.Ws2_32.SOCKET,System.UInt32,Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO@)">
            <summary>
            The <c>WSADuplicateSocket</c> function returns a WSAPROTOCOL_INFO structure that can be used to create a new socket descriptor
            for a shared socket. The <c>WSADuplicateSocket</c> function cannot be used on a QOS-enabled socket.
            </summary>
            <param name="s">Descriptor identifying the local socket.</param>
            <param name="dwProcessId">Process identifier of the target process in which the duplicated socket will be used.</param>
            <param name="lpProtocolInfo">
            Pointer to a buffer, allocated by the client, that is large enough to contain a WSAPROTOCOL_INFO structure. The service provider
            copies the protocol information structure contents to this buffer.
            </param>
            <returns>
            <para>
            If no error occurs, <c>WSADuplicateSocket</c> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error
            code can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>Indicates that one of the specified parameters was invalid.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEMFILE</term>
            <term>No more socket descriptors are available.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>No buffer space is available. The socket cannot be created.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The lpProtocolInfo parameter is not a valid part of the user address space.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSADuplicateSocket</c> function is used to enable socket sharing between processes. A source process calls
            <c>WSADuplicateSocket</c> to obtain a special WSAPROTOCOL_INFO structure. It uses some interprocess communications (IPC)
            mechanism to pass the contents of this structure to a target process, which in turn uses it in a call to WSASocket to obtain a
            descriptor for the duplicated socket. The special <c>WSAPROTOCOL_INFO</c> structure can only be used once by the target process.
            </para>
            <para>
            Sockets can be shared among threads in a given process without using the <c>WSADuplicateSocket</c> function because a socket
            descriptor is valid in all threads of a process.
            </para>
            <para>One possible scenario for establishing and handing off a shared socket is illustrated in the following table.</para>
            <list type="table">
            <listheader>
            <term>Source process</term>
            <term>IPC</term>
            <term>Destination process</term>
            </listheader>
            <item>
            <term>1) WSASocket, WSAConnect</term>
            <term/>
            <term/>
            </item>
            <item>
            <term>2) Request target process identifier</term>
            <term>==&gt;</term>
            <term/>
            </item>
            <item>
            <term/>
            <term/>
            <term>3) Receive process identifier request and respond</term>
            </item>
            <item>
            <term>4) Receive process identifier</term>
            <term>&lt;==</term>
            <term/>
            </item>
            <item>
            <term>5) Call WSADuplicateSocket to get a special WSAPROTOCOL_INFO structure</term>
            <term/>
            <term/>
            </item>
            <item>
            <term>6) Send WSAPROTOCOL_INFO structure to target</term>
            <term/>
            <term/>
            </item>
            <item>
            <term/>
            <term>==&gt;</term>
            <term>7) Receive WSAPROTOCOL_INFO structure</term>
            </item>
            <item>
            <term/>
            <term/>
            <term>8) Call WSASocket to create shared socket descriptor.</term>
            </item>
            <item>
            <term/>
            <term/>
            <term>9) Use shared socket for data exchange</term>
            </item>
            <item>
            <term>10) closesocket</term>
            <term>&lt;==</term>
            <term/>
            </item>
            </list>
            <para>
            The descriptors that reference a shared socket can be used independently for I/O. However, the Windows Sockets interface does
            not implement any type of access control, so it is up to the processes involved to coordinate their operations on a shared
            socket. Shared sockets are typically used to having one process that is responsible for creating sockets and establishing
            connections, and other processes that are responsible for information exchange.
            </para>
            <para>
            All of the state information associated with a socket is held in common across all the descriptors because the socket
            descriptors are duplicated and not the actual socket. For example, a setsockopt operation performed using one descriptor is
            subsequently visible using a getsockopt from any or all descriptors. Both the source process and the destination process should
            pass the same flags to their respective WSASocket function calls. If the source process uses the socket function to create the
            socket, the destination process must pass the <c>WSA_FLAG_OVERLAPPED</c> flag to its <c>WSASocket</c> function call. A process
            can call closesocket on a duplicated socket and the descriptor will become deallocated. The underlying socket, however, will
            remain open until <c>closesocket</c> is called by the last remaining descriptor.
            </para>
            <para>
            Notification on shared sockets is subject to the usual constraints of WSAAsyncSelect and WSAEventSelect. Issuing either of these
            calls using any of the shared descriptors cancels any previous event registration for the socket, regardless of which descriptor
            was used to make that registration. Thus, a shared socket cannot deliver FD_READ events to process A and FD_WRITE events to
            process B. For situations when such tight coordination is required, developers would be advised to use threads instead of
            separate processes.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>WSADuplicateSocketW</c> function is supported for Windows Store
            apps on Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAEnumNameSpaceProviders(System.UInt32@,System.IntPtr)">
            <summary>The <c>WSAEnumNameSpaceProviders</c> function retrieves information on available namespace providers.</summary>
            <param name="lpdwBufferLength">
            On input, the number of bytes contained in the buffer pointed to by lpnspBuffer. On output (if the function fails, and the error
            is WSAEFAULT), the minimum number of bytes to pass for the lpnspBuffer to retrieve all the requested information. The buffer
            passed to <c>WSAEnumNameSpaceProviders</c> must be sufficient to hold all of the namespace information.
            </param>
            <param name="lpnspBuffer">
            A buffer that is filled with WSANAMESPACE_INFO structures. The returned structures are located consecutively at the head of the
            buffer. Variable sized information referenced by pointers in the structures point to locations within the buffer located between
            the end of the fixed sized structures and the end of the buffer. The number of structures filled in is the return value of <c>WSAEnumNameSpaceProviders</c>.
            </param>
            <returns>
            <para>
            The <c>WSAEnumNameSpaceProviders</c> function returns the number of WSANAMESPACE_INFO structures copied into lpnspBuffer.
            Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The lpnspBuffer parameter was a NULL pointer or the buffer length, lpdwBufferLength, was too small to receive all the relevant
            WSANAMESPACE_INFO structures and associated information. When this error is returned, the buffer length required is returned in
            the lpdwBufferLength parameter.
            </term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>
            The WS2_32.DLL has not been initialized. The application must first call WSAStartup before calling any Windows Sockets functions.
            </term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There was insufficient memory to perform the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAEnumNameSpaceProviders</c> function returns information on available namespace providers in the buffer pointed to by
            the lpnspBuffer parameter. The returned buffer contains an array of WSANAMESPACE_INFO structures located consecutively at the
            head of the buffer. Variable sized information referenced by pointers in the <c>WSANAMESPACE_INFO</c> structures point to
            locations within the buffer located between the end of the fixed <c>WSANAMESPACE_INFO</c> structures and the end of the buffer.
            The number of <c>WSANAMESPACE_INFO</c> structures filled in is returned by the <c>WSAEnumNameSpaceProviders</c> function.
            </para>
            <para>
            Each WSANAMESPACE_INFO structure entry contains the provider-specific information on the namespace entry passed to the
            WSCInstallNameSpace and WSCInstallNameSpace32 functions when the namespace provider was installed.
            </para>
            <para>
            The WSAEnumNameSpaceProvidersEx function is an enhanced version of the <c>WSAEnumNameSpaceProviders</c> function. The
            WSCEnumNameSpaceProvidersEx32 function is an enhanced version of the <c>WSAEnumNameSpaceProviders</c> function that returns
            information on available 32-bit namespace providers for use on 64-bit platforms.
            </para>
            <para>Example Code</para>
            <para>
            The following example demonstrates the use of the <c>WSAEnumNameSpaceProviders</c> function to retrieve information on available
            namespace providers.
            </para>
            <para>
            <c>Windows Phone 8:</c> The <c>WSAEnumNameSpaceProvidersW</c> function is supported for Windows Phone Store apps on Windows
            Phone 8 and later.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>WSAEnumNameSpaceProvidersW</c> function is supported for Windows
            Store apps on Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAEnumNameSpaceProvidersEx(System.UInt32@,System.IntPtr)">
            <summary>The <c>WSAEnumNameSpaceProvidersEx</c> function retrieves information on available namespace providers.</summary>
            <param name="lpdwBufferLength">
            On input, the number of bytes contained in the buffer pointed to by lpnspBuffer. On output (if the function fails, and the error
            is WSAEFAULT), the minimum number of bytes to allocate for the lpnspBuffer buffer to allow it to retrieve all the requested
            information. The buffer passed to <c>WSAEnumNameSpaceProvidersEx</c> must be sufficient to hold all of the namespace information.
            </param>
            <param name="lpnspBuffer">
            A buffer that is filled with WSANAMESPACE_INFOEX structures. The returned structures are located consecutively at the head of
            the buffer. Variable sized information referenced by pointers in the structures point to locations within the buffer located
            between the end of the fixed sized structures and the end of the buffer. The number of structures filled in is the return value
            of <c>WSAEnumNameSpaceProvidersEx</c>.
            </param>
            <returns>
            <para>
            The <c>WSAEnumNameSpaceProvidersEx</c> function returns the number of WSANAMESPACE_INFOEX structures copied into lpnspBuffer.
            Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The lpnspBuffer parameter was a NULL pointer or the buffer length, lpdwBufferLength, was too small to receive all the relevant
            WSANAMESPACE_INFOEX structures and associated information. When this error is returned, the buffer length required is returned
            in the lpdwBufferLength parameter.
            </term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>
            The WS2_32.DLL has not been initialized. The application must first call WSAStartup before calling any Windows Sockets functions.
            </term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There was insufficient memory to perform the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAEnumNameSpaceProvidersEx</c> function is an enhanced version of the WSAEnumNameSpaceProviders function. The
            provider-specific data blob associated with the namespace entry passed in the lpProviderInfo parameter to the
            WSCInstallNameSpaceEx function can be queried using <c>WSAEnumNameSpaceProvidersEx</c> function.
            </para>
            <para>
            Currently, the only namespace provider included with Windows that sets information in the <c>ProviderSpecific</c> member of the
            WSANAMESPACE_INFOEX structure is the NS_EMAIL provider. The format of the <c>ProviderSpecific</c> member for an NS_EMAIL
            namespace provider is a NAPI_PROVIDER_INSTALLATION_BLOB structure.
            </para>
            <para>
            When UNICODE or _UNICODE is defined, <c>WSAEnumNameSpaceProvidersEx</c> is defined to <c>WSAEnumNameSpaceProvidersExW</c>, the
            Unicode version of this function. The lpnspBuffer parameter is defined to the LPSAWSANAMESPACE_INFOEXW data type and
            <c>WSANAMESPACE_INFOEXW</c> structures are returned on success.
            </para>
            <para>
            When UNICODE or _UNICODE is not defined, <c>WSAEnumNameSpaceProvidersEx</c> is defined to <c>WSAEnumNameSpaceProvidersExA</c>,
            the ANSI version of this function. The lpnspBuffer parameter is defined to the LPSAWSANAMESPACE_INFOEXA data type and
            <c>WSANAMESPACE_INFOEXA</c> structures are returned on success.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>WSAEnumNameSpaceProvidersExW</c> function is supported for Windows
            Store apps on Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAEnumNetworkEvents(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.WSAEVENT,Vanara.PInvoke.Ws2_32.WSANETWORKEVENTS@)">
            <summary>
            The <c>WSAEnumNetworkEvents</c> function discovers occurrences of network events for the indicated socket, clear internal
            network event records, and reset event objects (optional).
            </summary>
            <param name="s">A descriptor identifying the socket.</param>
            <param name="hEventObject">An optional handle identifying an associated event object to be reset.</param>
            <param name="lpNetworkEvents">
            A pointer to a WSANETWORKEVENTS structure that is filled with a record of network events that occurred and any associated error codes.
            </param>
            <returns>
            <para>
            The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error
            number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One of the specified parameters was invalid.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The lpNetworkEvents parameter is not a valid part of the user address space.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAEnumNetworkEvents</c> function is used to discover which network events have occurred for the indicated socket since
            the last invocation of this function. It is intended for use in conjunction with WSAEventSelect, which associates an event
            object with one or more network events. The recording of network events commences when <c>WSAEventSelect</c> is called with a
            nonzero lNetworkEvents parameter and remains in effect until another call is made to <c>WSAEventSelect</c> with the
            lNetworkEvents parameter set to zero, or until a call is made to WSAAsyncSelect.
            </para>
            <para>
            <c>WSAEnumNetworkEvents</c> only reports network activity and errors nominated through WSAEventSelect. See the descriptions of
            select and WSAAsyncSelect to find out how those functions report network activity and errors.
            </para>
            <para>
            The socket's internal record of network events is copied to the structure referenced by lpNetworkEvents, after which the
            internal network events record is cleared. If the hEventObject parameter is not <c>NULL</c>, the indicated event object is also
            reset. The Windows Sockets provider guarantees that the operations of copying the network event record, clearing it and
            resetting any associated event object are atomic, such that the next occurrence of a nominated network event will cause the
            event object to become set. In the case of this function returning SOCKET_ERROR, the associated event object is not reset and
            the record of network events is not cleared.
            </para>
            <para>
            The <c>lNetworkEvents</c> member of the WSANETWORKEVENTS structure indicates which of the FD_XXX network events have occurred.
            The <c>iErrorCode</c> array is used to contain any associated error codes with the array index corresponding to the position of
            event bits in <c>lNetworkEvents</c>. Identifiers such as FD_READ_BIT and FD_WRITE_BIT can be used to index the <c>iErrorCode</c>
            array. Note that only those elements of the <c>iErrorCode</c> array are set that correspond to the bits set in lNetworkEvents
            parameter. Other parameters are not modified (this is important for backward compatibility with the applications that are not
            aware of new FD_ROUTING_INTERFACE_CHANGE and FD_ADDRESS_LIST_CHANGE events).
            </para>
            <para>The following error codes can be returned along with the corresponding network event.</para>
            <para><c>Event: FD_CONNECT</c></para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEAFNOSUPPORT</term>
            <term>Addresses in the specified family cannot be used with this socket.</term>
            </item>
            <item>
            <term>WSAECONNREFUSED</term>
            <term>The attempt to connect was forcefully rejected.</term>
            </item>
            <item>
            <term>WSAENETUNREACH</term>
            <term>The network cannot be reached from this host at this time.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>No buffer space is available. The socket cannot be connected.</term>
            </item>
            <item>
            <term>WSAETIMEDOUT</term>
            <term>An attempt to connect timed out without establishing a connection</term>
            </item>
            </list>
            <para><c>Event: FD_CLOSE</c></para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAECONNRESET</term>
            <term>The connection was reset by the remote side.</term>
            </item>
            <item>
            <term>WSAECONNABORTED</term>
            <term>The connection was terminated due to a time-out or other failure.</term>
            </item>
            </list>
            <para><c>Event: FD_ACCEPT</c></para>
            <para><c>Event: FD_ADDRESS_LIST_CHANGE</c></para>
            <para><c>Event: FD_GROUP_QOS</c></para>
            <para><c>Event: FD_QOS</c></para>
            <para><c>Event: FD_OOB</c></para>
            <para><c>Event: FD_READ</c></para>
            <para><c>Event: FD_WRITE</c></para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            </list>
            <para><c>Event: FD_ROUTING_INTERFACE_CHANGE</c></para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAENETUNREACH</term>
            <term>The specified destination is no longer reachable.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            </list>
            <para>Example Code</para>
            <para>The following example demonstrates the use of the WSAEnumNetworkEvents function.</para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAEnumProtocols(System.Int32[],System.IntPtr,System.UInt32@)">
            <summary>The <c>WSAEnumProtocols</c> function retrieves information about available transport protocols.</summary>
            <param name="lpiProtocols">
            A <c>NULLl</c>-terminated array of iProtocol values. This parameter is optional; if lpiProtocols is <c>NULL</c>, information on
            all available protocols is returned. Otherwise, information is retrieved only for those protocols listed in the array.
            </param>
            <param name="lpProtocolBuffer">A pointer to a buffer that is filled with WSAPROTOCOL_INFO structures.</param>
            <param name="lpdwBufferLength">
            On input, number of bytes in the lpProtocolBuffer buffer passed to <c>WSAEnumProtocols</c>. On output, the minimum buffer size
            that can be passed to <c>WSAEnumProtocols</c> to retrieve all the requested information. This routine has no ability to
            enumerate over multiple calls; the passed-in buffer must be large enough to hold all entries in order for the routine to
            succeed. This reduces the complexity of the API and should not pose a problem because the number of protocols loaded on a
            computer is typically small.
            </param>
            <returns>
            <para>
            If no error occurs, <c>WSAEnumProtocols</c> returns the number of protocols to be reported. Otherwise, a value of SOCKET_ERROR
            is returned and a specific error code can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>Indicates that one of the specified parameters was invalid.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>
            The buffer length was too small to receive all the relevant WSAPROTOCOL_INFO structures and associated information. Pass in a
            buffer at least as large as the value returned in lpdwBufferLength.
            </term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            One or more of the lpiProtocols, lpProtocolBuffer, or lpdwBufferLength parameters are not a valid part of the user address space.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAEnumProtocols</c> function is used to discover information about the collection of transport protocols installed on
            the local computer. Layered protocols are only usable by applications when installed in protocol chains. Information on layered
            protocols is not returned except for any dummy layered service providers (LSPs) installed with a chain length of zero in the lpProtocolBuffer.
            </para>
            <para>
            <c>Note</c> Layered Service Providers are deprecated. Starting with Windows 8 and Windows Server 2012, use Windows Filtering Platform.
            </para>
            <para>
            The lpiProtocols parameter can be used as a filter to constrain the amount of information provided. Often, lpiProtocols will be
            specified as a <c>NULL</c> pointer that will cause the function to return information on all available transport protocols and
            protocol chains.
            </para>
            <para>
            The <c>WSAEnumProtocols</c> function differs from the WSCEnumProtocols and WSCEnumProtocols32 functions in that the
            <c>WSAEnumProtocols</c> function doesn't return WSAPROTOCOL_INFO structures for all installed protocols. The
            <c>WSAEnumProtocols</c> function excludes protocols that the service provider has set with the <c>PFL_HIDDEN</c> flag in the
            <c>dwProviderFlags</c> member of the WSAPROTOCOL_INFO structure to indicate to the Ws2_32.dll that this protocol should not be
            returned in the result buffer generated by <c>WSAEnumProtocols</c> function. In addition, the <c>WSAEnumProtocols</c> function
            does not return data for WSAPROTOCOL_INFO structures that have a chain length of one or greater (an LSP provider). The
            <c>WSAEnumProtocols</c> only returns information on base protocols and protocol chains that lack the <c>PFL_HIDDEN</c> flag and
            don't have a protocol chain length of zero.
            </para>
            <para>
            A WSAPROTOCOL_INFO structure is provided in the buffer pointed to by lpProtocolBuffer for each requested protocol. If the
            specified buffer is not large enough (as indicated by the input value of lpdwBufferLength ), the value pointed to by
            lpdwBufferLength will be updated to indicate the required buffer size. The application should then obtain a large enough buffer
            and call <c>WSAEnumProtocols</c> again.
            </para>
            <para>
            The order in which the WSAPROTOCOL_INFO structures appear in the buffer coincides with the order in which the protocol entries
            were registered by the service provider using the WS2_32.DLL, or with any subsequent reordering that occurred through the
            Windows Sockets application or DLL supplied for establishing default TCP/IP providers.
            </para>
            <para>
            <c>Windows Phone 8:</c> The <c>WSAEnumProtocolsW</c> function is supported for Windows Phone Store apps on Windows Phone 8 and later.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>WSAEnumProtocolsW</c> function is supported for Windows Store apps
            on Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            <para>Examples</para>
            <para>
            The following example demonstrates the use of the <c>WSAEnumProtocols</c> function to retrieve an array of WSAPROTOCOL_INFO
            structures for available transport protocols.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAEventSelect(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.WSAEVENT,Vanara.PInvoke.Ws2_32.FD)">
            <summary>
            The <c>WSAEventSelect</c> function specifies an event object to be associated with the specified set of FD_XXX network events.
            </summary>
            <param name="s">A descriptor identifying the socket.</param>
            <param name="hEventObject">
            A handle identifying the event object to be associated with the specified set of FD_XXX network events.
            </param>
            <param name="lNetworkEvents">
            A bitmask that specifies the combination of FD_XXX network events in which the application has interest.
            </param>
            <returns>
            <para>
            The return value is zero if the application's specification of the network events and the associated event object was
            successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.
            </para>
            <para>
            As in the case of the select and WSAAsyncSelect functions, <c>WSAEventSelect</c> will frequently be used to determine when a
            data transfer operation (send or recv) can be issued with the expectation of immediate success. Nevertheless, a robust
            application must be prepared for the possibility that the event object is set and it issues a Windows Sockets call that returns
            WSAEWOULDBLOCK immediately. For example, the following sequence of operations is possible:
            </para>
            <list type="bullet">
            <item>
            <term>Data arrives on socket s; Windows Sockets sets the <c>WSAEventSelect</c> event object.</term>
            </item>
            <item>
            <term>The application does some other processing.</term>
            </item>
            <item>
            <term>While processing, the application issues an ioctlsocket(s, FIONREAD...) and notices that there is data ready to be read.</term>
            </item>
            <item>
            <term>The application issues a recv(s,...) to read the data.</term>
            </item>
            <item>
            <term>
            The application eventually waits on the event object specified in <c>WSAEventSelect</c>, which returns immediately indicating
            that data is ready to read.
            </term>
            </item>
            <item>
            <term>The application issues recv(s,...), which fails with the error WSAEWOULDBLOCK.</term>
            </item>
            </list>
            <para>
            Having successfully recorded the occurrence of the network event (by setting the corresponding bit in the internal network event
            record) and signaled the associated event object, no further actions are taken for that network event until the application
            makes the function call that implicitly reenables the setting of that network event and signaling of the associated event object.
            </para>
            <list type="table">
            <listheader>
            <term>Network event</term>
            <term>Re-enabling function</term>
            </listheader>
            <item>
            <term>FD_READ</term>
            <term>The recv, recvfrom, WSARecv, WSARecvEx, or WSARecvFrom function.</term>
            </item>
            <item>
            <term>FD_WRITE</term>
            <term>The send, sendto, WSASend, or WSASendTo function.</term>
            </item>
            <item>
            <term>FD_OOB</term>
            <term>The recv, recvfrom, WSARecv, WSARecvEx, or WSARecvFrom function.</term>
            </item>
            <item>
            <term>FD_ACCEPT</term>
            <term>
            The accept, AcceptEx, or WSAAccept function unless the error code returned is WSATRY_AGAIN indicating that the condition
            function returned CF_DEFER.
            </term>
            </item>
            <item>
            <term>FD_CONNECT</term>
            <term>None.</term>
            </item>
            <item>
            <term>FD_CLOSE</term>
            <term>None.</term>
            </item>
            <item>
            <term>FD_QOS</term>
            <term>The WSAIoctl function with command SIO_GET_QOS.</term>
            </item>
            <item>
            <term>FD_GROUP_QOS</term>
            <term>Reserved.</term>
            </item>
            <item>
            <term>FD_ROUTING_ INTERFACE_CHANGE</term>
            <term>The WSAIoctl function with command SIO_ROUTING_INTERFACE_CHANGE.</term>
            </item>
            <item>
            <term>FD_ADDRESS_ LIST_CHANGE</term>
            <term>The WSAIoctl function with command SIO_ADDRESS_LIST_CHANGE.</term>
            </item>
            </list>
            <para>
            Any call to the reenabling routine, even one that fails, results in reenabling of recording and signaling for the relevant
            network event and event object.
            </para>
            <para>
            For FD_READ, FD_OOB, and FD_ACCEPT network events, network event recording and event object signaling are level-triggered. This
            means that if the reenabling routine is called and the relevant network condition is still valid after the call, the network
            event is recorded and the associated event object is set. This allows an application to be event-driven and not be concerned
            with the amount of data that arrives at any one time. Consider the following sequence:
            </para>
            <list type="number">
            <item>
            <term>
            The transport provider receives 100 bytes of data on socket s and causes WS2_32.DLL to record the FD_READ network event and set
            the associated event object.
            </term>
            </item>
            <item>
            <term>The application issues recv(s, buffptr, 50, 0) to read 50 bytes.</term>
            </item>
            <item>
            <term>
            The transport provider causes WS2_32.DLL to record the FD_READ network event and sets the associated event object again since
            there is still data to be read.
            </term>
            </item>
            </list>
            <para>
            With these semantics, an application need not read all available data in response to an FD_READ network eventa single recv in
            response to each FD_READ network event is appropriate.
            </para>
            <para>
            The FD_QOS event is considered edge triggered. A message will be posted exactly once when a quality of service change occurs.
            Further messages will not be forthcoming until either the provider detects a further change in quality of service or the
            application renegotiates the quality of service for the socket.
            </para>
            <para>
            The FD_ROUTING_INTERFACE_CHANGE and FD_ADDRESS_LIST_CHANGE events are considered edge triggered as well. A message will be
            posted exactly once when a change occurs after the application has requested the notification by issuing WSAIoctl with
            <c>SIO_ROUTING_INTERFACE_CHANGE</c> or <c>SIO_ADDRESS_LIST_CHANGE</c> correspondingly. Other messages will not be forthcoming
            until the application reissues the IOCTL and another change is detected since the IOCTL has been issued.
            </para>
            <para>
            If a network event has already happened when the application calls <c>WSAEventSelect</c> or when the reenabling function is
            called, then a network event is recorded and the associated event object is set as appropriate. For example, consider the
            following sequence:
            </para>
            <list type="number">
            <item>
            <term>An application calls listen.</term>
            </item>
            <item>
            <term>A connect request is received but not yet accepted.</term>
            </item>
            <item>
            <term>
            The application calls <c>WSAEventSelect</c> specifying that it is interested in the FD_ACCEPT network event for the socket. Due
            to the persistence of network events, Windows Sockets records the FD_ACCEPT network event and sets the associated event object immediately.
            </term>
            </item>
            </list>
            <para>
            The FD_WRITE network event is handled slightly differently. An FD_WRITE network event is recorded when a socket is first
            connected with a call to the connect, ConnectEx, WSAConnect, WSAConnectByList, or WSAConnectByName function or when a socket is
            accepted with accept, AcceptEx, or WSAAccept function and then after a send fails with WSAEWOULDBLOCK and buffer space becomes
            available. Therefore, an application can assume that sends are possible starting from the first FD_WRITE network event setting
            and lasting until a send returns WSAEWOULDBLOCK. After such a failure the application will find out that sends are again
            possible when an FD_WRITE network event is recorded and the associated event object is set.
            </para>
            <para>
            The FD_OOB network event is used only when a socket is configured to receive OOB data separately. If the socket is configured to
            receive OOB data inline, the OOB (expedited) data is treated as normal data and the application should register an interest in,
            and will get FD_READ network event, not FD_OOB network event. An application can set or inspect the way in which OOB data is to
            be handled by using setsockopt or getsockopt for the SO_OOBINLINE option.
            </para>
            <para>
            The error code in an FD_CLOSE network event indicates whether the socket close was graceful or abortive. If the error code is
            zero, then the close was graceful; if the error code is WSAECONNRESET, then the socket's virtual circuit was reset. This only
            applies to connection-oriented sockets such as SOCK_STREAM.
            </para>
            <para>
            The FD_CLOSE network event is recorded when a close indication is received for the virtual circuit corresponding to the socket.
            In TCP terms, this means that the FD_CLOSE is recorded when the connection goes into the TIME WAIT or CLOSE WAIT states. This
            results from the remote end performing a shutdown on the send side or a closesocket. FD_CLOSE being posted after all data is
            read from a socket. An application should check for remaining data upon receipt of FD_CLOSE to avoid any possibility of losing
            data. For more information, see the section on Graceful Shutdown, Linger Options, and Socket Closure and the <c>shutdown</c> function.
            </para>
            <para>
            Note that Windows Sockets will record only an FD_CLOSE network event to indicate closure of a virtual circuit. It will not
            record an FD_READ network event to indicate this condition.
            </para>
            <para>
            The FD_QOS or FD_GROUP_QOS network event is recorded when any parameter in the flow specification associated with socket s.
            Applications should use WSAIoctl with command <c>SIO_GET_QOS</c> to get the current quality of service for socket s.
            </para>
            <para>
            The FD_ROUTING_INTERFACE_CHANGE network event is recorded when the local interface that should be used to reach the destination
            specified in WSAIoctl with <c>SIO_ROUTING_INTERFACE_CHANGE</c> changes after such IOCTL has been issued.
            </para>
            <para>
            The FD_ADDRESS_LIST_CHANGE network event is recorded when the list of addresses of protocol family for the socket to which the
            application can bind changes after WSAIoctl with <c>SIO_ADDRESS_LIST_CHANGE</c> has been issued.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One of the specified parameters was invalid, or the specified socket is in an invalid state.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAEventSelect</c> function is used to specify an event object, hEventObject, to be associated with the selected FD_XXX
            network events, lNetworkEvents. The socket for which an event object is specified is identified by the s parameter. The event
            object is set when any of the nominated network events occur.
            </para>
            <para>
            The <c>WSAEventSelect</c> function operates very similarly to WSAAsyncSelect, the difference being the actions taken when a
            nominated network event occurs. The <c>WSAAsyncSelect</c> function causes an application-specified Windows message to be posted.
            The <c>WSAEventSelect</c> sets the associated event object and records the occurrence of this event in an internal network event
            record. An application can use WSAWaitForMultipleEvents to wait or poll on the event object, and use WSAEnumNetworkEvents to
            retrieve the contents of the internal network event record and thus determine which of the nominated network events have occurred.
            </para>
            <para>
            The proper way to reset the state of an event object used with the <c>WSAEventSelect</c> function is to pass the handle of the
            event object to the WSAEnumNetworkEvents function in the hEventObject parameter. This will reset the event object and adjust the
            status of active FD events on the socket in an atomic fashion.
            </para>
            <para>
            <c>WSAEventSelect</c> is the only function that causes network activity and errors to be recorded and retrievable through
            WSAEnumNetworkEvents. See the descriptions of select and WSAAsyncSelect to find out how those functions report network activity
            and errors.
            </para>
            <para>
            The <c>WSAEventSelect</c> function automatically sets socket s to nonblocking mode, regardless of the value of lNetworkEvents.
            To set socket s back to blocking mode, it is first necessary to clear the event record associated with socket s via a call to
            <c>WSAEventSelect</c> with lNetworkEvents set to zero and the hEventObject parameter set to <c>NULL</c>. You can then call
            ioctlsocket or WSAIoctl to set the socket back to blocking mode.
            </para>
            <para>
            The lNetworkEvents parameter is constructed by using the bitwise OR operator with any of the values specified in the following list.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>FD_READ</term>
            <term>Wants to receive notification of readiness for reading.</term>
            </item>
            <item>
            <term>FD_WRITE</term>
            <term>Wants to receive notification of readiness for writing.</term>
            </item>
            <item>
            <term>FD_OOB</term>
            <term>Wants to receive notification of the arrival of OOB data.</term>
            </item>
            <item>
            <term>FD_ACCEPT</term>
            <term>Wants to receive notification of incoming connections.</term>
            </item>
            <item>
            <term>FD_CONNECT</term>
            <term>Wants to receive notification of completed connection or multipoint join operation.</term>
            </item>
            <item>
            <term>FD_CLOSE</term>
            <term>Wants to receive notification of socket closure.</term>
            </item>
            <item>
            <term>FD_QOS</term>
            <term>Wants to receive notification of socket (QoS changes.</term>
            </item>
            <item>
            <term>FD_GROUP_QOS</term>
            <term>Reserved for future use with socket groups. Want to receive notification of socket group QoS changes.</term>
            </item>
            <item>
            <term>FD_ROUTING_ INTERFACE_CHANGE</term>
            <term>Wants to receive notification of routing interface changes for the specified destination.</term>
            </item>
            <item>
            <term>FD_ADDRESS_ LIST_CHANGE</term>
            <term>Wants to receive notification of local address list changes for the address family of the socket.</term>
            </item>
            </list>
            <para>
            Issuing a <c>WSAEventSelect</c> for a socket cancels any previous WSAAsyncSelect or <c>WSAEventSelect</c> for the same socket
            and clears the internal network event record. For example, to associate an event object with both reading and writing network
            events, the application must call <c>WSAEventSelect</c> with both FD_READ and FD_WRITE, as follows:
            </para>
            <para>
            It is not possible to specify different event objects for different network events. The following code will not work; the second
            call will cancel the effects of the first, and only the FD_WRITE network event will be associated with hEventObject2:
            </para>
            <para>
            To cancel the association and selection of network events on a socket, lNetworkEvents should be set to zero, in which case the
            hEventObject parameter will be ignored.
            </para>
            <para>
            Closing a socket with closesocket also cancels the association and selection of network events specified in
            <c>WSAEventSelect</c> for the socket. The application, however, still must call WSACloseEvent to explicitly close the event
            object and free any resources.
            </para>
            <para>
            The socket created when the accept function is called has the same properties as the listening socket used to accept it. Any
            <c>WSAEventSelect</c> association and network events selection set for the listening socket apply to the accepted socket. For
            example, if a listening socket has <c>WSAEventSelect</c> association of hEventObject with FD_ACCEPT, FD_READ, and FD_WRITE, then
            any socket accepted on that listening socket will also have FD_ACCEPT, FD_READ, and FD_WRITE network events associated with the
            same hEventObject. If a different hEventObject or network events are desired, the application should call <c>WSAEventSelect</c>,
            passing the accepted socket and the desired new information.
            </para>
            <para>Example Code</para>
            <para>The following example demonstrates the use of the <c>WSAEventSelect</c> function.</para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAGetLastError">
            <summary>The <c>WSAGetLastError</c> function returns the error status for the last Windows Sockets operation that failed.</summary>
            <returns>The return value indicates the error code for this thread's last Windows Sockets operation that failed.</returns>
            <remarks>
            <para>
            The <c>WSAGetLastError</c> function returns the last error that occurred for the calling thread. When a particular Windows
            Sockets function indicates an error has occurred, this function should be called immediately to retrieve the extended error code
            for the failing function call. This extended error code can be different from the error code obtained from getsockopt when
            called with an optname parameter of <c>SO_ERROR</c>, which is socket-specific since <c>WSAGetLastError</c> is for all
            thread-specific sockets.
            </para>
            <para>
            If a function call's return value indicates that error or other relevant data was returned in the error code,
            <c>WSAGetLastError</c> should be called immediately. This is necessary because some functions may reset the last extended error
            code to 0 if they succeed, overwriting the extended error code returned by a previously failed function. To specifically reset
            the extended error code, use the WSASetLastError function call with the iError parameter set to zero. A getsockopt function when
            called with an optname parameter of <c>SO_ERROR</c> also resets the extended error code to zero.
            </para>
            <para>
            The <c>WSAGetLastError</c> function should not be used to check for an extended error value on receipt of an asynchronous
            message. In this case, the extended error value is passed in the lParam parameter of the message, and this can differ from the
            value returned by <c>WSAGetLastError</c>.
            </para>
            <para>
            <c>Note</c> An application can call the <c>WSAGetLastError</c> function to determine the extended error code for other Windows
            sockets functions as is normally done in Windows Sockets even if the WSAStartup function fails or the <c>WSAStartup</c> function
            was not called to properly initialize Windows Sockets before calling a Windows Sockets function. The <c>WSAGetLastError</c>
            function is one of the only functions in the Winsock 2.2 DLL that can be called in the case of a <c>WSAStartup</c> failure.
            </para>
            <para>
            The Windows Sockets extended error codes returned by this function and the text description of the error are listed under
            Windows Sockets Error Codes. These error codes and a short text description associated with an error code are defined in the
            Winerror.h header file. The FormatMessage function can be used to obtain the message string for the returned error.
            </para>
            <para>
            For information on how to handle error codes when porting socket applications to Winsock, see Error Codes - errno, h_errno and WSAGetLastError.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAGetOverlappedResult(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.WSAOVERLAPPED@,System.UInt32@,System.Boolean,System.UInt32@)">
            <summary>The <c>WSAGetOverlappedResult</c> function retrieves the results of an overlapped operation on the specified socket.</summary>
            <param name="s">
            <para>A descriptor identifying the socket.</para>
            <para>
            This is the same socket that was specified when the overlapped operation was started by a call to any of the Winsock functions
            that supports overlappped operations. These functions include AcceptEx, ConnectEx, DisconnectEx, TransmitFile, TransmitPackets,
            WSARecv, WSARecvFrom, WSARecvMsg, WSASend, WSASendMsg, WSASendTo, and WSAIoctl.
            </para>
            </param>
            <param name="lpOverlapped">
            A pointer to a WSAOVERLAPPED structure that was specified when the overlapped operation was started. This parameter must not be
            a <c>NULL</c> pointer.
            </param>
            <param name="lpcbTransfer">
            A pointer to a 32-bit variable that receives the number of bytes that were actually transferred by a send or receive operation,
            or by the WSAIoctl function. This parameter must not be a <c>NULL</c> pointer.
            </param>
            <param name="fWait">
            A flag that specifies whether the function should wait for the pending overlapped operation to complete. If <c>TRUE</c>, the
            function does not return until the operation has been completed. If <c>FALSE</c> and the operation is still pending, the
            function returns <c>FALSE</c> and the WSAGetLastError function returns WSA_IO_INCOMPLETE. The fWait parameter may be set to
            <c>TRUE</c> only if the overlapped operation selected the event-based completion notification.
            </param>
            <param name="lpdwFlags">
            A pointer to a 32-bit variable that will receive one or more flags that supplement the completion status. If the overlapped
            operation was initiated through WSARecv or WSARecvFrom, this parameter will contain the results value for lpFlags parameter.
            This parameter must not be a <c>NULL</c> pointer.
            </param>
            <returns>
            <para>
            If <c>WSAGetOverlappedResult</c> succeeds, the return value is <c>TRUE</c>. This means that the overlapped operation has
            completed successfully and that the value pointed to by lpcbTransfer has been updated.
            </para>
            <para>
            If <c>WSAGetOverlappedResult</c> returns <c>FALSE</c>, this means that either the overlapped operation has not completed, the
            overlapped operation completed but with errors, or the overlapped operation's completion status could not be determined due to
            errors in one or more parameters to <c>WSAGetOverlappedResult</c>. On failure, the value pointed to by lpcbTransfer will not be
            updated. Use WSAGetLastError to determine the cause of the failure (either by the <c>WSAGetOverlappedResult</c> function or by
            the associated overlapped operation).
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSA_INVALID_HANDLE</term>
            <term>The hEvent parameter of the WSAOVERLAPPED structure does not contain a valid event object handle.</term>
            </item>
            <item>
            <term>WSA_INVALID_PARAMETER</term>
            <term>One of the parameters is unacceptable.</term>
            </item>
            <item>
            <term>WSA_IO_INCOMPLETE</term>
            <term>The fWait parameter is FALSE and the I/O operation has not yet completed.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            One or more of the lpOverlapped, lpcbTransfer, or lpdwFlags parameters are not in a valid part of the user address space. This
            error is returned if the lpOverlapped, lpcbTransfer, or lpdwFlags parameter was a NULL pointer on Windows Server 2003 and earlier.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAGetOverlappedResult</c> function reports the results of the overlapped operation specified in the lpOverlapped
            parameter for the socket specified in the s parameter. The <c>WSAGetOverlappedResult</c> function is passed the socket
            descriptor and the WSAOVERLAPPED structure that was specified when the overlapped function was called. A pending operation is
            indicated when the function that started the operation returns <c>FALSE</c> and the WSAGetLastError function returns
            WSA_IO_PENDING. When an I/O operation such as WSARecv is pending, the function that started the operation resets the hEvent
            member of the <c>WSAOVERLAPPED</c> structure to the nonsignaled state. Then, when the pending operation has completed, the
            system sets the event object to the signaled state.
            </para>
            <para>
            If the fWait parameter is <c>TRUE</c>, <c>WSAGetOverlappedResult</c> determines whether the pending operation has been completed
            by waiting for the event object to be in the signaled state. A client may set the fWait parameter to <c>TRUE</c>, but only if it
            selected event-based completion notification when the I/O operation was requested. If another form of notification was selected,
            the usage of the hEvent parameter of the WSAOVERLAPPED structure is different, and setting fWait to <c>TRUE</c> causes
            unpredictable results.
            </para>
            <para>
            If the <c>WSAGetOverlappedResult</c> function is called with the lpOverlapped, lpcbTransfer, or lpdwFlags parameter set to a
            <c>NULL</c> pointer on Windows Vista, this will result in an access violation. If the <c>WSAGetOverlappedResult</c> function is
            called with the lpOverlapped, lpcbTransfer, or lpdwFlags parameter set to a <c>NULL</c> pointer on Windows Server 2003 and
            earlier, this will result in the WSAEFAULT error code being returned.
            </para>
            <para>
            <c>Note</c> All I/O is canceled when a thread exits. For overlapped sockets, pending asynchronous operations can fail if the
            thread is closed before the operations complete. See ExitThread for more information.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAGetQOSByName(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.WSABUF@,Vanara.PInvoke.Ws2_32.QOS@)">
            <summary>
            The <c>WSAGetQOSByName</c> function initializes a QOS structure based on a named template, or it supplies a buffer to retrieve
            an enumeration of the available template names.
            </summary>
            <param name="s">A descriptor identifying a socket.</param>
            <param name="lpQOSName">A pointer to a specific quality of service template.</param>
            <param name="lpQOS">A pointer to the QOS structure to be filled.</param>
            <returns>
            <para>
            If <c>WSAGetQOSByName</c> succeeds, the return value is <c>TRUE</c>. If the function fails, the return value is <c>FALSE</c>. To
            get extended error information, call WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The lpQOSName or lpQOS parameter are not a valid part of the user address space, or the buffer length for lpQOS is too small.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAGetQOSByName</c> function is used by applications to initialize a QOS structure to a set of known values appropriate
            for a particular service class or media type. These values are stored in a template that is referenced by a well-known name. The
            client may retrieve these values by setting the buf parameter of the WSABUF structure indicated by lpQOSName, which points to a
            string of nonzero length specifying a template name. In this case, the usage of lpQOSName is IN only, and results are returned
            through lpQOS.
            </para>
            <para>
            Alternatively, the client may use this function to retrieve an enumeration of available template names. The client may do this
            by setting the buf parameter of the WSABUF indicated by lpQOSName to a zero-length null-terminated string. In this case the
            buffer indicated by buf is overwritten with a sequence of as many available, null-terminated template names up to the number of
            bytes available in buf as indicated by the len parameter of the <c>WSABUF</c> indicated by lpQOSName. The list of names itself
            is terminated by a zero-length name. When the <c>WSAGetQOSByName</c> function is used to retrieve template names, the lpQOS
            parameter is ignored.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAGetServiceClassInfo(System.Guid@,System.Guid@,System.UInt32@,System.IntPtr)">
            <summary>
            The <c>WSAGetServiceClassInfo</c> function retrieves the class information (schema) pertaining to a specified service class from
            a specified namespace provider.
            </summary>
            <param name="lpProviderId">A pointer to a GUID that identifies a specific namespace provider.</param>
            <param name="lpServiceClassId">A pointer to a GUID identifying the service class.</param>
            <param name="lpdwBufSize">
            <para>On input, the number of bytes contained in the buffer pointed to by the lpServiceClassInfo parameter.</para>
            <para>
            On output, if the function fails and the error is WSAEFAULT, this parameter specifies the minimum size, in bytes, of the buffer
            pointed to lpServiceClassInfo needed to retrieve the record.
            </para>
            </param>
            <param name="lpServiceClassInfo">
            A pointer to a WSASERVICECLASSINFO structure that contains the service class information from the indicated namespace provider
            for the specified service class.
            </param>
            <returns>
            <para>
            The return value is zero if the <c>WSAGetServiceClassInfo</c> was successful. Otherwise, the value SOCKET_ERROR is returned, and
            a specific error number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There was insufficient memory to perform the operation.</term>
            </item>
            <item>
            <term>WSAEACCES</term>
            <term>The calling routine does not have sufficient privileges to access the information.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The buffer pointed to by the lpServiceClassInfo parameter is too small to contain a WSASERVICECLASSINFOW. The application needs
            to pass in a larger buffer.
            </term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            The specified service class identifier or namespace provider identifier is not valid. This error is returned if the
            lpProviderId, lpServiceClassId, lpdwBufSize, or lpServiceClassInfo parameters are NULL.
            </term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>
            The operation is not supported for the type of object referenced. This error is returned by some namespace providers that do not
            support getting service class information.
            </term>
            </item>
            <item>
            <term>WSANO_DATA</term>
            <term>The requested name is valid, but no data of the requested type was found.</term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>
            The WS2_32.DLL has not been initialized. The application must first call WSAStartup before calling any Windows Sockets functions.
            </term>
            </item>
            <item>
            <term>WSATYPE_NOT_FOUND</term>
            <term>The specified class was not found.</term>
            </item>
            </list>
            </returns>
            <remarks>
            The <c>WSAGetServiceClassInfo</c> function retrieves service class information from a namespace provider. The service class
            information retrieved from a particular namespace provider might not be the complete set of class information that was specified
            when the service class was installed. Individual namespace providers are only required to retain service class information that
            is applicable to the namespaces that they support. See the section Service Class Data Structures for more information.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAGetServiceClassNameByClassId(System.Guid@,System.Text.StringBuilder,System.UInt32@)">
            <summary>
            The <c>WSAGetServiceClassNameByClassId</c> function retrieves the name of the service associated with the specified type. This
            name is the generic service name, like FTP or SNA, and not the name of a specific instance of that service.
            </summary>
            <param name="lpServiceClassId">A pointer to the GUID for the service class.</param>
            <param name="lpszServiceClassName">A pointer to the service name.</param>
            <param name="lpdwBufferLength">
            On input, the length of the buffer returned by lpszServiceClassName, in characters. On output, the length of the service name
            copied into lpszServiceClassName, in characters.
            </param>
            <returns>
            <para>
            The <c>WSAGetServiceClassNameByClassId</c> function returns a value of zero if successful. Otherwise, the value SOCKET_ERROR is
            returned, and a specific error number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSA_INVALID_PARAMETER</term>
            <term>The lpServiceClassId parameter specified is invalid.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There was insufficient memory to perform the operation.</term>
            </item>
            <item>
            <term>WSAEACCES</term>
            <term>The calling routine does not have sufficient privileges to access the information.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The specified buffer pointed to by lpszServiceClassName is too small. Pass in a larger buffer.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>No buffer space available.</term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>
            The operation is not supported for the type of object referenced. This error is returned by some namespace providers that do not
            support getting service class information.
            </term>
            </item>
            <item>
            <term>WSANO_DATA</term>
            <term>The lpServiceClassId is valid, but no data of the requested type was found.</term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>
            The WS2_32.DLL has not been initialized. The application must first call WSAStartup before calling any Windows Sockets functions.
            </term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAHtonl(Vanara.PInvoke.Ws2_32.SOCKET,System.UInt32,System.UInt32@)">
            <summary>The <c>WSAHtonl</c> function converts a <c>u_long</c> from host byte order to network byte order.</summary>
            <param name="s">A descriptor identifying a socket.</param>
            <param name="hostlong">A 32-bit number in host byte order.</param>
            <param name="lpnetlong">A pointer to a 32-bit number to receive the number in network byte order.</param>
            <returns>
            <para>
            If no error occurs, <c>WSAHtonl</c> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can
            be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The lpnetlong parameter is NULL or the address pointed to is not completely contained in a valid part of the user address space.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAHtonl</c> function takes a 32-bit number in host byte order and returns a 32-bit number in network byte order in the
            32-bit number pointed to by the lpnetlong parameter. The socket passed in the s parameter is used to determine the network byte
            order required based on the Winsock catalog protocol entry associated with the socket. This feature supports Winsock providers
            that use different network byte orders.
            </para>
            <para>
            If the socket is for the AF_INET or AF_INET6 address family, the <c>WSAHtonl</c> function can be used to convert an IPv4 address
            in host byte order to the IPv4 address in network byte order. This function does not do any checking to determine if the
            hostlong parameter is a valid IPv4 address.
            </para>
            <para>
            The <c>WSAHtonl</c> function requires that the Winsock DLL has previously been loaded with a successful call to the WSAStartup
            function. For use with the AF_INET or AF_INET6 family, the htonlfunction does not require that the Winsock DLL be loaded.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAHtons(Vanara.PInvoke.Ws2_32.SOCKET,System.UInt16,System.UInt16@)">
            <summary>The <c>WSAHtons</c> function converts a <c>u_short</c> from host byte order to network byte order.</summary>
            <param name="s">A descriptor identifying a socket.</param>
            <param name="hostshort">A 16-bit number in host byte order.</param>
            <param name="lpnetshort">A pointer to a 16-bit buffer to receive the number in network byte order.</param>
            <returns>
            <para>
            If no error occurs, <c>WSAHtons</c> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can
            be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The lpnetshort parameter is NULL or the address pointed to is not completely contained in a valid part of the user address space.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAHtons</c> function takes a 16-bit number in host byte order and returns a 16-bit number in network byte order in the
            16-bit number pointed to by the lpnetshort parameter. The socket passed in the s parameter is used to determine the network byte
            order required based on the Winsock catalog protocol entry associated with the socket. This feature supports Winsock providers
            that use different network byte orders.
            </para>
            <para>
            If the socket is for the AF_INET or AF_INET6 address family, the <c>WSAHtons</c> function can be used to convert an IP port
            number in host byte order to the IP port number in network byte order.
            </para>
            <para>
            The <c>WSAHtons</c> function requires that the Winsock DLL has previously been loaded with a successful call to the WSAStartup
            function. For use with the AF_INET OR AF_INET6 address family, the htonsfunction does not require that the Winsock DLL be loaded.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAInstallServiceClass(Vanara.PInvoke.Ws2_32.WSASERVICECLASSINFO@)">
            <summary>
            The <c>WSAInstallServiceClass</c> function registers a service class schema within a namespace. This schema includes the class
            name, class identifier, and any namespace-specific information that is common to all instances of the service, such as the SAP
            identifier or object identifier.
            </summary>
            <param name="lpServiceClassInfo">
            <para>Service class to namespace specifictype mapping information. Multiple mappings can be handled at one time.</para>
            <para>See the section Service Class Data Structures for a description of pertinent data structures.</para>
            </param>
            <returns>
            <para>
            The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error
            number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSA_INVALID_PARAMETER</term>
            <term>The namespace provider cannot supply the requested class information.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There was insufficient memory to perform the operation.</term>
            </item>
            <item>
            <term>WSAEACCES</term>
            <term>The calling function does not have sufficient privileges to install the service.</term>
            </item>
            <item>
            <term>WSAEALREADY</term>
            <term>
            Service class information has already been registered for this service class identifier. To modify service class information,
            first use WSARemoveServiceClass, and then reinstall with updated class information data.
            </term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            The service class information was not valid or improperly structured. This error is returned if the lpServiceClassInfo parameter
            is NULL.
            </term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>The operation is not supported. This error is returned if the namespace provider does not implement this function.</term>
            </item>
            <item>
            <term>WSANO_DATA</term>
            <term>The requested name is valid, but no data of the requested type was found.</term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>
            The WS2_32.DLL has not been initialized. The application must first call WSAStartup before calling any Windows Sockets functions.
            </term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAIoctl(Vanara.PInvoke.Ws2_32.SOCKET,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32@,System.IntPtr,System.IntPtr)">
            <summary>The <c>WSAIoctl</c> function controls the mode of a socket.</summary>
            <param name="s">A descriptor identifying a socket.</param>
            <param name="dwIoControlCode">The control code of operation to perform.</param>
            <param name="lpvInBuffer">A pointer to the input buffer.</param>
            <param name="cbInBuffer">The size, in bytes, of the input buffer.</param>
            <param name="lpvOutBuffer">A pointer to the output buffer.</param>
            <param name="cbOutBuffer">The size, in bytes, of the output buffer.</param>
            <param name="lpcbBytesReturned">A pointer to actual number of bytes of output.</param>
            <param name="lpOverlapped">A pointer to a WSAOVERLAPPED structure (ignored for non-overlapped sockets).</param>
            <param name="lpCompletionRoutine">
            <c>Note</c> A pointer to the completion routine called when the operation has been completed (ignored for non-overlapped
            sockets). See Remarks.
            </param>
            <returns>
            <para>
            Upon successful completion, the <c>WSAIoctl</c> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific
            error code can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSA_IO_PENDING</term>
            <term>An overlapped operation was successfully initiated and completion will be indicated at a later time.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The lpvInBuffer, lpvOutBuffer, lpcbBytesReturned, lpOverlapped, or lpCompletionRoutine parameter is not totally contained in a
            valid part of the user address space, or the cbInBuffer or cbOutBuffer parameter is too small.
            </term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            The dwIoControlCode parameter is not a valid command, or a specified input parameter is not acceptable, or the command is not
            applicable to the type of socket specified.
            </term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>The function is invoked when a callback is in progress.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor s is not a socket.</term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>
            The specified IOCTL command cannot be realized. (For example, the FLOWSPEC structures specified in SIO_SET_QOS or
            SIO_SET_GROUP_QOS cannot be satisfied.)
            </term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>The socket is marked as non-blocking and the requested operation would block.</term>
            </item>
            <item>
            <term>WSAENOPROTOOPT</term>
            <term>
            The socket option is not supported on the specified protocol. For example, an attempt to use the SIO_GET_BROADCAST_ADDRESS IOCTL
            was made on an IPv6 socket or an attempt to use the TCP SIO_KEEPALIVE_VALS IOCTL was made on a datagram socket.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAIoctl</c> function is used to set or retrieve operating parameters associated with the socket, the transport protocol,
            or the communications subsystem.
            </para>
            <para>
            If both lpOverlapped and lpCompletionRoutine are <c>NULL</c>, the socket in this function will be treated as a non-overlapped
            socket. For a non-overlapped socket, lpOverlapped and lpCompletionRoutine parameters are ignored, which causes the function to
            behave like the standard ioctlsocket function except that the function can block if socket s is in blocking mode. If socket s is
            in non-blocking mode, this function can return WSAEWOULDBLOCK when the specified operation cannot be finished immediately. In
            this case, the application may change the socket to blocking mode and reissue the request or wait for the corresponding network
            event (such as FD_ROUTING_INTERFACE_CHANGE or FD_ADDRESS_LIST_CHANGE in the case of <c>SIO_ROUTING_INTERFACE_CHANGE</c> or
            <c>SIO_ADDRESS_LIST_CHANGE</c>) using a Windows message (using WSAAsyncSelect)-based or event (using WSAEventSelect)-based
            notification mechanism.
            </para>
            <para>
            For overlapped sockets, operations that cannot be completed immediately will be initiated, and completion will be indicated at a
            later time. The <c>DWORD</c> value pointed to by the lpcbBytesReturned parameter that is returned may be ignored. The final
            completion status and bytes returned can be retrieved when the appropriate completion method is signaled when the operation has completed.
            </para>
            <para>
            Any IOCTL may block indefinitely, depending on the service provider's implementation. If the application cannot tolerate
            blocking in a <c>WSAIoctl</c> call, overlapped I/O would be advised for IOCTLs that are especially likely to block including:
            </para>
            <para><c>SIO_ADDRESS_LIST_CHANGE</c></para>
            <para><c>SIO_FINDROUTE</c></para>
            <para><c>SIO_FLUSH</c></para>
            <para><c>SIO_GET_QOS</c></para>
            <para><c>SIO_GET_GROUP_QOS</c></para>
            <para><c>SIO_ROUTING_INTERFACE_CHANGE</c></para>
            <para><c>SIO_SET_QOS</c></para>
            <para><c>SIO_SET_GROUP_QOS</c></para>
            <para>
            Some protocol-specific IOCTLs may also be especially likely to block. Check the relevant protocol-specific annex for any
            available information.
            </para>
            <para>The prototype for the completion routine pointed to by the lpCompletionRoutine parameter is as follows:</para>
            <para>
            The CompletionRoutine is a placeholder for an application-supplied function name. The dwError parameter specifies the completion
            status for the overlapped operation as indicated by lpOverlapped parameter. The cbTransferred parameter specifies the number of
            bytes received. The dwFlags parameter is not used for this IOCTL. The completion routine does not return a value.
            </para>
            <para>
            It is possible to adopt an encoding scheme that preserves the currently defined ioctlsocket opcodes while providing a convenient
            way to partition the opcode identifier space in as much as the dwIoControlCode parameter is now a 32-bit entity. The
            dwIoControlCode parameter is built to allow for protocol and vendor independence when adding new control codes while retaining
            backward compatibility with the Windows Sockets 1.1 and Unix control codes. The dwIoControlCode parameter has the following form.
            </para>
            <list type="table">
            <listheader>
            <term>I</term>
            <term>O</term>
            <term>V</term>
            <term>T</term>
            <term>Vendor/address family</term>
            <term>Code</term>
            </listheader>
            <item>
            <term>3</term>
            <term>3</term>
            <term>2</term>
            <term>2 2</term>
            <term>2 2 2 2 2 2 2 1 1 1 1</term>
            <term>1 1 1 1 1 1</term>
            </item>
            <item>
            <term>1</term>
            <term>0</term>
            <term>9</term>
            <term>8 7</term>
            <term>6 5 4 3 2 1 0 9 8 7 6</term>
            <term>5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0</term>
            </item>
            </list>
            <para>
            <c>Note</c> The bits in dwIoControlCode parameter displayed in the table must be read vertically from top to bottom by column.
            So the left-most bit is bit 31, the next bit is bit 30, and the right-most bit is bit 0.
            </para>
            <para>I is set if the input buffer is valid for the code, as with <c>IOC_IN</c>.</para>
            <para>
            O is set if the output buffer is valid for the code, as with <c>IOC_OUT</c>. Control codes using both input and output buffers
            set both I and O.
            </para>
            <para>V is set if there are no parameters for the code, as with <c>IOC_VOID</c>.</para>
            <para>T is a 2-bit quantity that defines the type of the IOCTL. The following values are defined:</para>
            <para>0 The IOCTL is a standard Unix IOCTL code, as with <c>FIONREAD</c> and <c>FIONBIO</c>.</para>
            <para>1 The IOCTL is a generic Windows Sockets 2 IOCTL code. New IOCTL codes defined for Windows Sockets 2 will have T == 1.</para>
            <para>2 The IOCTL applies only to a specific address family.</para>
            <para>
            3 The IOCTL applies only to a specific vendor's provider, as with <c>IOC_VENDOR</c>. This type allows companies to be assigned a
            vendor number that appears in the <c>Vendor/Address family</c> parameter. Then, the vendor can define new IOCTLs specific to
            that vendor without having to register the IOCTL with a clearinghouse, thereby providing vendor flexibility and privacy.
            </para>
            <para>
            <c>Vendor/Address family</c> An 11-bit quantity that defines the vendor who owns the code (if T == 3) or that contains the
            address family to which the code applies (if T == 2). If this is a Unix IOCTL code (T == 0) then this parameter has the same
            value as the code on Unix. If this is a generic Windows Sockets 2 IOCTL (T == 1) then this parameter can be used as an extension
            of the code parameter to provide additional code values.
            </para>
            <para><c>Code</c> The 16-bit quantity that contains the specific IOCTL code for the operation.</para>
            <para>The following Unix IOCTL codes (commands) are supported.</para>
            <para>The following Windows Sockets 2 commands are supported.</para>
            <para>
            If an overlapped operation completes immediately, <c>WSAIoctl</c> returns a value of zero and the lpcbBytesReturned parameter is
            updated with the number of bytes in the output buffer. If the overlapped operation is successfully initiated and will complete
            later, this function returns SOCKET_ERROR and indicates error code WSA_IO_PENDING. In this case, lpcbBytesReturned is not
            updated. When the overlapped operation completes the amount of data in the output buffer is indicated either through the
            cbTransferred parameter in the completion routine (if specified), or through the lpcbTransfer parameter in WSAGetOverlappedResult.
            </para>
            <para>
            When called with an overlapped socket, the lpOverlapped parameter must be valid for the duration of the overlapped operation.
            The lpOverlapped parameter contains the address of a WSAOVERLAPPED structure.
            </para>
            <para>
            If the lpCompletionRoutine parameter is <c>NULL</c>, the hEvent parameter of lpOverlapped is signaled when the overlapped
            operation completes if it contains a valid event object handle. An application can use WSAWaitForMultipleEvents or
            WSAGetOverlappedResult to wait or poll on the event object.
            </para>
            <para>
            <c>Note</c> All I/O initiated by a given thread is canceled when that thread exits. For overlapped sockets, pending asynchronous
            operations can fail if the thread is closed before the operations complete. See ExitThread for more information.
            </para>
            <para>
            If lpCompletionRoutine is not <c>NULL</c>, the hEvent parameter is ignored and can be used by the application to pass context
            information to the completion routine. A caller that passes a non- <c>NULL</c> lpCompletionRoutine and later calls
            WSAGetOverlappedResult for the same overlapped I/O request may not set the fWait parameter for that invocation of
            <c>WSAGetOverlappedResult</c> to <c>TRUE</c>. In this case, the usage of the hEvent parameter is undefined, and attempting to
            wait on the hEvent parameter would produce unpredictable results.
            </para>
            <para>The prototype of the completion routine is as follows:</para>
            <para>
            This <c>CompletionRoutine</c> is a placeholder for an application-defined or library-defined function. The completion routine is
            invoked only if the thread is in an alertable state. To put a thread into an alertable state, use the WSAWaitForMultipleEvents,
            WaitForSingleObjectEx, or WaitForMultipleObjectsEx function with the fAlertable or bAlertable parameter set to <c>TRUE</c>.
            </para>
            <para>
            The dwError parameter of <c>CompletionRoutine</c> specifies the completion status for the overlapped operation as indicated by
            lpOverlapped. The cbTransferred parameter specifies the number of bytes returned. Currently, no flag values are defined and
            dwFlags will be zero. The <c>CompletionRoutine</c> function does not return a value.
            </para>
            <para>
            Returning from this function allows invocation of another pending completion routine for this socket. The completion routines
            can be called in any order, not necessarily in the same order the overlapped operations are completed.
            </para>
            <para>Compatibility</para>
            <para>
            The IOCTL codes with T == 0 are a subset of the IOCTL codes used in Berkeley sockets. In particular, there is no command that is
            equivalent to <c>FIOASYNC</c>.
            </para>
            <para>
            <c>Note</c> Some IOCTL codes require additional header files. For example, use of the <c>SIO_RCVALL</c> IOCTL requires the
            Mstcpip.h header file.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAJoinLeaf(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.SOCKADDR,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,Vanara.PInvoke.Ws2_32.JL)">
            <summary>
            The <c>WSAJoinLeaf</c> function joins a leaf node into a multipoint session, exchanges connect data, and specifies needed
            quality of service based on the specified FLOWSPEC structures.
            </summary>
            <param name="s">Descriptor identifying a multipoint socket.</param>
            <param name="name">Name of the peer to which the socket is to be joined.</param>
            <param name="namelen">Length of name, in bytes.</param>
            <param name="lpCallerData">Pointer to the user data that is to be transferred to the peer during multipoint session establishment.</param>
            <param name="lpCalleeData">
            Pointer to the user data that is to be transferred back from the peer during multipoint session establishment.
            </param>
            <param name="lpSQOS">Pointer to the FLOWSPEC structures for socket s, one for each direction.</param>
            <param name="lpGQOS">
            Reserved for future use with socket groups. A pointer to the FLOWSPEC structures for the socket group (if applicable).
            </param>
            <param name="dwFlags">
            Flags to indicate that the socket is acting as a sender (JL_SENDER_ONLY), receiver (JL_RECEIVER_ONLY), or both (JL_BOTH).
            </param>
            <returns>
            <para>
            If no error occurs, <c>WSAJoinLeaf</c> returns a value of type SOCKET that is a descriptor for the newly created multipoint
            socket. Otherwise, a value of INVALID_SOCKET is returned, and a specific error code can be retrieved by calling WSAGetLastError.
            </para>
            <para>On a blocking socket, the return value indicates success or failure of the join operation.</para>
            <para>
            With a nonblocking socket, successful initiation of a join operation is indicated by a return of a valid socket descriptor.
            Subsequently, an FD_CONNECT indication will be given on the original socket s when the join operation completes, either
            successfully or otherwise. The application must use either WSAAsyncSelect or WSAEventSelect with interest registered for the
            FD_CONNECT event in order to determine when the join operation has completed and checks the associated error code to determine
            the success or failure of the operation. The select function cannot be used to determine when the join operation completes.
            </para>
            <para>
            Also, until the multipoint session join attempt completes all subsequent calls to <c>WSAJoinLeaf</c> on the same socket will
            fail with the error code WSAEALREADY. After the <c>WSAJoinLeaf</c> operation completes successfully, a subsequent attempt will
            usually fail with the error code WSAEISCONN. An exception to the WSAEISCONN rule occurs for a c_root socket that allows
            root-initiated joins. In such a case, another join may be initiated after a prior <c>WSAJoinLeaf</c> operation completes.
            </para>
            <para>
            If the return error code indicates the multipoint session join attempt failed (that is, WSAECONNREFUSED, WSAENETUNREACH,
            WSAETIMEDOUT) the application can call <c>WSAJoinLeaf</c> again for the same socket.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAEADDRINUSE</term>
            <term>
            The socket's local address is already in use and the socket was not marked to allow address reuse with SO_REUSEADDR. This error
            usually occurs at the time of bind, but could be delayed until this function if the bind was to a partially wildcard address
            (involving ADDR_ANY) and if a specific address needs to be committed at the time of this function.
            </term>
            </item>
            <item>
            <term>WSAEADDRNOTAVAIL</term>
            <term>The remote address is not a valid address (such as ADDR_ANY).</term>
            </item>
            <item>
            <term>WSAEAFNOSUPPORT</term>
            <term>Addresses in the specified family cannot be used with this socket.</term>
            </item>
            <item>
            <term>WSAEALREADY</term>
            <term>A nonblocking WSAJoinLeaf call is in progress on the specified socket.</term>
            </item>
            <item>
            <term>WSAECONNREFUSED</term>
            <term>The attempt to join was forcefully rejected.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The name or the namelen parameter is not a valid part of the user address space, the namelen parameter is too small, the buffer
            length for lpCalleeData, lpSQOS, and lpGQOS are too small, or the buffer length for lpCallerData is too large.
            </term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            A WSAJoinLeaf function call was performed on a UDP socket that was opened without setting its WSA_FLAG_MULTIPOINT_C_LEAF or
            WSA_FLAG_MULTIPOINT_D_LEAF multipoint flag.
            </term>
            </item>
            <item>
            <term>WSAEISCONN</term>
            <term>The socket is already a member of the multipoint session.</term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>A blocking Windows Socket 1.1 call was canceled through WSACancelBlockingCall.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENETUNREACH</term>
            <term>The network cannot be reached from this host at this time.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>No buffer space is available. The socket cannot be joined.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>The FLOWSPEC structures specified in lpSQOS and lpGQOS cannot be satisfied.</term>
            </item>
            <item>
            <term>WSAEPROTONOSUPPORT</term>
            <term>The lpCallerData augment is not supported by the service provider.</term>
            </item>
            <item>
            <term>WSAETIMEDOUT</term>
            <term>The attempt to join timed out without establishing a multipoint session.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAJoinLeaf</c> function is used to join a leaf node to a multipoint session, and to perform a number of other ancillary
            operations that occur at session join time as well. If the socket s is unbound, unique values are assigned to the local
            association by the system, and the socket is marked as bound.
            </para>
            <para>
            The <c>WSAJoinLeaf</c> function has the same parameters and semantics as WSAConnect except that it returns a socket descriptor
            (as in WSAAccept), and it has an additional dwFlags parameter. Only multipoint sockets created using WSASocket with appropriate
            multipoint flags set can be used for input parameter s in this function. The returned socket descriptor will not be usable until
            after the join operation completes. For example, if the socket is in nonblocking mode after a corresponding FD_CONNECT
            indication has been received from WSAAsyncSelect or WSAEventSelect on the original socket s, except that closesocket may be
            invoked on this new socket descriptor to cancel a pending join operation. A root application in a multipoint session may call
            <c>WSAJoinLeaf</c> one or more times in order to add a number of leaf nodes, however at most one multipoint connection request
            may be outstanding at a time. Refer to Multipoint and Multicast Semantics for additional information.
            </para>
            <para>
            For nonblocking sockets it is often not possible to complete the connection immediately. In such a case, this function returns
            an as-yet unusable socket descriptor and the operation proceeds. There is no error code such as WSAEWOULDBLOCK in this case,
            since the function has effectively returned a successful start indication. When the final outcome success or failure becomes
            known, it may be reported through WSAAsyncSelect or WSAEventSelect depending on how the client registers for notification on the
            original socket s. In either case, the notification is announced with FD_CONNECT and the error code associated with the
            FD_CONNECT indicates either success or a specific reason for failure. The select function cannot be used to detect completion
            notification for <c>WSAJoinLeaf</c>.
            </para>
            <para>
            The socket descriptor returned by <c>WSAJoinLeaf</c> is different depending on whether the input socket descriptor, s, is a
            c_root or a c_leaf. When used with a c_root socket, the name parameter designates a particular leaf node to be added and the
            returned socket descriptor is a c_leaf socket corresponding to the newly added leaf node. The newly created socket has the same
            properties as s, including asynchronous events registered with WSAAsyncSelect or with WSAEventSelect. It is not intended to be
            used for exchange of multipoint data, but rather is used to receive network event indications (for example, FD_CLOSE) for the
            connection that exists to the particular c_leaf. Some multipoint implementations can also allow this socket to be used for side
            chats between the root and an individual leaf node. An FD_CLOSE indication will be received for this socket if the corresponding
            leaf node calls closesocket to drop out of the multipoint session. Symmetrically, invoking <c>closesocket</c> on the c_leaf
            socket returned from <c>WSAJoinLeaf</c> will cause the socket in the corresponding leaf node to get an FD_CLOSE notification.
            </para>
            <para>
            When <c>WSAJoinLeaf</c> is invoked with a c_leaf socket, the name parameter contains the address of the root application (for a
            rooted control scheme) or an existing multipoint session (nonrooted control scheme), and the returned socket descriptor is the
            same as the input socket descriptor. In other words, a new socket descriptor is not allocated. In a rooted control scheme, the
            root application would put its c_root socket in listening mode by calling listen. The standard FD_ACCEPT notification will be
            delivered when the leaf node requests to join itself to the multipoint session. The root application uses the usual accept or
            WSAAccept functions to admit the new leaf node. The value returned from either <c>accept</c> or <c>WSAAccept</c> is also a
            c_leaf socket descriptor just like those returned from <c>WSAJoinLeaf</c>. To accommodate multipoint schemes that allow both
            root-initiated and leaf-initiated joins, it is acceptable for a c_root socket that is already in listening mode to be used as an
            input to <c>WSAJoinLeaf</c>.
            </para>
            <para>
            The application is responsible for allocating any memory space pointed to directly or indirectly by any of the parameters it specifies.
            </para>
            <para>
            The lpCallerData is a value parameter that contains any user data that is to be sent along with the multipoint session join
            request. If lpCallerData is <c>NULL</c>, no user data will be passed to the peer. The lpCalleeData is a result parameter that
            will contain any user data passed back from the peer as part of the multipoint session establishment. The <c>len</c> member of
            the WSABUF structure pointed to by the lpCalleeData parameter initially contains the length of the buffer allocated by the
            application and pointed to by the <c>buf</c> member of the <c>WSABUF</c> structure. The <c>len</c> member of the <c>WSABUF</c>
            structure pointed to by the lpCalleeData parameter will be set to zero if no user data has been passed back. The lpCalleeData
            information will be valid when the multipoint join operation is complete.
            </para>
            <para>
            For blocking sockets, this will be when the <c>WSAJoinLeaf</c> function returns. For nonblocking sockets, this will be after the
            join operation has completed. For example, this could occur after FD_CONNECT notification on the original socket s). If
            lpCalleeData is <c>NULL</c>, no user data will be passed back. The exact format of the user data is specific to the address
            family to which the socket belongs.
            </para>
            <para>
            At multipoint session establishment time, an application can use the lpSQOS and/or lpGQOS parameters to override any previous
            quality of service specification made for the socket through WSAIoctl with the SIO_SET_QOS or SIO_SET_GROUP_QOS opcodes.
            </para>
            <para>
            The lpSQOS parameter specifies the FLOWSPEC structures for socket s, one for each direction, followed by any additional
            provider-specific parameters. If either the associated transport provider in general or the specific type of socket in
            particular cannot honor the quality of service request, an error will be returned as indicated in the following. The respective
            sending or receiving flow specification values will be ignored for any unidirectional sockets. If no provider-specific
            parameters are specified, the <c>buf</c> and <c>len</c> members of the WSABUF structure pointed to by the lpCalleeData parameter
            should be set to <c>NULL</c> and zero, respectively. A <c>NULL</c> value for lpSQOS indicates no application-supplied quality of service.
            </para>
            <para>
            Reserved for future socket groups. The lpGQOS parameter specifies the FLOWSPEC structures for the socket group (if applicable),
            one for each direction, followed by any additional provider-specific parameters. If no provider-specific parameters are
            specified, the the <c>buf</c> and <c>len</c> members of the WSABUF structure pointed to by the lpCalleeData parameter should be
            set to should be set to <c>NULL</c> and zero, respectively. A <c>NULL</c> value for lpGQOS indicates no application-supplied
            group quality of service. This parameter will be ignored if s is not the creator of the socket group.
            </para>
            <para>
            When connected sockets break (that is, become closed for whatever reason), they should be discarded and recreated. It is safest
            to assume that when things go awry for any reason on a connected socket, the application must discard and recreate the needed
            sockets in order to return to a stable point.
            </para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>WSAJoinLeaf</c>, Winsock may need to wait for a network event before
            the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous
            procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an
            ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSALookupServiceBegin(Vanara.PInvoke.Ws2_32.WSAQUERYSET@,Vanara.PInvoke.Ws2_32.LUP,Vanara.PInvoke.HANDLE@)">
            <summary>
            The <c>WSALookupServiceBegin</c> function initiates a client query that is constrained by the information contained within a
            WSAQUERYSET structure. <c>WSALookupServiceBegin</c> only returns a handle, which should be used by subsequent calls to
            WSALookupServiceNext to get the actual results.
            </summary>
            <param name="lpqsRestrictions">A pointer to the search criteria. See the Remarks for details.</param>
            <param name="dwControlFlags">
            <para>A set of flags that controls the depth of the search.</para>
            <para>
            Supported values for the dwControlFlags parameter are defined in the Winsock2.h header file and can be a combination of the
            following options.
            </para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>LUP_DEEP 0x0001</term>
            <term>Queries deep as opposed to just the first level.</term>
            </item>
            <item>
            <term>LUP_CONTAINERS 0x0002</term>
            <term>Returns containers only.</term>
            </item>
            <item>
            <term>LUP_NOCONTAINERS 0x0004</term>
            <term>Do not return containers.</term>
            </item>
            <item>
            <term>LUP_NEAREST 0x0008</term>
            <term>If possible, returns results in the order of distance. The measure of distance is provider specific.</term>
            </item>
            <item>
            <term>LUP_RETURN_NAME 0x0010</term>
            <term>Retrieves the name as lpszServiceInstanceName.</term>
            </item>
            <item>
            <term>LUP_RETURN_TYPE 0x0020</term>
            <term>Retrieves the type as lpServiceClassId.</term>
            </item>
            <item>
            <term>LUP_RETURN_VERSION 0x0040</term>
            <term>Retrieves the version as lpVersion.</term>
            </item>
            <item>
            <term>LUP_RETURN_COMMENT 0x0080</term>
            <term>Retrieves the comment as lpszComment.</term>
            </item>
            <item>
            <term>LUP_RETURN_ADDR 0x0100</term>
            <term>Retrieves the addresses as lpcsaBuffer.</term>
            </item>
            <item>
            <term>LUP_RETURN_BLOB 0x0200</term>
            <term>Retrieves the private data as lpBlob.</term>
            </item>
            <item>
            <term>LUP_RETURN_ALIASES 0x0400</term>
            <term>
            Any available alias information is to be returned in successive calls to WSALookupServiceNext, and each alias returned will have
            the RESULT_IS_ALIAS flag set.
            </term>
            </item>
            <item>
            <term>LUP_RETURN_QUERY_STRING 0x0800</term>
            <term>Retrieves the query string used for the request.</term>
            </item>
            <item>
            <term>LUP_RETURN_ALL 0x0FF0</term>
            <term>A set of flags that retrieves all of the LUP_RETURN_* values.</term>
            </item>
            <item>
            <term>LUP_FLUSHPREVIOUS 0x1000</term>
            <term>
            Used as a value for the dwControlFlags parameter in WSALookupServiceNext. Setting this flag instructs the provider to discard
            the last result set, which was too large for the specified buffer, and move on to the next result set.
            </term>
            </item>
            <item>
            <term>LUP_FLUSHCACHE 0x2000</term>
            <term>If the provider has been caching information, ignores the cache, and queries the namespace itself.</term>
            </item>
            <item>
            <term>LUP_RES_SERVICE 0x8000</term>
            <term>
            This indicates whether prime response is in the remote or local part of CSADDR_INFO structure. The other part needs to be usable
            in either case.
            </term>
            </item>
            </list>
            </param>
            <param name="lphLookup">A handle to be used when calling WSALookupServiceNext in order to start retrieving the results set.</param>
            <returns>
            <para>
            The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error
            number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There was insufficient memory to perform the operation.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more parameters were missing or invalid for this provider.</term>
            </item>
            <item>
            <term>WSANO_DATA</term>
            <term>The name was found in the database but no data matching the given restrictions was located.</term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>
            The WS2_32.DLL has not been initialized. The application must first call WSAStartup before calling any Windows Sockets functions.
            </term>
            </item>
            <item>
            <term>WSASERVICE_NOT_FOUND</term>
            <term>
            No such service is known. The service cannot be found in the specified name space. This error is returned for a bluetooth
            service discovery request if no remote bluetooth devices were found.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The lpqsRestrictions parameter points to a buffer containing a WSAQUERYSET structure. At a minimum, the <c>dwSize</c> member of
            the <c>WSAQUERYSET</c> must be set to the length of the buffer before calling the <c>WSALookupServiceBegin</c> function.
            Applications can restrict the query by specifying other members in the <c>WSAQUERYSET</c>.
            </para>
            <para>
            In most instances, applications interested in only a particular transport protocol should constrain their query by address
            family and protocol using the <c>dwNumberOfProtocols</c> and <c>lpafpProtocols</c> members of the WSAQUERYSET rather than by
            specifiying the namespace in the <c>dwNameSpace</c> member.
            </para>
            <para>
            Information on supported network transport protocols can be retreived using the EnumProtocols, WSAEnumProtocols,
            WSCEnumProtocols, or WSCEnumProtocols32 function.
            </para>
            <para>
            It is also possible to constrain the query to a single namespace. For example, a query that only wants results from DNS (not
            results from the local hosts file and other naming services) would set the <c>dwNameSpace</c> member to NS_DNS. For example, a
            bluetooth device discovery would set the the <c>dwNameSpace</c> member to NS_BTH.
            </para>
            <para>
            Applications can also restrict the query to a specific namespace provider by specifying a pointer to the GUID for the provider
            in the <c>lpNSProviderId</c> member.
            </para>
            <para>
            Information on namespace providers on the local computer can be retrieved using the WSAEnumNameSpaceProviders,
            WSAEnumNameSpaceProvidersEx, WSCEnumNameSpaceProviders32, or WSCEnumNameSpaceProvidersEx32 function.
            </para>
            <para>
            If LUP_CONTAINERS is specified in a call, other restriction values should be avoided. If any are specified, it is up to the name
            service provider to decide if it can support this restriction over the containers. If it cannot, it should return an error.
            </para>
            <para>
            Some name service providers can have other means of finding containers. For example, containers might all be of some well-known
            type, or of a set of well-known types, and therefore a query restriction can be created for finding them. No matter what other
            means the name service provider has for locating containers, LUP_CONTAINERS and LUP_NOCONTAINERS take precedence. Hence, if a
            query restriction is given that includes containers, specifying LUP_NOCONTAINERS will prevent the container items from being
            returned. Similarly, no matter the query restriction, if LUP_CONTAINERS is given, only containers should be returned. If a
            namespace does not support containers, and LUP_CONTAINERS is specified, it should simply return WSANO_DATA.
            </para>
            <para>The preferred method of obtaining the containers within another container, is the call:</para>
            <para>
            This call is followed by the requisite number of WSALookupServiceNext calls. This will return all containers contained
            immediately within the starting context; that is, it is not a deep query. With this, one can map the address space structure by
            walking the hierarchy, perhaps enumerating the content of selected containers. Subsequent uses of <c>WSALookupServiceBegin</c>
            use the containers returned from a previous call.
            </para>
            <para>
            As mentioned above, a WSAQUERYSET structure is used as an input parameter to <c>WSALookupBegin</c> in order to qualify the
            query. The following table indicates how the <c>WSAQUERYSET</c> is used to construct a query. When a parameter is marked as
            (Optional) a <c>NULL</c> pointer can be specified, indicating that the parameter will not be used as a search criteria. See
            section Query-Related Data Structures for additional information.
            </para>
            <list type="table">
            <listheader>
            <term>WSAQUERYSET member</term>
            <term>Query interpretation</term>
            </listheader>
            <item>
            <term>dwSize</term>
            <term>Must be set to sizeof(WSAQUERYSET). This is a versioning mechanism.</term>
            </item>
            <item>
            <term>dwOutputFlags</term>
            <term>Ignored for queries.</term>
            </item>
            <item>
            <term>lpszServiceInstanceName</term>
            <term>
            (Optional) Referenced string contains service name. The semantics for wildcarding within the string are not defined, but can be
            supported by certain namespace providers.
            </term>
            </item>
            <item>
            <term>lpServiceClassId</term>
            <term>(Required) The GUID corresponding to the service class.</term>
            </item>
            <item>
            <term>lpVersion</term>
            <term>
            (Optional) References desired version number and provides version comparison semantics (that is, version must match exactly, or
            version must be not less than the value specified).
            </term>
            </item>
            <item>
            <term>lpszComment</term>
            <term>Ignored for queries.</term>
            </item>
            <item>
            <term>dwNameSpace See the Important note that follows.</term>
            <term>Identifier of a single namespace in which to constrain the search, or NS_ALL to include all namespaces.</term>
            </item>
            <item>
            <term>lpNSProviderId</term>
            <term>(Optional) References the GUID of a specific namespace provider, and limits the query to this provider only.</term>
            </item>
            <item>
            <term>lpszContext</term>
            <term>(Optional) Specifies the starting point of the query in a hierarchical namespace.</term>
            </item>
            <item>
            <term>dwNumberOfProtocols</term>
            <term>Size of the protocol constraint array, can be zero.</term>
            </item>
            <item>
            <term>lpafpProtocols</term>
            <term>(Optional) References an array of AFPROTOCOLS structure. Only services that utilize these protocols will be returned.</term>
            </item>
            <item>
            <term>lpszQueryString</term>
            <term>
            (Optional) Some namespaces (such as whois++) support enriched SQL-like queries that are contained in a simple text string. This
            parameter is used to specify that string.
            </term>
            </item>
            <item>
            <term>dwNumberOfCsAddrs</term>
            <term>Ignored for queries.</term>
            </item>
            <item>
            <term>lpcsaBuffer</term>
            <term>Ignored for queries.</term>
            </item>
            <item>
            <term>lpBlob</term>
            <term>(Optional) This is a pointer to a provider-specific entity.</term>
            </item>
            </list>
            <para>
            <c>Important</c> In most instances, applications interested in only a particular transport protocol should constrain their query
            by address family and protocol rather than by namespace. This would allow an application that needs to locate a TCP/IP service,
            for example, to have its query processed by all available namespaces such as the local hosts file, DNS, and NIS.
            </para>
            <para>
            <c>Windows Phone 8:</c> The <c>WSALookupServiceBeginW</c> function is supported for Windows Phone Store apps on Windows Phone 8
            and later.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>WSALookupServiceBeginW</c> function is supported for Windows Store
            apps on Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSALookupServiceEnd(Vanara.PInvoke.HANDLE)">
            <summary>
            <para>
            The <c>WSALookupServiceEnd</c> function is called to free the handle after previous calls to WSALookupServiceBegin and WSALookupServiceNext.
            </para>
            <para>
            If you call <c>WSALookupServiceEnd</c> from another thread while an existing WSALookupServiceNext is blocked, the end call will
            have the same effect as a cancel and will cause the <c>WSALookupServiceNext</c> call to return immediately.
            </para>
            </summary>
            <param name="hLookup">Handle previously obtained by calling WSALookupServiceBegin.</param>
            <returns>
            <para>
            The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error
            number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSA_INVALID_HANDLE</term>
            <term>The handle is not valid.</term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>
            The WS2_32.DLL has not been initialized. The application must first call WSAStartup before calling any Windows Sockets functions.
            </term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There was insufficient memory to perform the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSALookupServiceNext(Vanara.PInvoke.HANDLE,Vanara.PInvoke.Ws2_32.LUP,System.UInt32@,System.IntPtr)">
            <summary>
            <para>
            The <c>WSALookupServiceNext</c> function is called after obtaining a handle from a previous call to WSALookupServiceBegin in
            order to retrieve the requested service information.
            </para>
            <para>
            The provider will pass back a WSAQUERYSET structure in the lpqsResults buffer. The client should continue to call this function
            until it returns WSA_E_NO_MORE, indicating that all of <c>WSAQUERYSET</c> has been returned.
            </para>
            </summary>
            <param name="hLookup">A handle returned from the previous call to WSALookupServiceBegin.</param>
            <param name="dwControlFlags">
            <para>
            A set of flags that controls the operation. The values passed in the dwControlFlags parameter to the
            WSALookupServiceBeginfunction determine the possible criteria. Any values passed in the dwControlFlags parameter to the
            <c>WSALookupServiceNext</c> function further restrict the criteria for the service lookup.
            </para>
            <para>
            Currently, LUP_FLUSHPREVIOUS is defined as a means to cope with a result set that is too large. If an application does not (or
            cannot) supply a large enough buffer, setting LUP_FLUSHPREVIOUS instructs the provider to discard the last result setwhich was
            too largeand move on to the next set for this call.
            </para>
            <para>
            Supported values for the dwControlFlags parameter are defined in the Winsock2.h header file and can be a combination of the
            following options.
            </para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>LUP_DEEP 0x0001</term>
            <term>Queries deep as opposed to just the first level.</term>
            </item>
            <item>
            <term>LUP_CONTAINERS 0x0002</term>
            <term>Returns containers only.</term>
            </item>
            <item>
            <term>LUP_NOCONTAINERS 0x0004</term>
            <term>Do not return containers.</term>
            </item>
            <item>
            <term>LUP_NEAREST 0x0008</term>
            <term>If possible, returns results in the order of distance. The measure of distance is provider specific.</term>
            </item>
            <item>
            <term>LUP_RETURN_NAME 0x0010</term>
            <term>Retrieves the name as lpszServiceInstanceName.</term>
            </item>
            <item>
            <term>LUP_RETURN_TYPE 0x0020</term>
            <term>Retrieves the type as lpServiceClassId.</term>
            </item>
            <item>
            <term>LUP_RETURN_VERSION 0x0040</term>
            <term>Retrieves the version as lpVersion.</term>
            </item>
            <item>
            <term>LUP_RETURN_COMMENT 0x0080</term>
            <term>Retrieves the comment as lpszComment.</term>
            </item>
            <item>
            <term>LUP_RETURN_ADDR 0x0100</term>
            <term>Retrieves the addresses as lpcsaBuffer.</term>
            </item>
            <item>
            <term>LUP_RETURN_BLOB 0x0200</term>
            <term>Retrieves the private data as lpBlob.</term>
            </item>
            <item>
            <term>LUP_RETURN_ALIASES 0x0400</term>
            <term>
            Any available alias information is to be returned in successive calls to WSALookupServiceNext, and each alias returned will have
            the RESULT_IS_ALIAS flag set.
            </term>
            </item>
            <item>
            <term>LUP_RETURN_QUERY_STRING 0x0800</term>
            <term>Retrieves the query string used for the request.</term>
            </item>
            <item>
            <term>LUP_RETURN_ALL 0x0FF0</term>
            <term>A set of flags that retrieves all of the LUP_RETURN_* values.</term>
            </item>
            <item>
            <term>LUP_FLUSHPREVIOUS 0x1000</term>
            <term>
            Used as a value for the dwControlFlags parameter in WSALookupServiceNext. Setting this flag instructs the provider to discard
            the last result set, which was too large for the specified buffer, and move on to the next result set.
            </term>
            </item>
            <item>
            <term>LUP_FLUSHCACHE 0x2000</term>
            <term>If the provider has been caching information, ignores the cache, and queries the namespace itself.</term>
            </item>
            <item>
            <term>LUP_RES_SERVICE 0x8000</term>
            <term>
            This indicates whether prime response is in the remote or local part of CSADDR_INFO structure. The other part needs to be usable
            in either case.
            </term>
            </item>
            </list>
            </param>
            <param name="lpdwBufferLength">
            On input, the number of bytes contained in the buffer pointed to by lpqsResults. On output, if the function fails and the error
            is WSAEFAULT, then it contains the minimum number of bytes to pass for the lpqsResults to retrieve the record.
            </param>
            <param name="lpqsResults">A pointer to a block of memory, which will contain one result set in a WSAQUERYSET structure on return.</param>
            <returns>
            <para>
            The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error
            number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSA_E_CANCELLED</term>
            <term>
            A call to WSALookupServiceEnd was made while this call was still processing. The call has been canceled. The data in the
            lpqsResults buffer is undefined. In Windows Sockets version 2, conflicting error codes are defined for WSAECANCELLED (10103) and
            WSA_E_CANCELLED (10111). The error code WSAECANCELLED will be removed in a future version and only WSA_E_CANCELLED will remain.
            For Windows Sockets version 2, however, applications should check for both WSAECANCELLED and WSA_E_CANCELLED for the widest
            possible compatibility with namespace providers that use either one.
            </term>
            </item>
            <item>
            <term>WSA_E_NO_MORE</term>
            <term>
            There is no more data available. In Windows Sockets version 2, conflicting error codes are defined for WSAENOMORE (10102) and
            WSA_E_NO_MORE (10110). The error code WSAENOMORE will be removed in a future version and only WSA_E_NO_MORE will remain. For
            Windows Sockets version 2, however, applications should check for both WSAENOMORE and WSA_E_NO_MORE for the widest possible
            compatibility with name-space providers that use either one.
            </term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The lpqsResults buffer was too small to contain a WSAQUERYSET set.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more required parameters were invalid or missing.</term>
            </item>
            <item>
            <term>WSA_INVALID_HANDLE</term>
            <term>The specified Lookup handle is invalid.</term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>
            The WS2_32.DLL has not been initialized. The application must first call WSAStartup before calling any Windows Sockets functions.
            </term>
            </item>
            <item>
            <term>WSANO_DATA</term>
            <term>The name was found in the database, but no data matching the given restrictions was located.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There was insufficient memory to perform the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The dwControlFlags parameter specified in this function and the ones specified at the time of WSALookupServiceBegin are treated
            as restrictions for the purpose of combination. The restrictions are combined between the ones at <c>WSALookupServiceBegin</c>
            time and the ones at <c>WSALookupServiceNext</c> time. Therefore the flags at <c>WSALookupServiceNext</c> can never increase the
            amount of data returned beyond what was requested at <c>WSALookupServiceBegin</c>, although it is not an error to specify more
            or fewer flags. The flags specified at a given <c>WSALookupServiceNext</c> apply only to that call.
            </para>
            <para>
            The dwControlFlags LUP_FLUSHPREVIOUS and LUP_RES_SERVICE are exceptions to the combined restrictions rule (because they are
            behavior flags instead of restriction flags). If either of these flags are used in <c>WSALookupServiceNext</c> they have their
            defined effect regardless of the setting of the same flags at WSALookupServiceBegin.
            </para>
            <para>
            For example, if LUP_RETURN_VERSION is specified at WSALookupServiceBegin the service provider retrieves records including the
            version. If LUP_RETURN_VERSION is NOT specified at <c>WSALookupServiceNext</c>, the returned information does not include the
            version, even though it was available. No error is generated.
            </para>
            <para>
            Also for example, if LUP_RETURN_BLOB is NOT specified at WSALookupServiceBegin but is specified at <c>WSALookupServiceNext</c>,
            the returned information does not include the private data. No error is generated.
            </para>
            <para>
            If the <c>WSALookupServiceNext</c> function fails with an error of WSAEFAULT, this indicates that the buffer pointed to by the
            lpqsResults parameter was too small to contain the query results. A new buffer for a WSAQUERYSET should be provided with a size
            specified by the value pointed to by the lpdwBufferLength parameter. This new buffer for the <c>WSAQUERYSET</c> needs to have
            some of the members of the <c>WSAQUERYSET</c> specified before calling the <c>WSALookupServiceNext</c> function again. At a
            minimum, the <c>dwSize</c> member of the <c>WSAQUERYSET</c> must be set to the new size of the buffer.
            </para>
            <para>Query Results</para>
            <para>The following table describes how the query results are represented in the WSAQUERYSET structure.</para>
            <list type="table">
            <listheader>
            <term>WSAQUERYSET member</term>
            <term>Result interpretation</term>
            </listheader>
            <item>
            <term>dwSize</term>
            <term>Will be set to sizeof( WSAQUERYSET). This is used as a versioning mechanism.</term>
            </item>
            <item>
            <term>dwOutputFlags</term>
            <term>RESULT_IS_ALIAS flag indicates this is an alias result.</term>
            </item>
            <item>
            <term>lpszServiceInstanceName</term>
            <term>Referenced string contains service name.</term>
            </item>
            <item>
            <term>lpServiceClassId</term>
            <term>The GUID corresponding to the service class.</term>
            </item>
            <item>
            <term>lpVersion</term>
            <term>References version number of the particular service instance.</term>
            </item>
            <item>
            <term>lpszComment</term>
            <term>Optional comment string specified by service instance.</term>
            </item>
            <item>
            <term>dwNameSpace</term>
            <term>Namespace in which the service instance was found.</term>
            </item>
            <item>
            <term>lpNSProviderId</term>
            <term>Identifies the specific namespace provider that supplied this query result.</term>
            </item>
            <item>
            <term>lpszContext</term>
            <term>Specifies the context point in a hierarchical namespace at which the service is located.</term>
            </item>
            <item>
            <term>dwNumberOfProtocols</term>
            <term>Undefined for results.</term>
            </item>
            <item>
            <term>lpafpProtocols</term>
            <term>Undefined for results, all needed protocol information is in the CSADDR_INFO structures.</term>
            </item>
            <item>
            <term>lpszQueryString</term>
            <term>
            When dwControlFlags includes LUP_RETURN_QUERY_STRING, this parameter returns the unparsed remainder of the
            lpszServiceInstanceName specified in the original query. For example, in a namespace that identifies services by hierarchical
            names that specify a host name and a file path within that host, the address returned might be the host address and the unparsed
            remainder might be the file path. If the lpszServiceInstanceName is fully parsed and LUP_RETURN_QUERY_STRING is used, this
            parameter is NULL or points to a zero-length string.
            </term>
            </item>
            <item>
            <term>dwNumberOfCsAddrs</term>
            <term>Indicates the number of elements in the array of CSADDR_INFO structures.</term>
            </item>
            <item>
            <term>lpcsaBuffer</term>
            <term>A pointer to an array of CSADDR_INFO structures, with one complete transport address contained within each element.</term>
            </item>
            <item>
            <term>lpBlob</term>
            <term>(Optional) This is a pointer to a provider-specific entity.</term>
            </item>
            </list>
            <para>
            <c>Windows Phone 8:</c> The <c>WSALookupServiceNextW</c> function is supported for Windows Phone Store apps on Windows Phone 8
            and later.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>WSALookupServiceNextW</c> function is supported for Windows Store
            apps on Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSANSPIoctl(Vanara.PInvoke.HANDLE,System.UInt32,System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,System.UInt32@,System.IntPtr)">
            <summary>The Windows Sockets <c>WSANSPIoctl</c> function enables developers to make I/O control calls to a registered namespace.</summary>
            <param name="hLookup">The lookup handle returned from a previous call to the WSALookupServiceBegin function.</param>
            <param name="dwControlCode">
            <para>The control code of the operation to perform.</para>
            <para>The values that may be used for the dwControlCode parameter are determined by the namespace provider.</para>
            <para>
            The following value is supported by several Microsoft namespace providers including the Network Location Awareness (NS_NLA)
            namespace provider. This IOCTL is defined in the Winsock2.h header file.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SIO_NSP_NOTIFY_CHANGE</term>
            <term>
            This operation checks if the results returned with previous calls using the hLookup parameter are still valid. These previous
            calls include the initial call to the WSALookupServiceBegin function to retrieve the hLookup parameter. These previous calls may
            also include calls to the WSALookupServiceNext function using the hLookup parameter.
            </term>
            </item>
            </list>
            </param>
            <param name="lpvInBuffer">A pointer to the input buffer.</param>
            <param name="cbInBuffer">The size, in bytes, of the input buffer.</param>
            <param name="lpvOutBuffer">A pointer to the output buffer.</param>
            <param name="cbOutBuffer">The size, in bytes, of the output buffer.</param>
            <param name="lpcbBytesReturned">A pointer to the number of bytes returned.</param>
            <param name="lpCompletion">
            A pointer to a WSACOMPLETION structure, used for asynchronous processing. Set lpCompletion to <c>NULL</c> to force blocking
            (synchronous) execution.
            </param>
            <returns>
            <para>
            Success returns NO_ERROR. Failure returns SOCKET_ERROR, and a specific error code can be retrieved by calling the
            WSAGetLastError function. The following table describes the error codes.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>WSA_INVALID_HANDLE</term>
            <term>The hLookup parameter was not a valid query handle returned by WSALookupServiceBegin.</term>
            </item>
            <item>
            <term>WSA_IO_PENDING</term>
            <term>An overlapped operation was successfully initiated and completion will be indicated at a later time.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The lpvInBuffer, cbInBuffer, lpvOutBuffer, cbOutBuffer, or lpCompletion argument is not totally contained in a valid part of the
            user address space. Alternatively, the cbInBuffer or cbOutBuffer argument is too small, and the argument is modified to reflect
            the required allocation size.
            </term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            A supplied parameter is not acceptable, or the operation inappropriately returns results from multiple namespaces when it does
            not make sense for the specified operation.
            </term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>
            The operation is not supported. This error is returned if the namespace provider does not implement this function. This error
            can also be returned if the specified dwControlCode is an unrecognized command.
            </term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>
            The socket is not using overlapped I/O (asynchronous processing), yet the lpCompletion parameter is non-NULL. This error is used
            as a special notification for the SIO_NSP_NOTIFY_CHANGE IOCTL when the lpCompletion parameter is NULL (a poll) to indicate that
            a query set remains valid.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSANSPIoctl</c> function is used to set or retrieve operating parameters associated with a query handle to a namespace
            provider. The hLookup parameter is a handle to the namespace provider query previously returned by the WSALookupServiceBegin
            function (not a socket handle).
            </para>
            <para>
            Any IOCTL sent to a namespace provider may block indefinitely, depending upon the implementation of the namespace. If an
            application cannot tolerate blocking in a <c>WSANSPIoctl</c> function call, overlapped I/O should be used and the lpCompletion
            parameter should point to a WSACOMPLETION structure. To make a <c>WSANSPIoctl</c> function call nonblocking and return
            immediately, set the <c>Type</c> member of the <c>WSACOMPLETION</c> structure to <c>NSP_NOTIFY_IMMEDIATELY</c>.
            </para>
            <para>
            If lpCompletion is <c>NULL</c>, the <c>WSANSPIoctl</c> function executes as a blocking call. The namespace provider should
            return immediately and should not block. But each namespace is responsible for enforcing this behavior.
            </para>
            <para>The following IOCTL code is supported by several Microsoft name space provider:</para>
            <para>
            Immediate poll operations are usually much less expensive since they do not require a notification object. In most cases, this
            is implemented as a simple Boolean variable check. Asynchronous notification, however, may necessitate the creation of dedicated
            worker threads and/or inter-process communication channels, depending on the implementation of the namespace provider service,
            and will incur processing overhead related to the notification object involved with signaling the change event.
            </para>
            <para>
            To cancel an asynchronous notification request, end the original query with a WSALookupServiceEnd function call on the affected
            query handle. Canceling the asynchronous notification for LUP_NOTIFY_HWND will not post any message, however, an overlapped
            operation will be completed and notification will be delivered with the error WSA_OPERATION_ABORTED.
            </para>
            <para>
            <c>Note</c> All I/O initiated by a given thread is canceled when that thread exits. For overlapped sockets, pending asynchronous
            operations can fail if the thread is closed before the operations complete. See ExitThread for more information.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSANtohl(Vanara.PInvoke.Ws2_32.SOCKET,System.UInt32,System.UInt32@)">
            <summary>The <c>WSANtohl</c> function converts a <c>u_long</c> from network byte order to host byte order.</summary>
            <param name="s">A descriptor identifying a socket.</param>
            <param name="netlong">A 32-bit number in network byte order.</param>
            <param name="lphostlong">A pointer to a 32-bit number to receive the number in host byte order.</param>
            <returns>
            <para>
            If no error occurs, <c>WSANtohl</c> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can
            be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The lphostlong parameter is NULL or the address pointed to is not completely contained in a valid part of the user address space.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSANtohl</c> function takes a 32-bit number in network byte order and returns a 32-bit number in host byte order in the
            32-bit number pointed to by the lphostlong parameter. The socket passed in the s parameter is used to determine the network byte
            order required based on the Winsock catalog protocol entry associated with the socket. This feature supports Winsock providers
            that use different network byte orders.
            </para>
            <para>
            If the socket is for the AF_INET or AF_INET6 address family, the <c>WSANtohl</c> function can be used to convert an IPv4 address
            in network byte order to the IPv4 address in host byte order. This function does not do any checking to determine if the netlong
            parameter is a valid IPv4 address.
            </para>
            <para>
            The <c>WSANtohl</c> function requires that the Winsock DLL has previously been loaded with a successful call to the WSAStartup
            function. For use with the AF_INET or AF_INET6 family, the ntohl function does not require that the Winsock DLL be loaded.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSANtohs(Vanara.PInvoke.Ws2_32.SOCKET,System.UInt16,System.UInt16@)">
            <summary>The <c>WSANtohs</c> function converts a <c>u_short</c> from network byte order to host byte order.</summary>
            <param name="s">A descriptor identifying a socket.</param>
            <param name="netshort">A 16-bit number in network byte order.</param>
            <param name="lphostshort">A pointer to a 16-bit number to receive the number in host byte order.</param>
            <returns>
            <para>
            If no error occurs, <c>WSANtohs</c> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can
            be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The lphostshort parameter is NULL or the address pointed to is not completely contained in a valid part of the user address space.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSANtohs</c> function takes a 16-bit number in network byte order and returns a 16-bit number in host byte order in the
            16-bit number pointed to by the lphostshort parameter. The socket passed in the s parameter is used to determine the network
            byte order required based on the Winsock catalog protocol entry associated with the socket. This feature supports Winsock
            providers that use different network byte orders.
            </para>
            <para>
            If the socket is for the AF_INET or AF_INET6 address family, the <c>WSANtohs</c> function can be used to convert an IP port
            number in network byte order to the IP port number in host byte order.
            </para>
            <para>
            The <c>WSANtohs</c> function requires that the Winsock DLL has previously been loaded with a successful call to the WSAStartup
            function. For use with the AF_INET OR AF_INET6 address family, the ntohsfunction does not require that the Winsock DLL be loaded.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAPoll(Vanara.PInvoke.Ws2_32.WSAPOLLFD[],System.UInt32,System.Int32)">
            <summary>The <c>WSAPoll</c> function determines status of one or more sockets.</summary>
            <param name="fdArray">
            An array of one or more <c>POLLFD</c> structures specifying the set of sockets for which status is requested. The array must
            contain at least one structure with a valid socket. Upon return, this parameter receives the updated sockets with the
            <c>revents</c> status flags member set on each one that matches the status query criteria.
            </param>
            <param name="fds">
            The number of <c>WSAPOLLFD</c> structures in fdarray. This is not necessarily the number of sockets for which status is requested.
            </param>
            <param name="timeout">
            <para>A value that specifies the wait behavior, based on the following values.</para>
            <list type="table">
            <listheader>
            <term>Return value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>Greater than zero</term>
            <term>The time, in milliseconds, to wait.</term>
            </item>
            <item>
            <term>Zero</term>
            <term>Return immediately.</term>
            </item>
            <item>
            <term>Less than zero</term>
            <term>Wait indefinitely.</term>
            </item>
            </list>
            </param>
            <returns>
            <para>Returns one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>Zero</term>
            <term>No sockets were in the queried state before the timer expired.</term>
            </item>
            <item>
            <term>Greater than zero</term>
            <term>The number of elements in fdarray for which an revents member of the POLLFD structure is nonzero.</term>
            </item>
            <item>
            <term>SOCKET_ERROR</term>
            <term>An error occurred. Call the WSAGetLastError function to retrieve the extended error code.</term>
            </item>
            </list>
            <list type="table">
            <listheader>
            <term>Extended Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>An exception occurred while reading user input parameters.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            An invalid parameter was passed. This error is returned if the
            [WSAPOLLFD](/windows/win32/api/winsock2/ns-winsock2-wsapollfd)a&gt; structures pointed to by the fdarray parameter when
            requesting socket status. This error is also returned if none of the sockets specified in the fd member of any of the WSAPOLLFD
            structures pointed to by the fdarray parameter were valid.
            </term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>The function was unable to allocate sufficient memory.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>WSAPoll</c> function is defined on Windows Vista and later.</para>
            <para>
            The WSAPOLLFD structures. An application sets the appropriate flags in the <c>events</c> member of the <c>WSAPOLLFD</c>
            structure to specify the type of status requested for each corresponding socket. The <c>WSAPoll</c> function returns the status
            of a socket in the <c>revents</c> member of the <c>WSAPOLLFD</c> structure.
            </para>
            <para>
            For each socket, a caller can request information on read or write status. Error conditions are always returned, so information
            on them need not be requested.
            </para>
            <para>
            The WSAPOLLFD structure pointed to by the fdarray parameter. All sockets that do not meet these criteria and have no error
            condition will have the corresponding <c>revents</c> member set to 0.
            </para>
            <para>
            A combination of the following flags can be set in the WSAPOLLFD structure for a given socket when requesting status for that socket:
            </para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>POLLPRI</term>
            <term>Priority data may be read without blocking. This flag is not supported by the Microsoft Winsock provider.</term>
            </item>
            <item>
            <term>POLLRDBAND</term>
            <term>Priority band (out-of-band) data may be read without blocking.</term>
            </item>
            <item>
            <term>POLLRDNORM</term>
            <term>Normal data may be read without blocking.</term>
            </item>
            <item>
            <term>POLLWRNORM</term>
            <term>Normal data may be written without blocking.</term>
            </item>
            </list>
            <para>
            The <c>POLLIN</c> flag is defined as the combination of the <c>POLLRDNORM</c> and <c>POLLRDBAND</c> flag values. The
            <c>POLLOUT</c> flag is defined as the same as the <c>POLLWRNORM</c> flag value.
            </para>
            <para>
            The WSAPOLLFD structure must only contain a combination of the above flags that are supported by the Winsock provider. Any other
            values are considered errors and <c>WSAPoll</c> will return <c>SOCKET_ERROR</c>. A subsequent call to the WSAGetLastError
            function will retrieve the extended error code of WSAEINVAL. If the <c>POLLPRI</c> flag is set on a socket for the Microsoft
            Winsock provider, the <c>WSAPoll</c> function will fail.
            </para>
            <para>When the WSAPOLLFD structures pointed to by the fdarray parameter to indicate socket status:</para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>POLLERR</term>
            <term>An error has occurred.</term>
            </item>
            <item>
            <term>POLLHUP</term>
            <term>A stream-oriented connection was either disconnected or aborted.</term>
            </item>
            <item>
            <term>POLLNVAL</term>
            <term>An invalid socket was used.</term>
            </item>
            <item>
            <term>POLLPRI</term>
            <term>Priority data may be read without blocking. This flag is not returned by the Microsoft Winsock provider.</term>
            </item>
            <item>
            <term>POLLRDBAND</term>
            <term>Priority band (out-of-band) data may be read without blocking.</term>
            </item>
            <item>
            <term>POLLRDNORM</term>
            <term>Normal data may be read without blocking.</term>
            </item>
            <item>
            <term>POLLWRNORM</term>
            <term>Normal data may be written without blocking.</term>
            </item>
            </list>
            <para>With regard to TCP and UDP sockets:</para>
            <list type="bullet"/>
            <para>
            The number of elements (not sockets) in fdarray is indicated by nfds. Members of fdarray which have their <c>fd</c> member set
            to a negative value are ignored and their <c>revents</c> will be set to <c>POLLNVAL</c> upon return. This behavior is useful to
            an application which maintains a fixed fdarray allocation and will not compact the array to remove unused entries or to
            reallocate memory. It is not necessary to clear <c>revents</c> for any element prior to calling <c>WSAPoll</c>.
            </para>
            <para>
            The timeout argument specifies how long the function is to wait before returning. A positive value contains the number of
            milliseconds to wait before returning. A zero value forces <c>WSAPoll</c> to return immediately, and a negative value indicates
            that <c>WSAPoll</c> should wait indefinitely.
            </para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>WSAPoll</c> with the timeout parameter set to a negative number,
            Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation,
            which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock
            call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and
            must never be attempted by Winsock clients.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAProviderConfigChange(Vanara.PInvoke.HANDLE@,System.IntPtr,Vanara.PInvoke.Ws2_32.LPWSAOVERLAPPED_COMPLETION_ROUTINE)">
            <summary>The <c>WSAProviderConfigChange</c> function notifies the application when the provider configuration is changed.</summary>
            <param name="lpNotificationHandle">
            Pointer to notification handle. If the notification handle is set to <c>NULL</c> (the handle value not the pointer itself), this
            function returns a notification handle in the location pointed to by lpNotificationHandle.
            </param>
            <param name="lpOverlapped">Pointer to a WSAOVERLAPPED structure.</param>
            <param name="lpCompletionRoutine">Pointer to the completion routine called when the provider change notification is received.</param>
            <returns>
            <para>
            If no error occurs the <c>WSAProviderConfigChange</c> returns 0. Otherwise, a value of SOCKET_ERROR is returned and a specific
            error code may be retrieved by calling WSAGetLastError. The error code WSA_IO_PENDING indicates that the overlapped operation
            has been successfully initiated and that completion (and thus change event) will be indicated at a later time.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>Not enough free memory available to complete the operation.</term>
            </item>
            <item>
            <term>WSA_INVALID_HANDLE</term>
            <term>Value pointed by lpNotificationHandle parameter is not a valid notification handle.</term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>Current operating system environment does not support provider installation or removal without restart.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAProviderConfigChange</c> function notifies the application of provider (both transport and namespace) installation or
            removal in Windows operating environments that support such configuration change without requiring a restart. When called for
            the first time (lpNotificationHandle parameter points to <c>NULL</c> handle), this function completes immediately and returns
            notification handle in the location pointed by lpNotificationHandle that can be used in subsequent calls to receive
            notifications of provider installation and removal. The second and any subsequent calls only complete when provider information
            changes since the time the call was made It is expected (but not required) that the application uses overlapped I/O on second
            and subsequent calls to <c>WSAProviderConfigChange</c>, in which case the call will return immediately and application will be
            notified of provider configuration changes using the completion mechanism chosen through specified overlapped completion parameters.
            </para>
            <para>
            Notification handle returned by <c>WSAProviderConfigChange</c> is like any regular operating system handle that should be closed
            (when no longer needed) using Windows CloseHandle call.
            </para>
            <para>
            The following sequence of actions can be used to guarantee that application always has current protocol configuration information:
            </para>
            <list type="bullet">
            <item>
            <term>Call <c>WSAProviderConfigChange</c></term>
            </item>
            <item>
            <term>Call WSAEnumProtocols and/or WSAEnumNameSpaceProviders</term>
            </item>
            <item>
            <term>
            Whenever <c>WSAProviderConfigChange</c> notifies application of provider configuration change (through blocking or overlapped
            I/O), the whole sequence of actions should be repeated.
            </term>
            </item>
            </list>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSARecv(Vanara.PInvoke.Ws2_32.SOCKET,System.IntPtr,System.UInt32,System.UInt32@,Vanara.PInvoke.Ws2_32.MsgFlags@,System.IntPtr,Vanara.PInvoke.Ws2_32.LPWSAOVERLAPPED_COMPLETION_ROUTINE)">
            <summary>The <c>WSARecv</c> function receives data from a connected socket or a bound connectionless socket.</summary>
            <param name="s">A descriptor identifying a connected socket.</param>
            <param name="lpBuffers">
            A pointer to an array of WSABUF structures. Each <c>WSABUF</c> structure contains a pointer to a buffer and the length, in
            bytes, of the buffer.
            </param>
            <param name="dwBufferCount">The number of WSABUF structures in the lpBuffers array.</param>
            <param name="lpNumberOfBytesRecvd">
            <para>A pointer to the number, in bytes, of data received by this call if the receive operation completes immediately.</para>
            <para>
            Use <c>NULL</c> for this parameter if the lpOverlapped parameter is not <c>NULL</c> to avoid potentially erroneous results. This
            parameter can be <c>NULL</c> only if the lpOverlapped parameter is not <c>NULL</c>.
            </para>
            </param>
            <param name="lpFlags">
            A pointer to flags used to modify the behavior of the <c>WSARecv</c> function call. For more information, see the Remarks section.
            </param>
            <param name="lpOverlapped">A pointer to a WSAOVERLAPPED structure (ignored for nonoverlapped sockets).</param>
            <param name="lpCompletionRoutine">
            A pointer to the completion routine called when the receive operation has been completed (ignored for nonoverlapped sockets).
            </param>
            <returns>
            <para>
            If no error occurs and the receive operation has completed immediately, <c>WSARecv</c> returns zero. In this case, the
            completion routine will have already been scheduled to be called once the calling thread is in the alertable state. Otherwise, a
            value of <c>SOCKET_ERROR</c> is returned, and a specific error code can be retrieved by calling WSAGetLastError. The error code
            WSA_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion will be indicated at
            a later time. Any other error code indicates that the overlapped operation was not successfully initiated and no completion
            indication will occur.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAECONNABORTED</term>
            <term>The virtual circuit was terminated due to a time-out or other failure.</term>
            </item>
            <item>
            <term>WSAECONNRESET</term>
            <term>
            For a stream socket, the virtual circuit was reset by the remote side. The application should close the socket as it is no
            longer usable. For a UDP datagram socket, this error would indicate that a previous send operation resulted in an ICMP "Port
            Unreachable" message.
            </term>
            </item>
            <item>
            <term>WSAEDISCON</term>
            <term>Socket s is message oriented and the virtual circuit was gracefully closed by the remote side.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The lpBuffers parameter is not completely contained in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>The (blocking) call was canceled by the WSACancelBlockingCall function.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>The socket has not been bound (for example, with bind).</term>
            </item>
            <item>
            <term>WSAEMSGSIZE</term>
            <term>
            The message was too large to fit into the specified buffer and (for unreliable protocols only) any trailing portion of the
            message that did not fit into the buffer has been discarded.
            </term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENETRESET</term>
            <term>
            For a connection-oriented socket, this error indicates that the connection has been broken due to keep-alive activity that
            detected a failure while the operation was in progress. For a datagram socket, this error indicates that the time to live has expired.
            </term>
            </item>
            <item>
            <term>WSAENOTCONN</term>
            <term>The socket is not connected.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>
            MSG_OOB was specified, but the socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the
            communication domain associated with this socket, or the socket is unidirectional and supports only send operations.
            </term>
            </item>
            <item>
            <term>WSAESHUTDOWN</term>
            <term>
            The socket has been shut down; it is not possible to call WSARecv on a socket after shutdown has been invoked with how set to
            SD_RECEIVE or SD_BOTH.
            </term>
            </item>
            <item>
            <term>WSAETIMEDOUT</term>
            <term>The connection has been dropped because of a network failure or because the peer system failed to respond.</term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>
            Windows NT: Overlapped sockets: there are too many outstanding overlapped I/O requests. Nonoverlapped sockets: The socket is
            marked as nonblocking and the receive operation cannot be completed immediately.
            </term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSA_IO_PENDING</term>
            <term>An overlapped operation was successfully initiated and completion will be indicated at a later time.</term>
            </item>
            <item>
            <term>WSA_OPERATION_ABORTED</term>
            <term>The overlapped operation has been canceled due to the closure of the socket.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSARecv</c> function provides some additional features compared with the standard recv function in three important areas:
            </para>
            <list type="bullet">
            <item>
            <term>It can be used in conjunction with overlapped sockets to perform overlapped recv operations.</term>
            </item>
            <item>
            <term>It allows multiple receive buffers to be specified making it applicable to the scatter/gather type of I/O.</term>
            </item>
            <item>
            <term>
            The lpFlags parameter is used both on input and returned on output, allowing applications to sense the output state of the
            <c>MSG_PARTIAL</c> flag bit. However, the <c>MSG_PARTIAL</c> flag bit is not supported by all protocols.
            </term>
            </item>
            </list>
            <para>
            The <c>WSARecv</c> function is used on connected sockets or bound connectionless sockets specified by the s parameter and is
            used to read incoming data. The socket's local address must be known. For server applications, this is usually done explicitly
            through bind or implicitly through accept or WSAAccept. Explicit binding is discouraged for client applications. For client
            applications the socket can become bound implicitly to a local address through connect, WSAConnect, sendto, WSASendTo, or WSAJoinLeaf.
            </para>
            <para>
            For connected, connectionless sockets, this function restricts the addresses from which received messages are accepted. The
            function only returns messages from the remote address specified in the connection. Messages from other addresses are (silently) discarded.
            </para>
            <para>
            For overlapped sockets, <c>WSARecv</c> is used to post one or more buffers into which incoming data will be placed as it becomes
            available, after which the application-specified completion indication (invocation of the completion routine or setting of an
            event object) occurs. If the operation does not complete immediately, the final completion status is retrieved through the
            completion routine or WSAGetOverlappedResult.
            </para>
            <para>
            <c>Note</c> All I/O initiated by a given thread is canceled when that thread exits. For overlapped sockets, pending asynchronous
            operations can fail if the thread is closed before the operations complete. See ExitThread for more information.
            </para>
            <para>
            If both lpOverlapped and lpCompletionRoutine are <c>NULL</c>, the socket in this function will be treated as a nonoverlapped socket.
            </para>
            <para>
            For nonoverlapped sockets, the blocking semantics are identical to that of the standard recv function and the lpOverlapped and
            lpCompletionRoutine parameters are ignored. Any data that has already been received and buffered by the transport will be copied
            into the specified user buffers. In the case of a blocking socket with no data currently having been received and buffered by
            the transport, the call will block until data is received. Windows Sockets 2 does not define any standard blocking time-out
            mechanism for this function. For protocols acting as byte-stream protocols the stack tries to return as much data as possible
            subject to the available buffer space and amount of received data available. However, receipt of a single byte is sufficient to
            unblock the caller. There is no guarantee that more than a single byte will be returned. For protocols acting as
            message-oriented, a full message is required to unblock the caller.
            </para>
            <para><c>Note</c> The socket options <c>SO_RCVTIMEO</c> and <c>SO_SNDTIMEO</c> apply only to blocking sockets.</para>
            <para>
            Whether or not a protocol is acting as byte stream is determined by the setting of XP1_MESSAGE_ORIENTED and XP1_PSEUDO_STREAM in
            its WSAPROTOCOL_INFO structure and the setting of the MSG_PARTIAL flag passed in to this function (for protocols that support
            it). The following table lists relevant combinations, (an asterisk (*) indicates that the setting of this bit does not matter in
            this case).
            </para>
            <list type="table">
            <listheader>
            <term>XP1_MESSAGE_ORIENTED</term>
            <term>XP1_PSEUDO_STREAM</term>
            <term>MSG_PARTIAL</term>
            <term>Acts as</term>
            </listheader>
            <item>
            <term>not set</term>
            <term>*</term>
            <term>*</term>
            <term>Byte stream</term>
            </item>
            <item>
            <term>*</term>
            <term>Set</term>
            <term>*</term>
            <term>Byte stream</term>
            </item>
            <item>
            <term>set</term>
            <term>Not set</term>
            <term>set</term>
            <term>Byte stream</term>
            </item>
            <item>
            <term>set</term>
            <term>Not set</term>
            <term>not set</term>
            <term>Message oriented</term>
            </item>
            </list>
            <para>
            The buffers are filled in the order in which they appear in the array pointed to by lpBuffers, and the buffers are packed so
            that no holes are created.
            </para>
            <para>
            If this function is completed in an overlapped manner, it is the Winsock service provider's responsibility to capture the WSABUF
            structures before returning from this call. This enables applications to build stack-based <c>WSABUF</c> arrays pointed to by
            the lpBuffers parameter.
            </para>
            <para>
            For byte stream-style sockets (for example, type <c>SOCK_STREAM</c>), incoming data is placed into the buffers until the buffers
            are filled, the connection is closed, or the internally buffered data is exhausted. Regardless of whether or not the incoming
            data fills all the buffers, the completion indication occurs for overlapped sockets.
            </para>
            <para>
            For message-oriented sockets (for example, type <c>SOCK_DGRAM</c>), an incoming message is placed into the buffers up to the
            total size of the buffers, and the completion indication occurs for overlapped sockets. If the message is larger than the
            buffers, the buffers are filled with the first part of the message. If the <c>MSG_PARTIAL</c> feature is supported by the
            underlying service provider, the <c>MSG_PARTIAL</c> flag is set in lpFlags and subsequent receive operations will retrieve the
            rest of the message. If <c>MSG_PARTIAL</c> is not supported but the protocol is reliable, <c>WSARecv</c> generates the error
            WSAEMSGSIZE and a subsequent receive operation with a larger buffer can be used to retrieve the entire message. Otherwise, (that
            is, the protocol is unreliable and does not support <c>MSG_PARTIAL</c>), the excess data is lost, and <c>WSARecv</c> generates
            the error WSAEMSGSIZE.
            </para>
            <para>
            For connection-oriented sockets, <c>WSARecv</c> can indicate the graceful termination of the virtual circuit in one of two ways
            that depend on whether the socket is byte stream or message oriented. For byte streams, zero bytes having been read (as
            indicated by a zero return value to indicate success, and lpNumberOfBytesRecvd value of zero) indicates graceful closure and
            that no more bytes will ever be read. For message-oriented sockets, where a zero byte message is often allowable, a failure with
            an error code of WSAEDISCON is used to indicate graceful closure. In any case a return error code of WSAECONNRESET indicates an
            abortive close has occurred.
            </para>
            <para>
            The lpFlags parameter can be used to influence the behavior of the function invocation beyond the options specified for the
            associated socket. That is, the semantics of this function are determined by the socket options and the lpFlags parameter. The
            latter is constructed by using the bitwise OR operator with any of the values listed in the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MSG_PEEK</term>
            <term>
            Peeks at the incoming data. The data is copied into the buffer, but is not removed from the input queue. This flag is valid only
            for nonoverlapped sockets.
            </term>
            </item>
            <item>
            <term>MSG_OOB</term>
            <term>Processes OOB data.</term>
            </item>
            <item>
            <term>MSG_PARTIAL</term>
            <term>
            This flag is for message-oriented sockets only. On output, this flag indicates that the data specified is a portion of the
            message transmitted by the sender. Remaining portions of the message will be specified in subsequent receive operations. A
            subsequent receive operation with the MSG_PARTIAL flag cleared indicates end of sender's message. As an input parameter, this
            flag indicates that the receive operation should complete even if only part of a message has been received by the transport provider.
            </term>
            </item>
            <item>
            <term>MSG_PUSH_IMMEDIATE</term>
            <term>
            This flag is for stream-oriented sockets only. This flag allows an application that uses stream sockets to tell the transport
            provider not to delay completion of partially filled pending receive requests. This is a hint to the transport provider that the
            application is willing to receive any incoming data as soon as possible without necessarily waiting for the remainder of the
            data that might still be in transit. What constitutes a partially filled pending receive request is a transport-specific matter.
            In the case of TCP, this refers to the case of incoming TCP segments being placed into the receive request data buffer where
            none of the TCP segments indicated a PUSH bit value of 1. In this case, TCP may hold the partially filled receive request a
            little longer to allow the remainder of the data to arrive with a TCP segment that has the PUSH bit set to 1. This flag tells
            TCP not to hold the receive request but to complete it immediately. Using this flag for large block transfers is not recommended
            since processing partial blocks is often not optimal. This flag is useful only for cases where receiving and processing the
            partial data immediately helps decrease processing latency. This flag is a hint rather than an actual guarantee. This flag is
            supported on Windows 8.1, Windows Server 2012 R2, and later.
            </term>
            </item>
            <item>
            <term>MSG_WAITALL</term>
            <term>
            The receive request will complete only when one of the following events occurs: Be aware that if the underlying transport
            provider does not support MSG_WAITALL, or if the socket is in a non-blocking mode, then this call will fail with WSAEOPNOTSUPP.
            Also, if MSG_WAITALL is specified along with MSG_OOB, MSG_PEEK, or MSG_PARTIAL, then this call will fail with WSAEOPNOTSUPP.
            This flag is not supported on datagram sockets or message-oriented sockets.
            </term>
            </item>
            </list>
            <para>
            For message-oriented sockets, the <c>MSG_PARTIAL</c> bit is set in the lpFlags parameter if a partial message is received. If a
            complete message is received, <c>MSG_PARTIAL</c> is cleared in lpFlags. In the case of delayed completion, the value pointed to
            by lpFlags is not updated. When completion has been indicated, the application should call WSAGetOverlappedResult and examine
            the flags indicated by the lpdwFlags parameter.
            </para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>WSARecv</c> with the lpOverlapped parameter set to NULL, Winsock may
            need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can
            be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call
            inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must
            never be attempted by Winsock clients.
            </para>
            <para>Overlapped Socket I/O</para>
            <para>
            If an overlapped operation completes immediately, <c>WSARecv</c> returns a value of zero and the lpNumberOfBytesRecvd parameter
            is updated with the number of bytes received and the flag bits indicated by the lpFlags parameter are also updated. If the
            overlapped operation is successfully initiated and will complete later, <c>WSARecv</c> returns <c>SOCKET_ERROR</c> and indicates
            error code WSA_IO_PENDING. In this case, lpNumberOfBytesRecvd and lpFlags are not updated. When the overlapped operation
            completes, the amount of data transferred is indicated either through the cbTransferred parameter in the completion routine (if
            specified), or through the lpcbTransfer parameter in WSAGetOverlappedResult. Flag values are obtained by examining the lpdwFlags
            parameter of <c>WSAGetOverlappedResult</c>.
            </para>
            <para>
            The <c>WSARecv</c> function using overlapped I/O can be called from within the completion routine of a previous <c>WSARecv</c>,
            WSARecvFrom, WSASend or WSASendTo function. For a given socket, I/O completion routines will not be nested. This permits
            time-sensitive data transmissions to occur entirely within a preemptive context.
            </para>
            <para>
            The lpOverlapped parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are
            simultaneously outstanding, each must reference a separate WSAOVERLAPPED structure.
            </para>
            <para>
            If the lpCompletionRoutine parameter is <c>NULL</c>, the hEvent parameter of lpOverlapped is signaled when the overlapped
            operation completes if it contains a valid event object handle. An application can use WSAWaitForMultipleEvents or
            WSAGetOverlappedResult to wait or poll on the event object.
            </para>
            <para>
            If lpCompletionRoutine is not <c>NULL</c>, the hEvent parameter is ignored and can be used by the application to pass context
            information to the completion routine. A caller that passes a non- <c>NULL</c> lpCompletionRoutine and later calls
            WSAGetOverlappedResult for the same overlapped I/O request may not set the fWait parameter for that invocation of
            <c>WSAGetOverlappedResult</c> to <c>TRUE</c>. In this case the usage of the hEvent parameter is undefined, and attempting to
            wait on the hEvent parameter would produce unpredictable results.
            </para>
            <para>
            The completion routine follows the same rules as stipulated for Windows file I/O completion routines. The completion routine
            will not be invoked until the thread is in an alertable wait state such as can occur when the function WSAWaitForMultipleEvents
            with the fAlertable parameter set to <c>TRUE</c> is invoked.
            </para>
            <para>The prototype of the completion routine is as follows:</para>
            <para>
            CompletionRoutine is a placeholder for an application-defined or library-defined function name. The dwError specifies the
            completion status for the overlapped operation as indicated by lpOverlapped. The cbTransferred parameter specifies the number of
            bytes received. The dwFlags parameter contains information that would have appeared in lpFlags if the receive operation had
            completed immediately. This function does not return a value.
            </para>
            <para>
            Returning from this function allows invocation of another pending completion routine for this socket. When using
            WSAWaitForMultipleEvents, all waiting completion routines are called before the alertable thread's wait is satisfied with a
            return code of <c>WSA_IO_COMPLETION</c>. The completion routines can be called in any order, not necessarily in the same order
            the overlapped operations are completed. However, the posted buffers are guaranteed to be filled in the same order in which they
            are specified.
            </para>
            <para>
            If you are using I/O completion ports, be aware that the order of calls made to <c>WSARecv</c> is also the order in which the
            buffers are populated. <c>WSARecv</c> should not be called on the same socket simultaneously from different threads, because it
            can result in an unpredictable buffer order.
            </para>
            <para>Example Code</para>
            <para>The following example shows how to use the <c>WSARecv</c> function in overlapped I/O mode.</para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSARecvDisconnect(Vanara.PInvoke.Ws2_32.SOCKET,System.IntPtr)">
            <summary>
            The <c>WSARecvDisconnect</c> function terminates reception on a socket, and retrieves the disconnect data if the socket is
            connection oriented.
            </summary>
            <param name="s">A descriptor identifying a socket.</param>
            <param name="lpInboundDisconnectData">A pointer to the incoming disconnect data.</param>
            <returns>
            <para>
            If no error occurs, <c>WSARecvDisconnect</c> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error
            code can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The buffer referenced by the parameter lpInboundDisconnectData is too small.</term>
            </item>
            <item>
            <term>WSAENOPROTOOPT</term>
            <term>
            The disconnect data is not supported by the indicated protocol family. Note that implementations of TCP/IP that do not support
            disconnect data are not required to return the WSAENOPROTOOPT error code. See the remarks section for information about the
            Microsoft implementation of TCP/IP.
            </term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAENOTCONN</term>
            <term>The socket is not connected (connection-oriented sockets only).</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSARecvDisconnect</c> function is used on connection-oriented sockets to disable reception and retrieve any incoming
            disconnect data from the remote party. This is equivalent to a shutdown (SD_RECEIVE), except that <c>WSARecvDisconnect</c> also
            allows receipt of disconnect data (in protocols that support it).
            </para>
            <para>
            After this function has been successfully issued, subsequent receives on the socket will be disallowed. Calling
            <c>WSARecvDisconnect</c> has no effect on the lower protocol layers. For TCP sockets, if there is still data queued on the
            socket waiting to be received, or data arrives subsequently, the connection is reset, since the data cannot be delivered to the
            user. For UDP, incoming datagrams are accepted and queued. In no case will an ICMP error packet be generated.
            </para>
            <para>
            <c>Note</c> The native implementation of TCP/IP on Windows does not support disconnect data. Disconnect data is only supported
            with Windows Sockets providers that have the XP1_DISCONNECT_DATA flag in their WSAPROTOCOL_INFO structure. Use the
            WSAEnumProtocols function to obtain <c>WSAPROTOCOL_INFO</c> structures for all installed providers.
            </para>
            <para>
            To successfully receive incoming disconnect data, an application must use other mechanisms to determine that the circuit has
            been closed. For example, an application needs to receive an FD_CLOSE notification, to receive a zero return value, or to
            receive a WSAEDISCON or WSAECONNRESET error code from recv/WSARecv.
            </para>
            <para>
            The <c>WSARecvDisconnect</c> function does not close the socket, and resources attached to the socket will not be freed until
            closesocket is invoked.
            </para>
            <para>The <c>WSARecvDisconnect</c> function does not block regardless of the SO_LINGER setting on the socket.</para>
            <para>
            An application should not rely on being able to reuse a socket after it has been disconnected using <c>WSARecvDisconnect</c>. In
            particular, a Windows Sockets provider is not required to support the use of connect or WSAConnect on such a socket.
            </para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>WSARecvDisconnect</c>, Winsock may need to wait for a network event
            before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous
            procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an
            ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSARecvFrom(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.WSABUF[],System.UInt32,System.UInt32@,Vanara.PInvoke.Ws2_32.MsgFlags@,Vanara.PInvoke.Ws2_32.SOCKADDR,System.Int32@,System.IntPtr,Vanara.PInvoke.Ws2_32.LPWSAOVERLAPPED_COMPLETION_ROUTINE)">
            <summary>The <c>WSARecvFrom</c> function receives a datagram and stores the source address.</summary>
            <param name="s">A descriptor identifying a socket.</param>
            <param name="lpBuffers">
            A pointer to an array of WSABUF structures. Each <c>WSABUF</c> structure contains a pointer to a buffer and the length of the buffer.
            </param>
            <param name="dwBufferCount">The number of WSABUF structures in the lpBuffers array.</param>
            <param name="lpNumberOfBytesRecvd">
            <para>A pointer to the number of bytes received by this call if the <c>WSARecvFrom</c> operation completes immediately.</para>
            <para>
            Use <c>NULL</c> for this parameter if the lpOverlapped parameter is not <c>NULL</c> to avoid potentially erroneous results. This
            parameter can be <c>NULL</c> only if the lpOverlapped parameter is not <c>NULL</c>.
            </para>
            </param>
            <param name="lpFlags">A pointer to flags used to modify the behavior of the <c>WSARecvFrom</c> function call. See remarks below.</param>
            <param name="lpFrom">
            An optional pointer to a buffer that will hold the source address upon the completion of the overlapped operation.
            </param>
            <param name="lpFromlen">A pointer to the size, in bytes, of the "from" buffer required only if lpFrom is specified.</param>
            <param name="lpOverlapped">A pointer to a WSAOVERLAPPED structure (ignored for nonoverlapped sockets).</param>
            <param name="lpCompletionRoutine">
            A pointer to the completion routine called when the <c>WSARecvFrom</c> operation has been completed (ignored for nonoverlapped sockets).
            </param>
            <returns>
            <para>
            If no error occurs and the receive operation has completed immediately, <c>WSARecvFrom</c> returns zero. In this case, the
            completion routine will have already been scheduled to be called once the calling thread is in the alertable state. Otherwise, a
            value of <c>SOCKET_ERROR</c> is returned, and a specific error code can be retrieved by calling WSAGetLastError. The error code
            <c>WSA_IO_PENDING</c> indicates that the overlapped operation has been successfully initiated and that completion will be
            indicated at a later time. Any other error code indicates that the overlapped operation was not successfully initiated and no
            completion indication will occur.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAECONNRESET</term>
            <term>
            The virtual circuit was reset by the remote side executing a hard or abortive close. The application should close the socket as
            it is no longer usable. For a UPD datagram socket, this error would indicate that a previous send operation resulted in an ICMP
            "Port Unreachable" message.
            </term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The lpBuffers, lpFlags, lpFrom, lpNumberOfBytesRecvd, lpFromlen, lpOverlapped, or lpCompletionRoutine parameter is not totally
            contained in a valid part of the user address space: the lpFrom buffer was too small to accommodate the peer address.
            </term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>A blocking Windows Socket 1.1 call was canceled through WSACancelBlockingCall.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>The socket has not been bound (with bind, for example).</term>
            </item>
            <item>
            <term>WSAEMSGSIZE</term>
            <term>
            The message was too large for the specified buffer and (for unreliable protocols only) any trailing portion of the message that
            did not fit into the buffer has been discarded.
            </term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENETRESET</term>
            <term>For a datagram socket, this error indicates that the time to live has expired.</term>
            </item>
            <item>
            <term>WSAENOTCONN</term>
            <term>The socket is not connected (connection-oriented sockets only).</term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>
            Windows NT: Overlapped sockets: There are too many outstanding overlapped I/O requests. Nonoverlapped sockets: The socket is
            marked as nonblocking and the receive operation cannot be completed immediately.
            </term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSA_IO_PENDING</term>
            <term>An overlapped operation was successfully initiated and completion will be indicated later.</term>
            </item>
            <item>
            <term>WSA_OPERATION_ABORTED</term>
            <term>The overlapped operation has been canceled due to the closure of the socket.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSARecvFrom</c> function provides functionality over and above the standard recvfrom function in three important areas:
            </para>
            <list type="bullet">
            <item>
            <term>It can be used in conjunction with overlapped sockets to perform overlapped receive operations.</term>
            </item>
            <item>
            <term>It allows multiple receive buffers to be specified making it applicable to the scatter/gather type of I/O.</term>
            </item>
            <item>
            <term>
            The lpFlags parameter is both an input and an output parameter, allowing applications to sense the output state of the
            <c>MSG_PARTIAL</c> flag bit. Be aware that the <c>MSG_PARTIAL</c> flag bit is not supported by all protocols.
            </term>
            </item>
            </list>
            <para>
            The <c>WSARecvFrom</c> function is used primarily on a connectionless socket specified by s. The socket's local address must be
            known. For server applications, this is usually done explicitly through bind. Explicit binding is discouraged for client
            applications. For client applications using this function the socket can become bound implicitly to a local address through
            sendto, WSASendTo, or WSAJoinLeaf.
            </para>
            <para>
            For overlapped sockets, this function is used to post one or more buffers into which incoming data will be placed as it becomes
            available on a (possibly connected) socket, after which the application-specified completion indication (invocation of the
            completion routine or setting of an event object) occurs. If the operation does not complete immediately, the final completion
            status is retrieved through the completion routine or WSAGetOverlappedResult. Also, the values indicated by lpFrom and lpFromlen
            are not updated until completion is itself indicated. Applications must not use or disturb these values until they have been
            updated, therefore the application must not use automatic (that is, stack-based) variables for these parameters.
            </para>
            <para>
            <c>Note</c> All I/O initiated by a given thread is canceled when that thread exits. For overlapped sockets, pending asynchronous
            operations can fail if the thread is closed before the operations complete. See ExitThread for more information.
            </para>
            <para>
            If both lpOverlapped and lpCompletionRoutine are <c>NULL</c>, the socket in this function will be treated as a nonoverlapped socket.
            </para>
            <para>
            For nonoverlapped sockets, the blocking semantics are identical to that of the standard WSARecv function and the lpOverlapped
            and lpCompletionRoutine parameters are ignored. Any data that has already been received and buffered by the transport will be
            copied into the user buffers. For the case of a blocking socket with no data currently having been received and buffered by the
            transport, the call will block until data is received.
            </para>
            <para>
            The buffers are filled in the order in which they appear in the array indicated by lpBuffers, and the buffers are packed so that
            no holes are created.
            </para>
            <para>
            If this function is completed in an overlapped manner, it is the Winsock service provider's responsibility to capture the WSABUF
            structures before returning from this call. This enables applications to build stack-based <c>WSABUF</c> arrays pointed to by
            the lpBuffers parameter.
            </para>
            <para>
            For connectionless socket types, the address from which the data originated is copied to the buffer indicated by lpFrom. The
            value pointed to by lpFromlen is initialized to the size of this buffer, and is modified on completion to indicate the actual
            size of the address stored there. As stated previously for overlapped sockets, the lpFrom and lpFromlen parameters are not
            updated until after the overlapped I/O has completed. The memory pointed to by these parameters must, therefore, remain
            available to the service provider and cannot be allocated on the application stack frame. The lpFrom and lpFromlen parameters
            are ignored for connection-oriented sockets.
            </para>
            <para>For byte streamstyle sockets (for example, type SOCK_STREAM), incoming data is placed into the buffers until:</para>
            <list type="bullet">
            <item>
            <term>The buffers are filled.</term>
            </item>
            <item>
            <term>The connection is closed.</term>
            </item>
            <item>
            <term>The internally buffered data is exhausted.</term>
            </item>
            </list>
            <para>
            Regardless of whether or not the incoming data fills all the buffers, the completion indication occurs for overlapped sockets.
            For message-oriented sockets, an incoming message is placed into the buffers up to the total size of the buffers, and the
            completion indication occurs for overlapped sockets. If the message is larger than the buffers, the buffers are filled with the
            first part of the message. If the <c>MSG_PARTIAL</c> feature is supported by the underlying service provider, the
            <c>MSG_PARTIAL</c> flag is set in lpFlags and subsequent receive operation(s) will retrieve the rest of the message. If
            <c>MSG_PARTIAL</c> is not supported, but the protocol is reliable, <c>WSARecvFrom</c> generates the error WSAEMSGSIZE and a
            subsequent receive operation with a larger buffer can be used to retrieve the entire message. Otherwise, (that is, the protocol
            is unreliable and does not support <c>MSG_PARTIAL</c>), the excess data is lost, and <c>WSARecvFrom</c> generates the error WSAEMSGSIZE.
            </para>
            <para>
            The lpFlags parameter can be used to influence the behavior of the function invocation beyond the options specified for the
            associated socket. That is, the semantics of this function are determined by the socket options and the lpFlags parameter. The
            latter is constructed by using the bitwise OR operator with any of any of the values listed in the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MSG_PEEK</term>
            <term>
            Previews the incoming data. The data is copied into the buffer, but is not removed from the input queue. This flag is valid only
            for nonoverlapped sockets.
            </term>
            </item>
            <item>
            <term>MSG_OOB</term>
            <term>Processes OOB data.</term>
            </item>
            <item>
            <term>MSG_PARTIAL</term>
            <term>
            This flag is for message-oriented sockets only. On output, this flag indicates that the data is a portion of the message
            transmitted by the sender. Remaining portions of the message will be transmitted in subsequent receive operations. A subsequent
            receive operation with MSG_PARTIAL flag cleared indicates the end of the sender's message. As an input parameter, this flag
            indicates that the receive operation should complete even if only part of a message has been received by the service provider.
            </term>
            </item>
            </list>
            <para>
            For message-oriented sockets, the <c>MSG_PARTIAL</c> bit is set in the lpFlags parameter if a partial message is received. If a
            complete message is received, <c>MSG_PARTIAL</c> is cleared in lpFlags. In the case of delayed completion, the value pointed to
            by lpFlags is not updated. When completion has been indicated the application should call WSAGetOverlappedResult and examine the
            flags pointed to by the lpdwFlags parameter.
            </para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>WSARecvFrom</c> with the lpOverlapped parameter set to NULL, Winsock
            may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which
            can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call
            inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must
            never be attempted by Winsock clients.
            </para>
            <para>Overlapped Socket I/O</para>
            <para>
            If an overlapped operation completes immediately, <c>WSARecvFrom</c> returns a value of zero and the lpNumberOfBytesRecvd
            parameter is updated with the number of bytes received and the flag bits pointed by the lpFlags parameter are also updated. If
            the overlapped operation is successfully initiated and will complete later, <c>WSARecvFrom</c> returns <c>SOCKET_ERROR</c> and
            indicates error code <c>WSA_IO_PENDING</c>. In this case, lpNumberOfBytesRecvd and lpFlags is not updated. When the overlapped
            operation completes the amount of data transferred is indicated either through the cbTransferred parameter in the completion
            routine (if specified), or through the lpcbTransfer parameter in WSAGetOverlappedResult. Flag values are obtained either through
            the dwFlags parameter of the completion routine, or by examining the lpdwFlags parameter of <c>WSAGetOverlappedResult</c>.
            </para>
            <para>
            The <c>WSARecvFrom</c> function can be called from within the completion routine of a previous WSARecv, <c>WSARecvFrom</c>,
            WSASend, or WSASendTo function. For a given socket, I/O completion routines will not be nested. This permits time-sensitive data
            transmissions to occur entirely within a preemptive context.
            </para>
            <para>
            The lpOverlapped parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are
            simultaneously outstanding, each must reference a separate WSAOVERLAPPED structure.
            </para>
            <para>
            If the lpCompletionRoutine parameter is <c>NULL</c>, the hEvent parameter of lpOverlapped is signaled when the overlapped
            operation completes if it contains a valid event object handle. An application can use WSAWaitForMultipleEvents or
            WSAGetOverlappedResult to wait or poll on the event object.
            </para>
            <para>
            If lpCompletionRoutine is not <c>NULL</c>, the hEvent parameter is ignored and can be used by the application to pass context
            information to the completion routine. A caller that passes a non- <c>NULL</c> lpCompletionRoutine and later calls
            WSAGetOverlappedResult for the same overlapped I/O request may not set the fWait parameter for that invocation of
            <c>WSAGetOverlappedResult</c> to <c>TRUE</c>. In this case the usage of the hEvent parameter is undefined, and attempting to
            wait on the hEvent parameter would produce unpredictable results.
            </para>
            <para>
            The completion routine follows the same rules as stipulated for Windows file I/O completion routines. The completion routine
            will not be invoked until the thread is in an alertable wait state such as can occur when the function WSAWaitForMultipleEvents
            with the fAlertable parameter set to <c>TRUE</c> is invoked.
            </para>
            <para>
            The transport providers allow an application to invoke send and receive operations from within the context of the socket I/O
            completion routine, and guarantee that, for a given socket, I/O completion routines will not be nested. This permits
            time-sensitive data transmissions to occur entirely within a preemptive context.
            </para>
            <para>The prototype of the completion routine is as follows.</para>
            <para>
            The <c>CompletionRoutine</c> is a placeholder for an application-defined or library-defined function name. The dwError specifies
            the completion status for the overlapped operation as indicated by lpOverlapped. The cbTransferred specifies the number of bytes
            received. The dwFlags parameter contains information that would have appeared in lpFlags if the receive operation had completed
            immediately. This function does not return a value.
            </para>
            <para>
            Returning from this function allows invocation of another pending completion routine for this socket. When using
            WSAWaitForMultipleEvents, all waiting completion routines are called before the alertable thread's wait is satisfied with a
            return code of WSA_IO_COMPLETION. The completion routines can be called in any order, not necessarily in the same order the
            overlapped operations are completed. However, the posted buffers are guaranteed to be filled in the same order they are specified.
            </para>
            <para>Example Code</para>
            <para>The following example demonstrates the use of the <c>WSARecvFrom</c> function.</para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSARemoveServiceClass(System.Guid@)">
            <summary>The <c>WSARemoveServiceClass</c> function permanently removes the service class schema from the registry.</summary>
            <param name="lpServiceClassId">Pointer to the GUID for the service class you want to remove.</param>
            <returns>
            <para>
            The return value is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is returned, and a specific error
            number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSATYPE_NOT_FOUND</term>
            <term>The specified class was not found.</term>
            </item>
            <item>
            <term>WSAEACCES</term>
            <term>The calling routine does not have sufficient privileges to remove the Service.</term>
            </item>
            <item>
            <term>WSAETOOMANYREFS</term>
            <term>There are service instances that still reference the class. Removal of this class is not possible at this time.</term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>
            The WS2_32.DLL has not been initialized. The application must first call WSAStartup before calling any Windows Sockets functions.
            </term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>The specified GUID was not valid.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There was insufficient memory to perform the operation.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAResetEvent(Vanara.PInvoke.Ws2_32.WSAEVENT)">
            <summary>The <c>WSAResetEvent</c> function resets the state of the specified event object to nonsignaled.</summary>
            <param name="hEvent">A handle that identifies an open event object handle.</param>
            <returns>
            <para>
            If the <c>WSAResetEvent</c> function succeeds, the return value is <c>TRUE</c>. If the function fails, the return value is
            <c>FALSE</c>. To get extended error information, call WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSA_INVALID_HANDLE</term>
            <term>The hEvent parameter is not a valid event object handle.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>WSAResetEvent</c> function is used to set the state of the event object to nonsignaled.</para>
            <para>
            The proper way to reset the state of an event object used with the WSAEventSelect function is to pass the handle of the event
            object to the WSAEnumNetworkEvents function in the hEventObject parameter. This will reset the event object and adjust the
            status of active FD events on the socket in an atomic fashion.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSASend(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.WSABUF[],System.UInt32,System.UInt32@,Vanara.PInvoke.Ws2_32.MsgFlags,System.IntPtr,Vanara.PInvoke.Ws2_32.LPWSAOVERLAPPED_COMPLETION_ROUTINE)">
            <summary>The <c>WSASend</c> function sends data on a connected socket.</summary>
            <param name="s">A descriptor that identifies a connected socket.</param>
            <param name="lpBuffers">
            A pointer to an array of WSABUF structures. Each <c>WSABUF</c> structure contains a pointer to a buffer and the length, in
            bytes, of the buffer. For a Winsock application, once the <c>WSASend</c> function is called, the system owns these buffers and
            the application may not access them. This array must remain valid for the duration of the send operation.
            </param>
            <param name="dwBufferCount">The number of WSABUF structures in the lpBuffers array.</param>
            <param name="lpNumberOfBytesSent">
            <para>A pointer to the number, in bytes, sent by this call if the I/O operation completes immediately.</para>
            <para>
            Use <c>NULL</c> for this parameter if the lpOverlapped parameter is not <c>NULL</c> to avoid potentially erroneous results. This
            parameter can be <c>NULL</c> only if the lpOverlapped parameter is not <c>NULL</c>.
            </para>
            </param>
            <param name="dwFlags">
            The flags used to modify the behavior of the <c>WSASend</c> function call. For more information, see Using dwFlags in the
            Remarks section.
            </param>
            <param name="lpOverlapped">A pointer to a WSAOVERLAPPED structure. This parameter is ignored for nonoverlapped sockets.</param>
            <param name="lpCompletionRoutine">
            A pointer to the completion routine called when the send operation has been completed. This parameter is ignored for
            nonoverlapped sockets.
            </param>
            <returns>
            <para>
            If no error occurs and the send operation has completed immediately, <c>WSASend</c> returns zero. In this case, the completion
            routine will have already been scheduled to be called once the calling thread is in the alertable state. Otherwise, a value of
            <c>SOCKET_ERROR</c> is returned, and a specific error code can be retrieved by calling WSAGetLastError. The error code
            WSA_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion will be indicated at
            a later time. Any other error code indicates that the overlapped operation was not successfully initiated and no completion
            indication will occur.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAECONNABORTED</term>
            <term>The virtual circuit was terminated due to a time-out or other failure.</term>
            </item>
            <item>
            <term>WSAECONNRESET</term>
            <term>
            For a stream socket, the virtual circuit was reset by the remote side. The application should close the socket as it is no
            longer usable. For a UDP datagram socket, this error would indicate that a previous send operation resulted in an ICMP "Port
            Unreachable" message.
            </term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The lpBuffers, lpNumberOfBytesSent, lpOverlapped, lpCompletionRoutine parameter is not totally contained in a valid part of the
            user address space.
            </term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>A blocking Windows Socket 1.1 call was canceled through WSACancelBlockingCall.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>The socket has not been bound with bind or the socket is not created with the overlapped flag.</term>
            </item>
            <item>
            <term>WSAEMSGSIZE</term>
            <term>The socket is message oriented, and the message is larger than the maximum supported by the underlying transport.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENETRESET</term>
            <term>
            For a stream socket, the connection has been broken due to keep-alive activity detecting a failure while the operation was in
            progress. For a datagram socket, this error indicates that the time to live has expired.
            </term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>The Windows Sockets provider reports a buffer deadlock.</term>
            </item>
            <item>
            <term>WSAENOTCONN</term>
            <term>The socket is not connected.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>
            MSG_OOB was specified, but the socket is not stream-style such as type SOCK_STREAM, OOB data is not supported in the
            communication domain associated with this socket, MSG_PARTIAL is not supported, or the socket is unidirectional and supports
            only receive operations.
            </term>
            </item>
            <item>
            <term>WSAESHUTDOWN</term>
            <term>
            The socket has been shut down; it is not possible to WSASend on a socket after shutdown has been invoked with how set to SD_SEND
            or SD_BOTH.
            </term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>
            Windows NT: Overlapped sockets: There are too many outstanding overlapped I/O requests. Nonoverlapped sockets: The socket is
            marked as nonblocking and the send operation cannot be completed immediately.
            </term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSA_IO_PENDING</term>
            <term>An overlapped operation was successfully initiated and completion will be indicated at a later time.</term>
            </item>
            <item>
            <term>WSA_OPERATION_ABORTED</term>
            <term>
            The overlapped operation has been canceled due to the closure of the socket, the execution of the "SIO_FLUSH" command in
            WSAIoctl, or the thread that initiated the overlapped request exited before the operation completed. For more information, see
            the Remarks section.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>WSASend</c> function provides functionality over and above the standard send function in two important areas:</para>
            <list type="bullet">
            <item>
            <term>It can be used in conjunction with overlapped sockets to perform overlapped send operations.</term>
            </item>
            <item>
            <term>It allows multiple send buffers to be specified making it applicable to the scatter/gather type of I/O.</term>
            </item>
            </list>
            <para>
            The <c>WSASend</c> function is used to write outgoing data from one or more buffers on a connection-oriented socket specified by
            s. It can also be used, however, on connectionless sockets that have a stipulated default peer address established through the
            connect or WSAConnect function.
            </para>
            <para>
            A socket created by the socket function will have the overlapped attribute as the default. A socket created by the WSASocket
            function with the dwFlags parameter passed to <c>WSASocket</c> with the <c>WSA_FLAG_OVERLAPPED</c> bit set will have the
            overlapped attribute. For sockets with the overlapped attribute, <c>WSASend</c> uses overlapped I/O unless both the lpOverlapped
            and lpCompletionRoutine parameters are <c>NULL</c>. In that case, the socket is treated as a non-overlapped socket. A completion
            indication will occur, invoking the completion of a routine or setting of an event object, when the buffer(s) have been consumed
            by the transport. If the operation does not complete immediately, the final completion status is retrieved through the
            completion routine or WSAGetOverlappedResult.
            </para>
            <para>
            If both lpOverlapped and lpCompletionRoutine are <c>NULL</c>, the socket in this function will be treated as a non-overlapped socket.
            </para>
            <para>
            For non-overlapped sockets, the last two parameters (lpOverlapped, lpCompletionRoutine) are ignored and <c>WSASend</c> adopts
            the same blocking semantics as send. Data is copied from the buffer(s) into the transport's buffer. If the socket is
            non-blocking and stream-oriented, and there is not sufficient space in the transport's buffer, <c>WSASend</c> will return with
            only part of the application's buffers having been consumed. Given the same buffer situation and a blocking socket,
            <c>WSASend</c> will block until all of the application buffer contents have been consumed.
            </para>
            <para><c>Note</c> The socket options <c>SO_RCVTIMEO</c> and <c>SO_SNDTIMEO</c> apply only to blocking sockets.</para>
            <para>
            If this function is completed in an overlapped manner, it is the Winsock service provider's responsibility to capture the WSABUF
            structures before returning from this call. This enables applications to build stack-based <c>WSABUF</c> arrays pointed to by
            the lpBuffers parameter.
            </para>
            <para>
            For message-oriented sockets, do not exceed the maximum message size of the underlying provider, which can be obtained by
            getting the value of socket option <c>SO_MAX_MSG_SIZE</c>. If the data is too long to pass atomically through the underlying
            protocol the error WSAEMSGSIZE is returned, and no data is transmitted.
            </para>
            <para><c>Windows Me/98/95:</c> The <c>WSASend</c> function does not support more than 16 buffers.</para>
            <para><c>Note</c> The successful completion of a <c>WSASend</c> does not indicate that the data was successfully delivered.</para>
            <para>Using dwFlags</para>
            <para>
            The dwFlags parameter can be used to influence the behavior of the function invocation beyond the options specified for the
            associated socket. That is, the semantics of this function are determined by the socket options and the dwFlags parameter. The
            latter is constructed by using the bitwise OR operator with any of any of the values listed in the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MSG_DONTROUTE</term>
            <term>
            Specifies that the data should not be subject to routing. A Windows Sockets service provider can choose to ignore this flag.
            </term>
            </item>
            <item>
            <term>MSG_OOB</term>
            <term>Send OOB data on a stream-style socket such as SOCK_STREAM only.</term>
            </item>
            <item>
            <term>MSG_PARTIAL</term>
            <term>
            Specifies that lpBuffers only contains a partial message. Be aware that the error code WSAEOPNOTSUPP will be returned by
            transports that do not support partial message transmissions.
            </term>
            </item>
            </list>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>WSASend</c> with the lpOverlapped parameter set to NULL, Winsock may
            need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which can
            be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call
            inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must
            never be attempted by Winsock clients.
            </para>
            <para>Overlapped Socket I/O</para>
            <para>
            If an overlapped operation completes immediately, <c>WSASend</c> returns a value of zero and the lpNumberOfBytesSent parameter
            is updated with the number of bytes sent. If the overlapped operation is successfully initiated and will complete later,
            <c>WSASend</c> returns SOCKET_ERROR and indicates error code WSA_IO_PENDING. In this case, lpNumberOfBytesSent is not updated.
            When the overlapped operation completes the amount of data transferred is indicated either through the cbTransferred parameter
            in the completion routine (if specified), or through the lpcbTransfer parameter in WSAGetOverlappedResult.
            </para>
            <para>
            <c>Note</c> All I/O initiated by a given thread is canceled when that thread exits. For overlapped sockets, pending asynchronous
            operations can fail if the thread is closed before the operations complete. For more information, see ExitThread.
            </para>
            <para>
            The <c>WSASend</c> function using overlapped I/O can be called from within the completion routine of a previous WSARecv,
            WSARecvFrom, <c>WSASend</c>, or WSASendTo function. This enables time-sensitive data transmissions to occur entirely within a
            preemptive context.
            </para>
            <para>
            The lpOverlapped parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are
            simultaneously outstanding, each must reference a separate WSAOVERLAPPED structure.
            </para>
            <para>
            If the lpCompletionRoutine parameter is <c>NULL</c>, the hEvent parameter of lpOverlapped is signaled when the overlapped
            operation completes if it contains a valid event object handle. An application can use WSAWaitForMultipleEvents or
            WSAGetOverlappedResult to wait or poll on the event object.
            </para>
            <para>
            If lpCompletionRoutine is not <c>NULL</c>, the hEvent parameter is ignored and can be used by the application to pass context
            information to the completion routine. A caller that passes a non- <c>NULL</c> lpCompletionRoutine and later calls
            WSAGetOverlappedResult for the same overlapped I/O request may not set the fWait parameter for that invocation of
            <c>WSAGetOverlappedResult</c> to <c>TRUE</c>. In this case the usage of the hEvent parameter is undefined, and attempting to
            wait on the hEvent parameter would produce unpredictable results.
            </para>
            <para>
            The completion routine follows the same rules as stipulated for Windows file I/O completion routines. The completion routine
            will not be invoked until the thread is in an alertable wait state such as can occur when the function WSAWaitForMultipleEvents
            with the fAlertable parameter set to <c>TRUE</c> is invoked.
            </para>
            <para>
            The transport providers allow an application to invoke send and receive operations from within the context of the socket I/O
            completion routine, and guarantee that, for a given socket, I/O completion routines will not be nested. This permits
            time-sensitive data transmissions to occur entirely within a preemptive context.
            </para>
            <para>The following C++ code example is a prototype of the completion routine.</para>
            <para>
            The CompletionRoutine function is a placeholder for an application-defined or library-defined function name. The dwError
            parameter specifies the completion status for the overlapped operation as indicated by lpOverlapped. cbTransferred specifies the
            number of bytes sent. Currently there are no flag values defined and dwFlags will be zero. This function does not return a value.
            </para>
            <para>
            Returning from this function allows invocation of another pending completion routine for this socket. All waiting completion
            routines are called before the alertable thread's wait is satisfied with a return code of <c>WSA_IO_COMPLETION</c>. The
            completion routines can be called in any order, not necessarily in the same order the overlapped operations are completed.
            However, the posted buffers are guaranteed to be sent in the same order they are specified.
            </para>
            <para>
            The order of calls made to <c>WSASend</c> is also the order in which the buffers are transmitted to the transport layer.
            <c>WSASend</c> should not be called on the same stream-oriented socket concurrently from different threads, because some Winsock
            providers may split a large send request into multiple transmissions, and this may lead to unintended data interleaving from
            multiple concurrent send requests on the same stream-oriented socket.
            </para>
            <para>Example Code</para>
            <para>The following code example shows how to use the <c>WSASend</c> function in overlapped I/O mode.</para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSASendDisconnect(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.WSABUF@)">
            <summary>
            The <c>WSASendDisconnect</c> function initiates termination of the connection for the socket and sends disconnect data.
            </summary>
            <param name="s">Descriptor identifying a socket.</param>
            <param name="lpOutboundDisconnectData">A pointer to the outgoing disconnect data.</param>
            <returns>
            <para>
            If no error occurs, <c>WSASendDisconnect</c> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error
            code can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENOPROTOOPT</term>
            <term>The parameter lpOutboundDisconnectData is not NULL, and the disconnect data is not supported by the service provider.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAENOTCONN</term>
            <term>The socket is not connected (connection-oriented sockets only).</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The lpOutboundDisconnectData parameter is not completely contained in a valid part of the user address space.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSASendDisconnect</c> function is used on connection-oriented sockets to disable transmission and to initiate termination
            of the connection along with the transmission of disconnect data, if any. This is equivalent to a shutdown (SD_SEND), except
            that <c>WSASendDisconnect</c> also allows sending disconnect data (in protocols that support it).
            </para>
            <para>After this function has been successfully issued, subsequent sends are disallowed.</para>
            <para>
            The lpOutboundDisconnectData parameter, if not <c>NULL</c>, points to a buffer containing the outgoing disconnect data to be
            sent to the remote party for retrieval by using WSARecvDisconnect.
            </para>
            <para>
            <c>Note</c> The native implementation of TCP/IP on Windows does not support disconnect data. Disconnect data is only supported
            with Windows Sockets providers that have the XP1_DISCONNECT_DATA flag in their WSAPROTOCOL_INFO structure. Use the
            WSAEnumProtocols function to obtain <c>WSAPROTOCOL_INFO</c> structures for all installed providers.
            </para>
            <para>
            The <c>WSASendDisconnect</c> function does not close the socket, and resources attached to the socket will not be freed until
            closesocket is invoked.
            </para>
            <para>The <c>WSASendDisconnect</c> function does not block regardless of the SO_LINGER setting on the socket.</para>
            <para>
            An application should not rely on being able to reuse a socket after calling <c>WSASendDisconnect</c>. In particular, a Windows
            Sockets provider is not required to support the use of connect/WSAConnect on such a socket.
            </para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>WSASendDisconnect</c>, Winsock may need to wait for a network event
            before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous
            procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an
            ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSASendDisconnect(Vanara.PInvoke.Ws2_32.SOCKET,System.IntPtr)">
            <summary>
            The <c>WSASendDisconnect</c> function initiates termination of the connection for the socket and sends disconnect data.
            </summary>
            <param name="s">Descriptor identifying a socket.</param>
            <param name="lpOutboundDisconnectData">A pointer to the outgoing disconnect data.</param>
            <returns>
            <para>
            If no error occurs, <c>WSASendDisconnect</c> returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error
            code can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENOPROTOOPT</term>
            <term>The parameter lpOutboundDisconnectData is not NULL, and the disconnect data is not supported by the service provider.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAENOTCONN</term>
            <term>The socket is not connected (connection-oriented sockets only).</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The lpOutboundDisconnectData parameter is not completely contained in a valid part of the user address space.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSASendDisconnect</c> function is used on connection-oriented sockets to disable transmission and to initiate termination
            of the connection along with the transmission of disconnect data, if any. This is equivalent to a shutdown (SD_SEND), except
            that <c>WSASendDisconnect</c> also allows sending disconnect data (in protocols that support it).
            </para>
            <para>After this function has been successfully issued, subsequent sends are disallowed.</para>
            <para>
            The lpOutboundDisconnectData parameter, if not <c>NULL</c>, points to a buffer containing the outgoing disconnect data to be
            sent to the remote party for retrieval by using WSARecvDisconnect.
            </para>
            <para>
            <c>Note</c> The native implementation of TCP/IP on Windows does not support disconnect data. Disconnect data is only supported
            with Windows Sockets providers that have the XP1_DISCONNECT_DATA flag in their WSAPROTOCOL_INFO structure. Use the
            WSAEnumProtocols function to obtain <c>WSAPROTOCOL_INFO</c> structures for all installed providers.
            </para>
            <para>
            The <c>WSASendDisconnect</c> function does not close the socket, and resources attached to the socket will not be freed until
            closesocket is invoked.
            </para>
            <para>The <c>WSASendDisconnect</c> function does not block regardless of the SO_LINGER setting on the socket.</para>
            <para>
            An application should not rely on being able to reuse a socket after calling <c>WSASendDisconnect</c>. In particular, a Windows
            Sockets provider is not required to support the use of connect/WSAConnect on such a socket.
            </para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>WSASendDisconnect</c>, Winsock may need to wait for a network event
            before the call can complete. Winsock performs an alertable wait in this situation, which can be interrupted by an asynchronous
            procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call inside an APC that interrupted an
            ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must never be attempted by Winsock clients.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSASendMsg(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.WSAMSG@,Vanara.PInvoke.Ws2_32.MsgFlags,System.UInt32@,System.IntPtr,Vanara.PInvoke.Ws2_32.LPWSAOVERLAPPED_COMPLETION_ROUTINE)">
            <summary>The <c>WSASendMsg</c> function sends data and optional control information from connected and unconnected sockets.</summary>
            <param name="Handle">A descriptor identifying the socket.</param>
            <param name="lpMsg">A WSAMSG structure storing the Posix.1g <c>msghdr</c> structure.</param>
            <param name="dwFlags">
            The flags used to modify the behavior of the <c>WSASendMsg</c> function call. For more information, see Using dwFlags in the
            Remarks section.
            </param>
            <param name="lpNumberOfBytesSent">
            <para>A pointer to the number, in bytes, sent by this call if the I/O operation completes immediately.</para>
            <para>
            Use <c>NULL</c> for this parameter if the lpOverlapped parameter is not <c>NULL</c> to avoid potentially erroneous results. This
            parameter can be <c>NULL</c> only if the lpOverlapped parameter is not <c>NULL</c>.
            </para>
            </param>
            <param name="lpOverlapped">A pointer to a WSAOVERLAPPED structure. Ignored for non-overlapped sockets.</param>
            <param name="lpCompletionRoutine">
            A pointer to the completion routine called when the send operation completes. Ignored for non-overlapped sockets.
            </param>
            <returns>
            <para>
            Returns zero when successful and immediate completion occurs. When zero is returned, the specified completion routine is called
            when the calling thread is in the alertable state.
            </para>
            <para>
            A return value of <c>SOCKET_ERROR</c>, and subsequent call to WSAGetLastError that returns WSA_IO_PENDING, indicates the
            overlapped operation has successfully initiated; completion is then indicated through other means, such as through events or
            completion ports.
            </para>
            <para>
            Upon failure, returns <c>SOCKET_ERROR</c> and a subsequent call to WSAGetLastError returns a value other than
            <c>WSA_IO_PENDING</c>. The following table lists error codes.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEACCES</term>
            <term>The requested address is a broadcast address, but the appropriate flag was not set.</term>
            </item>
            <item>
            <term>WSAECONNRESET</term>
            <term>
            For a UDP datagram socket, this error would indicate that a previous send operation resulted in an ICMP "Port Unreachable" message.
            </term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The lpMsg, lpNumberOfBytesSent, lpOverlapped, or lpCompletionRoutine parameter is not totally contained in a valid part of the
            user address space. This error is also returned if a name member of the WSAMSGstructure pointed to by the lpMsg parameter was a
            NULL pointer and the namelen member of the WSAMSGstructure was not set to zero. This error is also returned if a Control.buf
            member of the WSAMSGstructure pointed to by the lpMsg parameter was a NULL pointer and the Control.len member of the
            WSAMSGstructure was not set to zero.
            </term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>A blocking Windows Socket 1.1 call was canceled through WSACancelBlockingCall.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>The socket has not been bound with bind, or the socket was not created with the overlapped flag.</term>
            </item>
            <item>
            <term>WSAEMSGSIZE</term>
            <term>The socket is message oriented, and the message is larger than the maximum supported by the underlying transport.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENETRESET</term>
            <term>For a datagram socket, this error indicates that the time to live has expired.</term>
            </item>
            <item>
            <term>WSAENETUNREACH</term>
            <term>The network is unreachable.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>The Windows Sockets provider reports a buffer deadlock.</term>
            </item>
            <item>
            <term>WSAENOTCONN</term>
            <term>The socket is not connected.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>
            The socket operation is not supported. This error is returned if the dwFlags member of the WSAMSGstructure pointed to by the
            lpMsg parameter includes any control flags invalid for WSASendMsg.
            </term>
            </item>
            <item>
            <term>WSAESHUTDOWN</term>
            <term>
            The socket has been shut down; it is not possible to call the WSASendMsg function on a socket after shutdown has been invoked
            with how set to SD_SEND or SD_BOTH.
            </term>
            </item>
            <item>
            <term>WSAETIMEDOUT</term>
            <term>
            The socket timed out. This error is returned if the socket had a wait timeout specified using the SO_SNDTIMEO socket option and
            the timeout was exceeded.
            </term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>
            Overlapped sockets: There are too many outstanding overlapped I/O requests. Nonoverlapped sockets: The socket is marked as
            nonblocking and the send operation cannot be completed immediately.
            </term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSA_IO_PENDING</term>
            <term>An overlapped operation was successfully initiated and completion will be indicated at a later time.</term>
            </item>
            <item>
            <term>WSA_OPERATION_ABORTED</term>
            <term>
            The overlapped operation has been canceled due to the closure of the socket or due to the execution of the SIO_FLUSH command in WSAIoctl.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSASendMsg</c> function can be used in place of the WSASend and WSASendTo functions. The <c>WSASendMsg</c> function can
            only be used with datagrams and raw sockets. The socket descriptor in the s parameter must be opened with the socket type set to
            <c>SOCK_DGRAM</c> or <c>SOCK_RAW</c>.
            </para>
            <para>
            The dwFlags parameter can only contain a combination of the following control flags: <c>MSG_DONTROUTE</c>, <c>MSG_PARTIAL</c>,
            and <c>MSG_OOB</c>. The <c>dwFlags</c> member of the WSAMSGstructure pointed to by the lpMsg parameter is ignored on input and
            not used on output.
            </para>
            <para>
            <c>Note</c> The function pointer for the <c>WSASendMsg</c> function must be obtained at run time by making a call to the
            WSAIoctl function with the <c>SIO_GET_EXTENSION_FUNCTION_POINTER</c> opcode specified. The input buffer passed to the
            <c>WSAIoctl</c> function must contain <c>WSAID_WSASENDMSG</c>, a globally unique identifier (GUID) whose value identifies the
            <c>WSASendMsg</c> extension function. On success, the output returned by the <c>WSAIoctl</c> function contains a pointer to the
            <c>WSASendMsg</c> function. The <c>WSAID_WSASENDMSG</c> GUID is defined in the Mswsock.h header file.
            </para>
            <para>
            Overlapped sockets are created with a WSASocket function call that has the <c>WSA_FLAG_OVERLAPPED</c> flag set. For overlapped
            sockets, sending information uses overlapped I/O unless both lpOverlapped and lpCompletionRoutine are <c>NULL</c>; when
            lpOverlapped and lpCompletionRoutine are <c>NULL</c>, the socket is treated as a nonoverlapped socket. A completion indication
            occurs with overlapped sockets; once the buffer or buffers have been consumed by the transport, a completion routine is
            triggered or an event object is set. If the operation does not complete immediately, the final completion status is retrieved
            through the completion routine or by calling the WSAGetOverlappedResult function.
            </para>
            <para>
            For nonoverlapped sockets, the lpOverlapped and lpCompletionRoutine parameters are ignored and <c>WSASendMsg</c> adopts the same
            blocking semantics as the send function: data is copied from the buffer or buffers into the transport's buffer. If the socket is
            nonblocking and stream oriented, and there is insufficient space in the transport's buffer, <c>WSASendMsg</c> returns with only
            part of the application's buffers having been consumed. In contrast, this buffer situation on a blocking socket results in
            <c>WSASendMsg</c> blocking until all of the application's buffer contents have been consumed.
            </para>
            <para>
            If this function is completed in an overlapped manner, it is the Winsock service provider's responsibility to capture this
            WSABUF structure before returning from this call. This enables applications to build stack-based <c>WSABUF</c> arrays pointed to
            by the <c>lpBuffers</c> member of the WSAMSGstructure pointed to by the lpMsg parameter.
            </para>
            <para>
            For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying provider, which can be
            obtained by getting the value of socket option <c>SO_MAX_MSG_SIZE</c>. If the data is too long to pass atomically through the
            underlying protocol, the error <c>WSAEMSGSIZE</c> is returned and no data is transmitted.
            </para>
            <para>
            On an IPv4 socket of type <c>SOCK_DGRAM</c> or <c>SOCK_RAW</c>, an application can specific the local IP source address to use
            for sending with the <c>WSASendMsg</c> function. One of the control data objects passed in the WSAMSG structure to the
            <c>WSASendMsg</c> function may contain an in_pktinfo structure used to specify the local IPv4 source address to use for sending.
            </para>
            <para>
            On an IPv6 socket of type <c>SOCK_DGRAM</c> or <c>SOCK_RAW</c>, an application can specific the local IP source address to use
            for sending with the <c>WSASendMsg</c> function. One of the control data objects passed in the WSAMSG structure to the
            <c>WSASendMsg</c> function may contain an in6_pktinfo structure used to specify the local IPv6 source address to use for sending.
            </para>
            <para>
            For a dual-stack socket when sending datagrams with the <c>WSASendMsg</c> function and an application wants to specify a
            specific local IP source address to be used, the method to handle this depends on the destination IP address. When sending to an
            IPv4 destination address or an IPv4-mapped IPv6 destination address, one of the control data objects passed in the WSAMSG
            structure pointed to by the lpMsg parameter should contain an in_pktinfo structure containing the local IPv4 source address to
            use for sending. When sending to an IPv6 destination address that is not a an IPv4-mapped IPv6 address, one of the control data
            objects passed in the <c>WSAMSG</c> structure pointed to by the lpMsg parameter should contain an in6_pktinfo structure
            containing the local IPv6 source address to use for sending.
            </para>
            <para><c>Note</c> The <c>SO_SNDTIMEO</c> socket option applies only to blocking sockets.</para>
            <para><c>Note</c> The successful completion of a <c>WSASendMsg</c> does not indicate that the data was successfully delivered.</para>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>WSASendMsg</c> with the lpOverlapped parameter set to NULL, Winsock
            may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation, which
            can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock call
            inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and must
            never be attempted by Winsock clients.
            </para>
            <para>dwFlags</para>
            <para>
            The dwFlags input parameter can be used to influence the behavior of the function invocation beyond the options specified for
            the associated socket. That is, the semantics of this function are determined by the socket options and the dwFlags parameter.
            The latter is constructed by using the bitwise OR operator with any of the following values.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MSG_DONTROUTE</term>
            <term>
            Specifies that the data should not be subject to routing. A Windows Sockets service provider can choose to ignore this flag.
            </term>
            </item>
            <item>
            <term>MSG_PARTIAL</term>
            <term>
            Specifies that lpMsg-&gt;lpBuffers contains only a partial message. Note that the error code WSAEOPNOTSUPP will be returned by
            transports that do not support partial message transmissions.
            </term>
            </item>
            </list>
            <para>The possible values for dwFlags parameter are defined in the Winsock2.h header file.</para>
            <para>On output, the <c>dwFlags</c> member of the WSAMSGstructure pointed to by the lpMsg parameter is not used.</para>
            <para>Overlapped Socket I/O</para>
            <para>
            If an overlapped operation completes immediately, <c>WSASendMsg</c> returns a value of zero and the lpNumberOfBytesSent
            parameter is updated with the number of bytes sent. If the overlapped operation is successfully initiated and will complete
            later, <c>WSASendMsg</c> returns SOCKET_ERROR and indicates error code WSA_IO_PENDING. In this case, lpNumberOfBytesSent is not
            updated. When the overlapped operation completes, the amount of data transferred is indicated either through the cbTransferred
            parameter in the completion routine (if specified) or through the lpcbTransfer parameter in WSAGetOverlappedResult.
            </para>
            <para>
            <c>Note</c> All I/O initiated by a given thread is canceled when that thread exits. For overlapped sockets, pending asynchronous
            operations can fail if the thread is closed before the operations complete. See ExitThread for more information.
            </para>
            <para>
            The <c>WSASendMsg</c> function using overlapped I/O can be called from within the completion routine of a previous , WSARecv,
            WSARecvFrom, WSARecvMsg, WSASend, <c>WSASendMsg</c>, or WSASendTo function. This permits time-sensitive data transmissions to
            occur entirely within a preemptive context.
            </para>
            <para>
            The lpOverlapped parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are
            simultaneously outstanding, each must reference a separate WSAOVERLAPPED structure.
            </para>
            <para>
            If the lpCompletionRoutine parameter is <c>NULL</c>, the hEvent parameter of lpOverlapped is signaled when the overlapped
            operation completes if it contains a valid event object handle. An application can use WSAWaitForMultipleEvents or
            WSAGetOverlappedResult to wait or poll on the event object.
            </para>
            <para>
            If lpCompletionRoutine is not <c>NULL</c>, the hEvent parameter is ignored and can be used by the application to pass context
            information to the completion routine. A caller that passes a non- <c>NULL</c> lpCompletionRoutine and later calls
            WSAGetOverlappedResult for the same overlapped I/O request may not set the fWait parameter for that invocation of
            <c>WSAGetOverlappedResult</c> to <c>TRUE</c>. In this case, the usage of the hEvent parameter is undefined, and attempting to
            wait on the hEvent parameter would produce unpredictable results.
            </para>
            <para>
            The completion routine follows the same rules as stipulated for Windows file I/O completion routines. The completion routine
            will not be invoked until the thread is in an alertable wait state, for example, with WSAWaitForMultipleEvents called with the
            fAlertable parameter set to <c>TRUE</c>.
            </para>
            <para>
            The transport providers allow an application to invoke send and receive operations from within the context of the socket I/O
            completion routine, and guarantee that, for a given socket, I/O completion routines will not be nested. This permits
            time-sensitive data transmissions to occur entirely within a preemptive context.
            </para>
            <para>The prototype of the completion routine is as follows.</para>
            <para>
            The <c>CompletionRoutine</c> function is a placeholder for an application-defined or library-defined function name. The dwError
            parameter specifies the completion status for the overlapped operation as indicated by the lpOverlapped parameter. The
            cbTransferred parameter indicates the number of bytes sent. Currently there are no flag values defined and the dwFlags parameter
            will be zero. The <c>CompletionRoutine</c> function does not return a value.
            </para>
            <para>
            Returning from this function allows invocation of another pending completion routine for the socket. All waiting completion
            routines are called before the alertable thread's wait is satisfied with a return code of WSA_IO_COMPLETION. The completion
            routines can be called in any order, not necessarily in the same order the overlapped operations are completed. However, the
            posted buffers are guaranteed to be sent in the same order they are specified.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSASendTo(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.WSABUF[],System.UInt32,System.UInt32@,Vanara.PInvoke.Ws2_32.MsgFlags,Vanara.PInvoke.Ws2_32.SOCKADDR,System.Int32,System.IntPtr,Vanara.PInvoke.Ws2_32.LPWSAOVERLAPPED_COMPLETION_ROUTINE)">
            <summary>The <c>WSASendTo</c> function sends data to a specific destination, using overlapped I/O where applicable.</summary>
            <param name="s">A descriptor identifying a (possibly connected) socket.</param>
            <param name="lpBuffers">
            A pointer to an array of WSABUF structures. Each <c>WSABUF</c> structure contains a pointer to a buffer and the length of the
            buffer, in bytes. For a Winsock application, once the <c>WSASendTo</c> function is called, the system owns these buffers and the
            application may not access them. This array must remain valid for the duration of the send operation.
            </param>
            <param name="dwBufferCount">The number of WSABUF structures in the lpBuffers array.</param>
            <param name="lpNumberOfBytesSent">
            <para>A pointer to the number of bytes sent by this call if the I/O operation completes immediately.</para>
            <para>
            Use <c>NULL</c> for this parameter if the lpOverlapped parameter is not <c>NULL</c> to avoid potentially erroneous results. This
            parameter can be <c>NULL</c> only if the lpOverlapped parameter is not <c>NULL</c>.
            </para>
            </param>
            <param name="dwFlags">The flags used to modify the behavior of the <c>WSASendTo</c> function call.</param>
            <param name="lpTo">An optional pointer to the address of the target socket in the SOCKADDR structure.</param>
            <param name="iTolen">The size, in bytes, of the address in the lpTo parameter.</param>
            <param name="lpOverlapped">A pointer to a WSAOVERLAPPED structure (ignored for nonoverlapped sockets).</param>
            <param name="lpCompletionRoutine">
            A pointer to the completion routine called when the send operation has been completed (ignored for nonoverlapped sockets).
            </param>
            <returns>
            <para>
            If no error occurs and the send operation has completed immediately, <c>WSASendTo</c> returns zero. In this case, the completion
            routine will have already been scheduled to be called once the calling thread is in the alertable state. Otherwise, a value of
            <c>SOCKET_ERROR</c> is returned, and a specific error code can be retrieved by calling WSAGetLastError. The error code
            WSA_IO_PENDING indicates that the overlapped operation has been successfully initiated and that completion will be indicated at
            a later time. Any other error code indicates that the overlapped operation was not successfully initiated and no completion
            indication will occur.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEACCES</term>
            <term>The requested address is a broadcast address, but the appropriate flag was not set.</term>
            </item>
            <item>
            <term>WSAEADDRNOTAVAIL</term>
            <term>The remote address is not a valid address (such as ADDR_ANY).</term>
            </item>
            <item>
            <term>WSAEAFNOSUPPORT</term>
            <term>Addresses in the specified family cannot be used with this socket.</term>
            </item>
            <item>
            <term>WSAECONNRESET</term>
            <term>
            For a UDP datagram socket, this error would indicate that a previous send operation resulted in an ICMP "Port Unreachable" message.
            </term>
            </item>
            <item>
            <term>WSAEDESTADDRREQ</term>
            <term>A destination address is required.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The lpBuffers, lpTo, lpOverlapped, lpNumberOfBytesSent, or lpCompletionRoutine parameters are not part of the user address
            space, or the lpTo parameter is too small.
            </term>
            </item>
            <item>
            <term>WSAEHOSTUNREACH</term>
            <term>A socket operation was attempted to an unreachable host.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEINTR</term>
            <term>A blocking Windows Socket 1.1 call was canceled through WSACancelBlockingCall.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>The socket has not been bound with bind, or the socket is not created with the overlapped flag.</term>
            </item>
            <item>
            <term>WSAEMSGSIZE</term>
            <term>The socket is message oriented, and the message is larger than the maximum supported by the underlying transport.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAENETRESET</term>
            <term>For a datagram socket, this error indicates that the time to live has expired.</term>
            </item>
            <item>
            <term>WSAENETUNREACH</term>
            <term>The network cannot be reached from this host at this time.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>The Windows Sockets provider reports a buffer deadlock.</term>
            </item>
            <item>
            <term>WSAENOTCONN</term>
            <term>The socket is not connected (connection-oriented sockets only).</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            <item>
            <term>WSAESHUTDOWN</term>
            <term>
            The socket has been shut down; it is not possible to WSASendTo on a socket after shutdown has been invoked with how set to
            SD_SEND or SD_BOTH.
            </term>
            </item>
            <item>
            <term>WSAEWOULDBLOCK</term>
            <term>
            Windows NT: Overlapped sockets: there are too many outstanding overlapped I/O requests. Nonoverlapped sockets: The socket is
            marked as nonblocking and the send operation cannot be completed immediately.
            </term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSA_IO_PENDING</term>
            <term>An overlapped operation was successfully initiated and completion will be indicated at a later time.</term>
            </item>
            <item>
            <term>WSA_OPERATION_ABORTED</term>
            <term>
            The overlapped operation has been canceled due to the closure of the socket, or the execution of the SIO_FLUSH command in WSAIoctl.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>WSASendTo</c> function provides enhanced features over the standard sendto function in two important areas:</para>
            <list type="bullet">
            <item>
            <term>It can be used in conjunction with overlapped sockets to perform overlapped send operations.</term>
            </item>
            <item>
            <term>It allows multiple send buffers to be specified making it applicable to the scatter/gather type of I/O.</term>
            </item>
            </list>
            <para>
            The <c>WSASendTo</c> function is normally used on a connectionless socket specified by s to send a datagram contained in one or
            more buffers to a specific peer socket identified by the lpTo parameter. Even if the connectionless socket has been previously
            connected using the connect function to a specific address, lpTo overrides the destination address for that particular datagram
            only. On a connection-oriented socket, the lpTo and iToLen parameters are ignored; in this case, the <c>WSASendTo</c> is
            equivalent to WSASend.
            </para>
            <para>
            For overlapped sockets (created using WSASocket with flag <c>WSA_FLAG_OVERLAPPED</c>) sending data uses overlapped I/O, unless
            both lpOverlapped and lpCompletionRoutine are <c>NULL</c> in which case the socket is treated as a nonoverlapped socket. A
            completion indication will occur (invoking the completion routine or setting of an event object) when the buffer(s) have been
            consumed by the transport. If the operation does not complete immediately, the final completion status is retrieved through the
            completion routine or WSAGetOverlappedResult.
            </para>
            <para>
            <c>Note</c> If a socket is opened, a setsockopt call is made, and then a sendto call is made, Windows Sockets performs an
            implicit bind function call.
            </para>
            <para>
            If both lpOverlapped and lpCompletionRoutine are <c>NULL</c>, the socket in this function will be treated as a nonoverlapped socket.
            </para>
            <para>
            For nonoverlapped sockets, the last two parameters (lpOverlapped, lpCompletionRoutine) are ignored and <c>WSASendTo</c> adopts
            the same blocking semantics as send. Data is copied from the buffer(s) into the transport buffer. If the socket is nonblocking
            and stream oriented, and there is not sufficient space in the transport's buffer, <c>WSASendTo</c> returns with only part of the
            application's buffers having been consumed. Given the same buffer situation and a blocking socket, <c>WSASendTo</c> will block
            until all of the application's buffer contents have been consumed.
            </para>
            <para>
            If this function is completed in an overlapped manner, it is the Winsock service provider's responsibility to capture the WSABUF
            structures before returning from this call. This enables applications to build stack-based <c>WSABUF</c> arrays pointed to by
            the lpBuffers parameter.
            </para>
            <para>
            For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport, which can
            be obtained by getting the value of socket option <c>SO_MAX_MSG_SIZE</c>. If the data is too long to pass atomically through the
            underlying protocol the error WSAEMSGSIZE is returned, and no data is transmitted.
            </para>
            <para>
            If the socket is unbound, unique values are assigned to the local association by the system, and the socket is then marked as bound.
            </para>
            <para>
            If the socket is connected, the getsockname function can be used to determine the local IP address and port associated with the socket.
            </para>
            <para>
            If the socket is not connected, the getsockname function can be used to determine the local port number associated with the
            socket but the IP address returned is set to the wildcard address for the given protocol (for example, INADDR_ANY or "0.0.0.0"
            for IPv4 and IN6ADDR_ANY_INIT or "::" for IPv6).
            </para>
            <para>The successful completion of a <c>WSASendTo</c> does not indicate that the data was successfully delivered.</para>
            <para>
            The dwFlags parameter can be used to influence the behavior of the function invocation beyond the options specified for the
            associated socket. That is, the semantics of this function are determined by the socket options and the dwFlags parameter. The
            latter is constructed by using the bitwise OR operator with any of any of the values listed in the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MSG_DONTROUTE</term>
            <term>
            Specifies that the data should not be subject to routing. A Windows Socket service provider may choose to ignore this flag.
            </term>
            </item>
            <item>
            <term>MSG_OOB</term>
            <term>Send OOB data (stream-style socket such as SOCK_STREAM only).</term>
            </item>
            <item>
            <term>MSG_PARTIAL</term>
            <term>
            Specifies that lpBuffers only contains a partial message. Be aware that the error code WSAEOPNOTSUPP will be returned by
            transports that do not support partial message transmissions.
            </term>
            </item>
            </list>
            <para>
            <c>Note</c> When issuing a blocking Winsock call such as <c>WSASendTo</c> with the lpOverlapped parameter set to <c>NULL</c>,
            Winsock may need to wait for a network event before the call can complete. Winsock performs an alertable wait in this situation,
            which can be interrupted by an asynchronous procedure call (APC) scheduled on the same thread. Issuing another blocking Winsock
            call inside an APC that interrupted an ongoing blocking Winsock call on the same thread will lead to undefined behavior, and
            must never be attempted by Winsock clients.
            </para>
            <para>Overlapped Socket I/O</para>
            <para>
            If an overlapped operation completes immediately, <c>WSASendTo</c> returns a value of zero and the lpNumberOfBytesSent parameter
            is updated with the number of bytes sent. If the overlapped operation is successfully initiated and will complete later,
            <c>WSASendTo</c> returns <c>SOCKET_ERROR</c> and indicates error code WSA_IO_PENDING. In this case, lpNumberOfBytesSent is not
            updated. When the overlapped operation completes the amount of data transferred is indicated either through the cbTransferred
            parameter in the completion routine (if specified), or through the lpcbTransfer parameter in WSAGetOverlappedResult.
            </para>
            <para>
            <c>Note</c> All I/O initiated by a given thread is canceled when that thread exits. For overlapped sockets, pending asynchronous
            operations can fail if the thread is closed before the operations complete. See ExitThread for more information.
            </para>
            <para>
            The <c>WSASendTo</c> function using overlapped I/O can be called from within the completion routine of a previous WSARecv,
            WSARecvFrom, WSASend, or <c>WSASendTo</c> function. This permits time-sensitive data transmissions to occur entirely within a
            preemptive context.
            </para>
            <para>
            The lpOverlapped parameter must be valid for the duration of the overlapped operation. If multiple I/O operations are
            simultaneously outstanding, each must reference a separate WSAOVERLAPPED structure.
            </para>
            <para>
            If the lpCompletionRoutine parameter is <c>NULL</c>, the hEvent parameter of lpOverlapped is signaled when the overlapped
            operation completes if it contains a valid event object handle. An application can use WSAWaitForMultipleEvents or
            WSAGetOverlappedResult to wait or poll on the event object.
            </para>
            <para>
            If lpCompletionRoutine is not <c>NULL</c>, the hEvent parameter is ignored and can be used by the application to pass context
            information to the completion routine. A caller that passes a non- <c>NULL</c> lpCompletionRoutine and later calls
            WSAGetOverlappedResult for the same overlapped I/O request may not set the fWait parameter for that invocation of
            <c>WSAGetOverlappedResult</c> to <c>TRUE</c>. In this case the usage of the hEvent parameter is undefined, and attempting to
            wait on the hEvent parameter would produce unpredictable results.
            </para>
            <para>
            The completion routine follows the same rules as stipulated for Windows file I/O completion routines. The completion routine
            will not be invoked until the thread is in an alertable wait state such as can occur when the function WSAWaitForMultipleEvents
            with the fAlertable parameter set to <c>TRUE</c> is invoked.
            </para>
            <para>
            Transport providers allow an application to invoke send and receive operations from within the context of the socket I/O
            completion routine, and guarantee that, for a given socket, I/O completion routines will not be nested. This permits
            time-sensitive data transmissions to occur entirely within a preemptive context.
            </para>
            <para>The prototype of the completion routine is as follows.</para>
            <para>
            The CompletionRoutine function is a placeholder for an application-defined or library-defined function name. The dwError
            parameter specifies the completion status for the overlapped operation as indicated by lpOverlapped. The cbTransferred parameter
            specifies the number of bytes sent. Currently there are no flag values defined and dwFlags will be zero. This function does not
            return a value.
            </para>
            <para>
            Returning from this function allows invocation of another pending completion routine for this socket. All waiting completion
            routines are called before the alertable thread's wait is satisfied with a return code of WSA_IO_COMPLETION. The completion
            routines can be called in any order, not necessarily in the same order in which the overlapped operations are completed.
            However, the posted buffers are guaranteed to be sent in the same order they are specified.
            </para>
            <para>Example Code</para>
            <para>The following example demonstrates the use of the <c>WSASendTo</c> function using an event object.</para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSASetEvent(Vanara.PInvoke.Ws2_32.WSAEVENT)">
            <summary>The <c>WSASetEvent</c> function sets the state of the specified event object to signaled.</summary>
            <param name="hEvent">Handle that identifies an open event object.</param>
            <returns>
            <para>If the function succeeds, the return value is <c>TRUE</c>.</para>
            <para>If the function fails, the return value is <c>FALSE</c>. To get extended error information, call WSAGetLastError.</para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSA_INVALID_HANDLE</term>
            <term>The hEvent parameter is not a valid event object handle.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>WSASetEvent</c> function sets the state of the event object to be signaled.</para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSASetLastError(System.Int32)">
            <summary>The <c>WSASetLastError</c> function sets the error code that can be retrieved through the WSAGetLastError function.</summary>
            <param name="iError">Integer that specifies the error code to be returned by a subsequent WSAGetLastError call.</param>
            <returns>
            <para>This function generates no return values.</para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSASetLastError</c> function allows an application to set the error code to be returned by a subsequent WSAGetLastError
            call for the current thread. Note that any subsequent Windows Sockets routine called by the application will override the error
            code as set by this routine.
            </para>
            <para>
            The error code set by <c>WSASetLastError</c> is different from the error code reset by calling the function getsockopt with SO_ERROR.
            </para>
            <para>The Windows Sockets error codes used by this function are listed under Windows Sockets Error Codes.</para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSASetService(Vanara.PInvoke.Ws2_32.WSAQUERYSET@,Vanara.PInvoke.Ws2_32.WSAESETSERVICEOP,Vanara.PInvoke.Ws2_32.ServiceInstallFlags)">
            <summary>The <c>WSASetService</c> function registers or removes from the registry a service instance within one or more namespaces.</summary>
            <param name="lpqsRegInfo">A pointer to the service information for registration or deregistration.</param>
            <param name="essoperation">
            <para>
            A value that determines that operation requested. This parameter can be one of the values from the WSAESETSERVICEOP enumeration
            type defined in the Winsock2.h header file.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>RNRSERVICE_REGISTER</term>
            <term>
            Register the service. For SAP, this means sending out a periodic broadcast. This is an NOP for the DNS namespace. For persistent
            data stores, this means updating the address information.
            </term>
            </item>
            <item>
            <term>RNRSERVICE_DEREGISTER</term>
            <term>
            Remove the service from the registry. For SAP, this means stop sending out the periodic broadcast. This is an NOP for the DNS
            namespace. For persistent data stores this means deleting address information.
            </term>
            </item>
            <item>
            <term>RNRSERVICE_DELETE</term>
            <term>
            Delete the service from dynamic name and persistent spaces. For services represented by multiple CSADDR_INFO structures (using
            the SERVICE_MULTIPLE flag), only the specified address will be deleted, and this must match exactly the corresponding
            CSADDR_INFO structure that was specified when the service was registered.
            </term>
            </item>
            </list>
            </param>
            <param name="dwControlFlags">
            <para>
            Service install flags value that further controls the operation performed of the <c>WSASetService</c> function. The possible
            values for this parameter are defined in the Winsock2.h header file.
            </para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SERVICE_MULTIPLE</term>
            <term>
            Controls scope of operation. When this flag is not set, service addresses are managed as a group. A register or removal from the
            registry invalidates all existing addresses before adding the given address set. When set, the action is only performed on the
            given address set. A register does not invalidate existing addresses and a removal from the registry only invalidates the given
            set of addresses.
            </term>
            </item>
            </list>
            </param>
            <returns>
            <para>
            The return value for <c>WSASetService</c> is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is
            returned, and a specific error number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEACCES</term>
            <term>The calling routine does not have sufficient privileges to install the Service.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more required parameters were invalid or missing.</term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>
            The Ws2_32.dll has not been initialized. The application must first call WSAStartup before calling any Windows Sockets functions.
            </term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There was insufficient memory to perform the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSASetService</c> function can be used to affect a specific namespace provider, all providers associated with a specific
            namespace, or all providers across all namespaces.
            </para>
            <para>
            The available values for essOperation and dwControlFlags combine to control operation of the <c>WSASetService</c> function as
            shown in the following table.
            </para>
            <list type="table">
            <listheader>
            <term>Operation</term>
            <term>Flags</term>
            <term>Service already exists</term>
            <term>Service does not exist</term>
            </listheader>
            <item>
            <term>RNRSERVICE_REGISTER</term>
            <term>None</term>
            <term>Overwrites the object. Uses only addresses specified. The object is REGISTERED.</term>
            <term>Creates a new object. Uses only addresses specified. Object is REGISTERED.</term>
            </item>
            <item>
            <term>RNRSERVICE_REGISTER</term>
            <term>SERVICE_MULTIPLE</term>
            <term>Updates the object. Adds new addresses to the existing set. The object is REGISTERED.</term>
            <term>Creates a new object. Uses all addresses specified. Object is REGISTERED.</term>
            </item>
            <item>
            <term>RNRSERVICE_DEREGISTER</term>
            <term>None</term>
            <term>Removes all addresses, but does not remove the object from the namespace. The object is removed from the registry.</term>
            <term>WSASERVICE_NOT_FOUND</term>
            </item>
            <item>
            <term>RNRSERVICE_DEREGISTER</term>
            <term>SERVICE_MULTIPLE</term>
            <term>
            Updates the object. Removes only addresses that are specified. Only marks the object as DEREGISTERED if no addresses are
            present. Does not remove the object from the namespace.
            </term>
            <term>WSASERVICE_NOT_FOUND</term>
            </item>
            <item>
            <term>RNRSERVICE_DELETE</term>
            <term>None</term>
            <term>Removes the object from the namespace.</term>
            <term>WSASERVICE_NOT_FOUND</term>
            </item>
            <item>
            <term>RNRSERVICE_DELETE</term>
            <term>SERVICE_MULTIPLE</term>
            <term>Removes only addresses that are specified. Only removes object from the namespace if no addresses remain.</term>
            <term>WSASERVICE_NOT_FOUND</term>
            </item>
            </list>
            <para>
            Publishing services to directories, such as Active Directory Services, is restricted based on access control lists (ACLs). For
            more information, see Security Issues for Service Publication.
            </para>
            <para>
            When the dwControlFlags parameter is set to <c>SERVICE_MULTIPLE</c>, an application can manage its addresses independently. This
            is useful when the application wants to manage its protocols individually or when the service resides on more than one computer.
            For instance, when a service uses more than one protocol, it may find that one listening socket aborts but the other sockets
            remain operational. In this case, the service could remove the aborted address from the registry without affecting the other addresses.
            </para>
            <para>
            When the dwControlFlags parameter is set to <c>SERVICE_MULTIPLE</c>, an application must not let stale addresses remain in the
            object. This can happen if the application aborts without issuing a DEREGISTER request. When a service registers, it should
            store its addresses. On its next invocation, the service should explicitly remove these old stale addresses from the registry
            before registering new addresses.
            </para>
            <para>
            <c>Note</c> If ANSI character strings are used, there is a chance that the WSAQUERYSET data in lpqsRegInfo may not contain any
            results after this function returns. This is because the ANSI version of this method, <c>WSASetServiceA</c>, converts the ANSI
            data in <c>WSAQUERYSET</c> to Unicode internally, but does not convert the results back to ANSI. This primarily impacts
            transports that return a "service record handle" used to uniquely identify a record. To work around this issue, applications
            should use Unicode string data in <c>WSAQUERYSET</c> when calling this function.
            </para>
            <para>Service Properties</para>
            <para>
            The following table describes how service property data is represented in a WSAQUERYSET structure. Fields labeled as (Optional)
            can contain a null pointer.
            </para>
            <list type="table">
            <listheader>
            <term>WSAQUERYSET member</term>
            <term>Service property description</term>
            </listheader>
            <item>
            <term>dwSize</term>
            <term>Must be set to sizeof (WSAQUERYSET). This is a versioning mechanism.</term>
            </item>
            <item>
            <term>dwOutputFlags</term>
            <term>Not applicable and ignored.</term>
            </item>
            <item>
            <term>lpszServiceInstanceName</term>
            <term>Referenced string contains the service instance name.</term>
            </item>
            <item>
            <term>lpServiceClassId</term>
            <term>The GUID corresponding to this service class.</term>
            </item>
            <item>
            <term>lpVersion</term>
            <term>(Optional) Supplies service instance version number.</term>
            </item>
            <item>
            <term>lpszComment</term>
            <term>(Optional) An optional comment string.</term>
            </item>
            <item>
            <term>dwNameSpace</term>
            <term>See table that follows.</term>
            </item>
            <item>
            <term>lpNSProviderId</term>
            <term>See table that follows.</term>
            </item>
            <item>
            <term>lpszContext</term>
            <term>(Optional) Specifies the starting point of the query in a hierarchical namespace.</term>
            </item>
            <item>
            <term>dwNumberOfProtocols</term>
            <term>Ignored.</term>
            </item>
            <item>
            <term>lpafpProtocols</term>
            <term>Ignored.</term>
            </item>
            <item>
            <term>lpszQueryString</term>
            <term>Ignored.</term>
            </item>
            <item>
            <term>dwNumberOfCsAddrs</term>
            <term>The number of elements in the array of CSADDR_INFO structures referenced by lpcsaBuffer.</term>
            </item>
            <item>
            <term>lpcsaBuffer</term>
            <term>A pointer to an array of CSADDR_INFO structures that contain the address(es) that the service is listening on.</term>
            </item>
            <item>
            <term>lpBlob</term>
            <term>(Optional) This is a pointer to a provider-specific entity.</term>
            </item>
            </list>
            <para>
            As illustrated in the following, the combination of the <c>dwNameSpace</c> and <c>lpNSProviderId</c> members determine that
            namespace providers are affected by this function.
            </para>
            <list type="table">
            <listheader>
            <term>dwNameSpace</term>
            <term>lpNSProviderId</term>
            <term>Scope of impact</term>
            </listheader>
            <item>
            <term>Ignored</term>
            <term>Non-null</term>
            <term>The specified name-space provider.</term>
            </item>
            <item>
            <term>A valid name- space identifier</term>
            <term>Null</term>
            <term>All name-space providers that support the indicated namespace.</term>
            </item>
            <item>
            <term>NS_ALL</term>
            <term>Null</term>
            <term>All name-space providers.</term>
            </item>
            </list>
            <para>
            <c>Windows Phone 8:</c> The <c>WSASetServiceW</c> function is supported for Windows Phone Store apps on Windows Phone 8 and later.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>WSASetServiceW</c> function is supported for Windows Store apps on
            Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSASocket(Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY,Vanara.PInvoke.Ws2_32.SOCK,Vanara.PInvoke.Ws2_32.IPPROTO,Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO@,Vanara.PInvoke.Ws2_32.GROUP,Vanara.PInvoke.Ws2_32.WSA_FLAG)">
            <summary>The <c>WSASocket</c> function creates a socket that is bound to a specific transport-service provider.</summary>
            <param name="af">
            <para>The address family specification. Possible values for the address family are defined in the Winsock2.h header file.</para>
            <para>
            On the Windows SDK released for Windows Vista and later, the organization of header files has changed and the possible values
            for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in
            Winsock2.h, and should never be used directly.
            </para>
            <para>
            The values currently supported are AF_INET or AF_INET6, which are the Internet address family formats for IPv4 and IPv6. Other
            options for address family (AF_NETBIOS for use with NetBIOS, for example) are supported if a Windows Sockets service provider
            for the address family is installed. Note that the values for the AF_ address family and PF_ protocol family constants are
            identical (for example, <c>AF_INET</c> and <c>PF_INET</c>), so either constant can be used.
            </para>
            <para>The table below lists common values for address family although many other values are possible.</para>
            <list type="table">
            <listheader>
            <term>Af</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AF_UNSPEC 0</term>
            <term>The address family is unspecified.</term>
            </item>
            <item>
            <term>AF_INET 2</term>
            <term>The Internet Protocol version 4 (IPv4) address family.</term>
            </item>
            <item>
            <term>AF_IPX 6</term>
            <term>
            The IPX/SPX address family. This address family is only supported if the NWLink IPX/SPX NetBIOS Compatible Transport protocol is
            installed. This address family is not supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AF_APPLETALK 16</term>
            <term>
            The AppleTalk address family. This address family is only supported if the AppleTalk protocol is installed. This address family
            is not supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AF_NETBIOS 17</term>
            <term>
            The NetBIOS address family. This address family is only supported if the Windows Sockets provider for NetBIOS is installed. The
            Windows Sockets provider for NetBIOS is supported on 32-bit versions of Windows. This provider is installed by default on 32-bit
            versions of Windows. The Windows Sockets provider for NetBIOS is not supported on 64-bit versions of windows including Windows
            7, Windows Server 2008, Windows Vista, Windows Server 2003, or Windows XP. The Windows Sockets provider for NetBIOS only
            supports sockets where the type parameter is set to SOCK_DGRAM. The Windows Sockets provider for NetBIOS is not directly related
            to the NetBIOS programming interface. The NetBIOS programming interface is not supported on Windows Vista, Windows Server 2008,
            and later.
            </term>
            </item>
            <item>
            <term>AF_INET6 23</term>
            <term>The Internet Protocol version 6 (IPv6) address family.</term>
            </item>
            <item>
            <term>AF_IRDA 26</term>
            <term>
            The Infrared Data Association (IrDA) address family. This address family is only supported if the computer has an infrared port
            and driver installed.
            </term>
            </item>
            <item>
            <term>AF_BTH 32</term>
            <term>
            The Bluetooth address family. This address family is supported on Windows XP with SP2 or later if the computer has a Bluetooth
            adapter and driver installed.
            </term>
            </item>
            </list>
            </param>
            <param name="type">
            <para>The type specification for the new socket.</para>
            <para>Possible values for the socket type are defined in the Winsock2.h header file.</para>
            <para>The following table lists the possible values for the type parameter supported for Windows Sockets 2:</para>
            <list type="table">
            <listheader>
            <term>Type</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SOCK_STREAM 1</term>
            <term>
            A socket type that provides sequenced, reliable, two-way, connection-based byte streams with an OOB data transmission mechanism.
            This socket type uses the Transmission Control Protocol (TCP) for the Internet address family (AF_INET or AF_INET6).
            </term>
            </item>
            <item>
            <term>SOCK_DGRAM 2</term>
            <term>
            A socket type that supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length.
            This socket type uses the User Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).
            </term>
            </item>
            <item>
            <term>SOCK_RAW 3</term>
            <term>
            A socket type that provides a raw socket that allows an application to manipulate the next upper-layer protocol header. To
            manipulate the IPv4 header, the IP_HDRINCL socket option must be set on the socket. To manipulate the IPv6 header, the
            IPV6_HDRINCL socket option must be set on the socket.
            </term>
            </item>
            <item>
            <term>SOCK_RDM 4</term>
            <term>
            A socket type that provides a reliable message datagram. An example of this type is the Pragmatic General Multicast (PGM)
            multicast protocol implementation in Windows, often referred to as reliable multicast programming. This type value is only
            supported if the Reliable Multicast Protocol is installed.
            </term>
            </item>
            <item>
            <term>SOCK_SEQPACKET 5</term>
            <term>A socket type that provides a pseudo-stream packet based on datagrams.</term>
            </item>
            </list>
            <para>
            In Windows Sockets 2, new socket types were introduced. An application can dynamically discover the attributes of each available
            transport protocol through the WSAEnumProtocols function. So an application can determine the possible socket type and protocol
            options for an address family and use this information when specifying this parameter. Socket type definitions in the Winsock2.h
            and Ws2def.h header files will be periodically updated as new socket types, address families, and protocols are defined.
            </para>
            <para>In Windows Sockets 1.1, the only possible socket types are <c>SOCK_DGRAM</c> and <c>SOCK_STREAM</c>.</para>
            </param>
            <param name="protocol">
            <para>
            The protocol to be used. The possible options for the protocol parameter are specific to the address family and socket type
            specified. Possible values for the protocol are defined are defined in the Winsock2.h and Wsrm.h header files.
            </para>
            <para>
            On the Windows SDK released for Windows Vista and later,, the organization of header files has changed and this parameter can be
            one of the values from the <c>IPPROTO</c> enumeration type defined in the Ws2def.h header file. Note that the Ws2def.h header
            file is automatically included in Winsock2.h, and should never be used directly.
            </para>
            <para>
            If a value of 0 is specified, the caller does not wish to specify a protocol and the service provider will choose the protocol
            to use.
            </para>
            <para>
            When the af parameter is AF_INET or AF_INET6 and the type is <c>SOCK_RAW</c>, the value specified for the protocol is set in the
            protocol field of the IPv6 or IPv4 packet header.
            </para>
            <para>The table below lists common values for the protocol although many other values are possible.</para>
            <list type="table">
            <listheader>
            <term>protocol</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>IPPROTO_ICMP 1</term>
            <term>
            The Internet Control Message Protocol (ICMP). This is a possible value when the af parameter is AF_UNSPEC, AF_INET, or AF_INET6
            and the type parameter is SOCK_RAW or unspecified. This protocol value is supported on Windows XP and later.
            </term>
            </item>
            <item>
            <term>IPPROTO_IGMP 2</term>
            <term>
            The Internet Group Management Protocol (IGMP). This is a possible value when the af parameter is AF_UNSPEC, AF_INET, or AF_INET6
            and the type parameter is SOCK_RAW or unspecified. This protocol value is supported on Windows XP and later.
            </term>
            </item>
            <item>
            <term>BTHPROTO_RFCOMM 3</term>
            <term>
            The Bluetooth Radio Frequency Communications (Bluetooth RFCOMM) protocol. This is a possible value when the af parameter is
            AF_BTH and the type parameter is SOCK_STREAM. This protocol value is supported on Windows XP with SP2 or later.
            </term>
            </item>
            <item>
            <term>IPPROTO_TCP 6</term>
            <term>
            The Transmission Control Protocol (TCP). This is a possible value when the af parameter is AF_INET or AF_INET6 and the type
            parameter is SOCK_STREAM.
            </term>
            </item>
            <item>
            <term>IPPROTO_UDP 17</term>
            <term>
            The User Datagram Protocol (UDP). This is a possible value when the af parameter is AF_INET or AF_INET6 and the type parameter
            is SOCK_DGRAM.
            </term>
            </item>
            <item>
            <term>IPPROTO_ICMPV6 58</term>
            <term>
            The Internet Control Message Protocol Version 6 (ICMPv6). This is a possible value when the af parameter is AF_UNSPEC, AF_INET,
            or AF_INET6 and the type parameter is SOCK_RAW or unspecified. This protocol value is supported on Windows XP and later.
            </term>
            </item>
            <item>
            <term>IPPROTO_RM 113</term>
            <term>
            The PGM protocol for reliable multicast. This is a possible value when the af parameter is AF_INET and the type parameter is
            SOCK_RDM. On the Windows SDK released for Windows Vista and later, this protocol is also called IPPROTO_PGM. This protocol value
            is only supported if the Reliable Multicast Protocol is installed.
            </term>
            </item>
            </list>
            </param>
            <param name="lpProtocolInfo">
            A pointer to a WSAPROTOCOL_INFO structure that defines the characteristics of the socket to be created. If this parameter is not
            <c>NULL</c>, the socket will be bound to the provider associated with the indicated <c>WSAPROTOCOL_INFO</c> structure.
            </param>
            <param name="g">
            <para>An existing socket group ID or an appropriate action to take when creating a new socket and a new socket group.</para>
            <para>
            If g is an existing socket group ID, join the new socket to this socket group, provided all the requirements set by this group
            are met.
            </para>
            <para>If g is not an existing socket group ID, then the following values are possible.</para>
            <list type="table">
            <listheader>
            <term>g</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>No group operation is performed.</term>
            </item>
            <item>
            <term>SG_UNCONSTRAINED_GROUP 0x01</term>
            <term>
            Create an unconstrained socket group and have the new socket be the first member. For an unconstrained group, Winsock does not
            constrain all sockets in the socket group to have been created with the same value for the type and protocol parameters.
            </term>
            </item>
            <item>
            <term>SG_CONSTRAINED_GROUP 0x02</term>
            <term>
            Create a constrained socket group and have the new socket be the first member. For a contrained socket group, Winsock constrains
            all sockets in the socket group to have been created with the same value for the type and protocol parameters. A constrained
            socket group may consist only of connection-oriented sockets, and requires that connections on all grouped sockets be to the
            same address on the same host.
            </term>
            </item>
            </list>
            <para>
            <c>Note</c> The SG_UNCONSTRAINED_GROUP and SG_CONSTRAINED_GROUP constants are not currently defined in a public header file.
            </para>
            </param>
            <param name="dwFlags">
            <para>A set of flags used to specify additional socket attributes.</para>
            <para>A combination of these flags may be set, although some combinations are not allowed.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSA_FLAG_OVERLAPPED 0x01</term>
            <term>
            Create a socket that supports overlapped I/O operations. Most sockets should be created with this flag set. Overlapped sockets
            can utilize WSASend, WSASendTo, WSARecv, WSARecvFrom, and WSAIoctl for overlapped I/O operations, which allow multiple
            operations to be initiated and in progress simultaneously. All functions that allow overlapped operation (WSASend, WSARecv,
            WSASendTo, WSARecvFrom, WSAIoctl) also support nonoverlapped usage on an overlapped socket if the values for parameters related
            to overlapped operations are NULL.
            </term>
            </item>
            <item>
            <term>WSA_FLAG_MULTIPOINT_C_ROOT 0x02</term>
            <term>
            Create a socket that will be a c_root in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO structure
            for the transport provider that creates the socket supports a multipoint or multicast mechanism and the control plane for a
            multipoint session is rooted. This would be indicated by the dwServiceFlags1 member of the WSAPROTOCOL_INFO structure with the
            XP1_SUPPORT_MULTIPOINT and XP1_MULTIPOINT_CONTROL_PLANE flags set. When the lpProtocolInfo parameter is not NULL, the
            WSAPROTOCOL_INFO structure for the transport provider is pointed to by the lpProtocolInfo parameter. When the lpProtocolInfo
            parameter is NULL, the WSAPROTOCOL_INFO structure is based on the transport provider selected by the values specified for the
            af, type, and protocol parameters. Refer to Multipoint and Multicast Semantics for additional information on a multipoint session.
            </term>
            </item>
            <item>
            <term>WSA_FLAG_MULTIPOINT_C_LEAF 0x04</term>
            <term>
            Create a socket that will be a c_leaf in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO structure
            for the transport provider that creates the socket supports a multipoint or multicast mechanism and the control plane for a
            multipoint session is non-rooted. This would be indicated by the dwServiceFlags1 member of the WSAPROTOCOL_INFO structure with
            the XP1_SUPPORT_MULTIPOINT flag set and the XP1_MULTIPOINT_CONTROL_PLANE flag not set. When the lpProtocolInfo parameter is not
            NULL, the WSAPROTOCOL_INFO structure for the transport provider is pointed to by the lpProtocolInfo parameter. When the
            lpProtocolInfo parameter is NULL, the WSAPROTOCOL_INFO structure is based on the transport provider selected by the values
            specified for the af, type, and protocol parameters. Refer to Multipoint and Multicast Semantics for additional information on a
            multipoint session.
            </term>
            </item>
            <item>
            <term>WSA_FLAG_MULTIPOINT_D_ROOT 0x08</term>
            <term>
            Create a socket that will be a d_root in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO structure
            for the transport provider that creates the socket supports a multipoint or multicast mechanism and the data plane for a
            multipoint session is rooted. This would be indicated by the dwServiceFlags1 member of the WSAPROTOCOL_INFO structure with the
            XP1_SUPPORT_MULTIPOINT and XP1_MULTIPOINT_DATA_PLANE flags set. When the lpProtocolInfo parameter is not NULL, the
            WSAPROTOCOL_INFO structure for the transport provider is pointed to by the lpProtocolInfo parameter. When the lpProtocolInfo
            parameter is NULL, the WSAPROTOCOL_INFO structure is based on the transport provider selected by the values specified for the
            af, type, and protocol parameters. Refer to Multipoint and Multicast Semantics for additional information on a multipoint session.
            </term>
            </item>
            <item>
            <term>WSA_FLAG_MULTIPOINT_D_LEAF 0x10</term>
            <term>
            Create a socket that will be a d_leaf in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO structure
            for the transport provider that creates the socket supports a multipoint or multicast mechanism and the data plane for a
            multipoint session is non-rooted. This would be indicated by the dwServiceFlags1 member of the WSAPROTOCOL_INFO structure with
            the XP1_SUPPORT_MULTIPOINT flag set and the XP1_MULTIPOINT_DATA_PLANE flag not set. When the lpProtocolInfo parameter is not
            NULL, the WSAPROTOCOL_INFO structure for the transport provider is pointed to by the lpProtocolInfo parameter. When the
            lpProtocolInfo parameter is NULL, the WSAPROTOCOL_INFO structure is based on the transport provider selected by the values
            specified for the af, type, and protocol parameters. Refer to Multipoint and Multicast Semantics for additional information on a
            multipoint session.
            </term>
            </item>
            <item>
            <term>WSA_FLAG_ACCESS_SYSTEM_SECURITY 0x40</term>
            <term>
            Create a socket that allows the the ability to set a security descriptor on the socket that contains a security access control
            list (SACL) as opposed to just a discretionary access control list (DACL). SACLs are used for generating audits and alarms when
            an access check occurs on the object. For a socket, an access check occurs to determine whether the socket should be allowed to
            bind to a specific address specified to the bind function. The ACCESS_SYSTEM_SECURITY access right controls the ability to get
            or set the SACL in an object's security descriptor. The system grants this access right only if the SE_SECURITY_NAME privilege
            is enabled in the access token of the requesting thread.
            </term>
            </item>
            <item>
            <term>WSA_FLAG_NO_HANDLE_INHERIT 0x80</term>
            <term>
            Create a socket that is non-inheritable. A socket handle created by the WSASocket or the socket function is inheritable by
            default. When this flag is set, the socket handle is non-inheritable. The GetHandleInformation function can be used to determine
            if a socket handle was created with the WSA_FLAG_NO_HANDLE_INHERIT flag set. The GetHandleInformation function will return that
            the HANDLE_FLAG_INHERIT value is set. This flag is supported on Windows 7 with SP1, Windows Server 2008 R2 with SP1, and later
            </term>
            </item>
            </list>
            <para>
            <c>Important</c> For multipoint sockets, only one of <c>WSA_FLAG_MULTIPOINT_C_ROOT</c> or <c>WSA_FLAG_MULTIPOINT_C_LEAF</c>
            flags can be specified, and only one of <c>WSA_FLAG_MULTIPOINT_D_ROOT</c> or <c>WSA_FLAG_MULTIPOINT_D_LEAF</c> flags can be
            specified. Refer to Multipoint and Multicast Semantics for additional information.
            </para>
            </param>
            <returns>
            <para>
            If no error occurs, <c>WSASocket</c> returns a descriptor referencing the new socket. Otherwise, a value of INVALID_SOCKET is
            returned, and a specific error code can be retrieved by calling WSAGetLastError.
            </para>
            <para><c>Note</c> This error code description is Microsoft-specific.</para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEAFNOSUPPORT</term>
            <term>The specified address family is not supported.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The lpProtocolInfo parameter is not in a valid part of the process address space.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>This value is true for any of the following conditions.</term>
            </item>
            <item>
            <term>WSAEINVALIDPROVIDER</term>
            <term>The service provider returned a version other than 2.2.</term>
            </item>
            <item>
            <term>WSAEINVALIDPROCTABLE</term>
            <term>The service provider returned an invalid or incomplete procedure table to the WSPStartup.</term>
            </item>
            <item>
            <term>WSAEMFILE</term>
            <term>No more socket descriptors are available.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>No buffer space is available. The socket cannot be created.</term>
            </item>
            <item>
            <term>WSAEPROTONOSUPPORT</term>
            <term>The specified protocol is not supported.</term>
            </item>
            <item>
            <term>WSAEPROTOTYPE</term>
            <term>The specified protocol is the wrong type for this socket.</term>
            </item>
            <item>
            <term>WSAEPROVIDERFAILEDINIT</term>
            <term>
            The service provider failed to initialize. This error is returned if a layered service provider (LSP) or namespace provider was
            improperly installed or the provider fails to operate correctly.
            </term>
            </item>
            <item>
            <term>WSAESOCKTNOSUPPORT</term>
            <term>The specified socket type is not supported in this address family.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSASocket</c> function causes a socket descriptor and any related resources to be allocated and associated with a
            transport-service provider. Most sockets should be created with the <c>WSA_FLAG_OVERLAPPED</c> attribute set in the dwFlags
            parameter. A socket created with this attribute supports the use of overlapped I/O operations which provide higher performance.
            By default, a socket created with the <c>WSASocket</c> function will not have this overlapped attribute set. In contrast, the
            socket function creates a socket that supports overlapped I/O operations as the default behavior.
            </para>
            <para>
            If the lpProtocolInfo parameter is <c>NULL</c>, Winsock will utilize the first available transport-service provider that
            supports the requested combination of address family, socket type and protocol specified in the af, type, and protocol parameters.
            </para>
            <para>
            If the lpProtocolInfo parameter is not <c>NULL</c>, the socket will be bound to the provider associated with the indicated
            WSAPROTOCOL_INFO structure. In this instance, the application can supply the manifest constant <c>FROM_PROTOCOL_INFO</c> as the
            value for any of af, type, or protocol parameters. This indicates that the corresponding values from the indicated
            <c>WSAPROTOCOL_INFO</c> structure ( <c>iAddressFamily</c>, <c>iSocketType</c>, <c>iProtocol</c>) are to be assumed. In any case,
            the values specified for af, type, and protocol are passed unmodified to the transport-service provider.
            </para>
            <para>
            When selecting a protocol and its supporting service provider based on af, type, and protocol, this procedure will only choose a
            base protocol or a protocol chain, not a protocol layer by itself. Unchained protocol layers are not considered to have partial
            matches on type or af, either. That is, they do not lead to an error code of WSAEAFNOSUPPORT or WSAEPROTONOSUPPORT, if no
            suitable protocol is found.
            </para>
            <para>
            <c>Note</c> The manifest constant <c>AF_UNSPEC</c> continues to be defined in the header file but its use is strongly
            discouraged, as this can cause ambiguity in interpreting the value of the protocol parameter.
            </para>
            <para>
            Applications are encouraged to use <c>AF_INET6</c> for the af parameter and create a dual-mode socket that can be used with both
            IPv4 and IPv6.
            </para>
            <para>
            If a socket is created using the <c>WSASocket</c> function, then the dwFlags parameter must have the <c>WSA_FLAG_OVERLAPPED</c>
            attribute set for the <c>SO_RCVTIMEO</c> or <c>SO_SNDTIMEO</c> socket options to function properly. Otherwise the timeout never
            takes effect on the socket.
            </para>
            <para>
            Connection-oriented sockets such as <c>SOCK_STREAM</c> provide full-duplex connections, and must be in a connected state before
            any data can be sent or received on them. A connection to a specified socket is established with a connect or WSAConnect
            function call. Once connected, data can be transferred using send/WSASend and recv/WSARecv calls. When a session has been
            completed, the closesocket function should be called to release the resources associated with the socket. For
            connection-oriented sockets, the shutdown function should be called to stop data transfer on the socket before calling the
            <c>closesocket</c> function.
            </para>
            <para>
            The communications protocols used to implement a reliable, connection-oriented socket ensure that data is not lost or
            duplicated. If data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable length
            of time, the connection is considered broken and subsequent calls will fail with the error code set to WSAETIMEDOUT.
            </para>
            <para>
            Connectionless, message-oriented sockets allow sending and receiving of datagrams to and from arbitrary peers using
            sendto/WSASendTo and recvfrom/WSARecvFrom. If such a socket is connected to a specific peer, datagrams can be sent to that peer
            using send/WSASend and can be received from (only) this peer using recv/WSARecv.
            </para>
            <para>
            Support for sockets with type <c>SOCK_RAW</c> is not required, but service providers are encouraged to support raw sockets
            whenever possible.
            </para>
            <para>
            The <c>WSASocket</c> function can be used to create a socket to be used by a service so that if another socket tries to bind to
            the same port used by the service, and audit record is generared. To enable this option, an application would need to do the following:
            </para>
            <list type="bullet">
            <item>
            <term>
            Call the AdjustTokenPrivileges function to enable the <c>SE_SECURITY_NAME</c> privilege in the access token for the process.
            This privilege is required to set the <c>ACCESS_SYSTEM_SECURITY</c> access rights on the security descriptor for an object.
            </term>
            </item>
            <item>
            <term>
            Call the <c>WSASocket</c> function to create a socket with dwFlag with the <c>WSA_FLAG_ACCESS_SYSTEM_SECURITY</c> option set.
            The <c>WSASocket</c> function will fail if the AdjustTokenPrivileges function is not called first to enable the
            <c>SE_SECURITY_NAME</c> privilege needed for this operation.
            </term>
            </item>
            <item>
            <term>
            Call the SetSecurityInfo function to set a security descriptor with a System Access Control List (SACL) on the socket. The
            socket handle returned by the <c>WSASocket</c> function is passed in the handle parameter. If the function succeeds, this will
            set the the <c>ACCESS_SYSTEM_SECURITY</c> access right on the security descriptor for the socket.
            </term>
            </item>
            <item>
            <term>
            Call the bindfunction to bind the socket to a specific port. If the <c>bind</c> function succeeds, then an audit entry is
            generated if another socket tries to bind to the same port.
            </term>
            </item>
            <item>
            <term>
            Call the AdjustTokenPrivileges function to remove the <c>SE_SECURITY_NAME</c> privilege in the access token for the process,
            since this is no longer needed.
            </term>
            </item>
            </list>
            <para>
            For more information on <c>ACCESS_SYSTEM_SECURITY</c>, see SACL Access Right and Audit Generation in the Authorization documentation.
            </para>
            <para>Socket Groups</para>
            <para>
            WinSock 2 introduced the notion of a socket group as a means for an application, or cooperating set of applications, to indicate
            to an underlying service provider that a particular set of sockets are related and that the group thus formed has certain
            attributes. Group attributes include relative priorities of the individual sockets within the group and a group quality of
            service specification.
            </para>
            <para>
            Applications that need to exchange multimedia streams over the network are an example where being able to establish a specific
            relationship among a set of sockets could be beneficial. It is up to the transport on how to treat socket groups.
            </para>
            <para>
            The <c>WSASocket</c> and WSAAccept functions can be used to explicitly create and join a socket group when creating a new
            socket. The socket group ID for a socket can be retrieved by using the getsockopt function with level parameter set to
            SOL_SOCKET and the optname parameter set to <c>SO_GROUP_ID</c>. A socket group and its associated socket group ID remain valid
            until the last socket belonging to this socket group is closed. Socket group IDs are unique across all processes for a given
            service provider. A socket group of zero indicates that the socket is not member of a socket group.
            </para>
            <para>
            The relative group priority of a socket group can be accessed by using the getsockopt function with the level parameter set to
            SOL_SOCKET and the optname parameter set to <c>SO_GROUP_PRIORITY</c>. The relative group priority of a socket group can be set
            by using setsockopt with the level parameter set to SOL_SOCKET and the optname parameter set to <c>SO_GROUP_PRIORITY</c>.
            </para>
            <para>
            The Winsock provider included with Windows allows the creation of socket groups and it enforces the SG_CONSTRAINED_GROUP. All
            sockets in a constrained socket group must be created with the same value for the type and protocol parameters. A constrained
            socket group may consist only of connection-oriented sockets, and requires that connections on all grouped sockets be to the
            same address on the same host. This is the only restriction applied to a socket group by the Winsock provider included with
            Windows. The socket group priority is not currently used by the Winsock provider or the TCP/IP stack included with Windows.
            </para>
            <para>Example Code</para>
            <para>The following example demonstrates the use of the <c>WSASocket</c> function.</para>
            <para>
            <c>Windows Phone 8:</c> The <c>WSASocketW</c> function is supported for Windows Phone Store apps on Windows Phone 8 and later.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>WSASocketW</c> function is supported for Windows Store apps on
            Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSASocket(Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY,Vanara.PInvoke.Ws2_32.SOCK,Vanara.PInvoke.Ws2_32.IPPROTO,System.IntPtr,Vanara.PInvoke.Ws2_32.GROUP,Vanara.PInvoke.Ws2_32.WSA_FLAG)">
            <summary>The <c>WSASocket</c> function creates a socket that is bound to a specific transport-service provider.</summary>
            <param name="af">
            <para>The address family specification. Possible values for the address family are defined in the Winsock2.h header file.</para>
            <para>
            On the Windows SDK released for Windows Vista and later, the organization of header files has changed and the possible values
            for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in
            Winsock2.h, and should never be used directly.
            </para>
            <para>
            The values currently supported are AF_INET or AF_INET6, which are the Internet address family formats for IPv4 and IPv6. Other
            options for address family (AF_NETBIOS for use with NetBIOS, for example) are supported if a Windows Sockets service provider
            for the address family is installed. Note that the values for the AF_ address family and PF_ protocol family constants are
            identical (for example, <c>AF_INET</c> and <c>PF_INET</c>), so either constant can be used.
            </para>
            <para>The table below lists common values for address family although many other values are possible.</para>
            <list type="table">
            <listheader>
            <term>Af</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AF_UNSPEC 0</term>
            <term>The address family is unspecified.</term>
            </item>
            <item>
            <term>AF_INET 2</term>
            <term>The Internet Protocol version 4 (IPv4) address family.</term>
            </item>
            <item>
            <term>AF_IPX 6</term>
            <term>
            The IPX/SPX address family. This address family is only supported if the NWLink IPX/SPX NetBIOS Compatible Transport protocol is
            installed. This address family is not supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AF_APPLETALK 16</term>
            <term>
            The AppleTalk address family. This address family is only supported if the AppleTalk protocol is installed. This address family
            is not supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AF_NETBIOS 17</term>
            <term>
            The NetBIOS address family. This address family is only supported if the Windows Sockets provider for NetBIOS is installed. The
            Windows Sockets provider for NetBIOS is supported on 32-bit versions of Windows. This provider is installed by default on 32-bit
            versions of Windows. The Windows Sockets provider for NetBIOS is not supported on 64-bit versions of windows including Windows
            7, Windows Server 2008, Windows Vista, Windows Server 2003, or Windows XP. The Windows Sockets provider for NetBIOS only
            supports sockets where the type parameter is set to SOCK_DGRAM. The Windows Sockets provider for NetBIOS is not directly related
            to the NetBIOS programming interface. The NetBIOS programming interface is not supported on Windows Vista, Windows Server 2008,
            and later.
            </term>
            </item>
            <item>
            <term>AF_INET6 23</term>
            <term>The Internet Protocol version 6 (IPv6) address family.</term>
            </item>
            <item>
            <term>AF_IRDA 26</term>
            <term>
            The Infrared Data Association (IrDA) address family. This address family is only supported if the computer has an infrared port
            and driver installed.
            </term>
            </item>
            <item>
            <term>AF_BTH 32</term>
            <term>
            The Bluetooth address family. This address family is supported on Windows XP with SP2 or later if the computer has a Bluetooth
            adapter and driver installed.
            </term>
            </item>
            </list>
            </param>
            <param name="type">
            <para>The type specification for the new socket.</para>
            <para>Possible values for the socket type are defined in the Winsock2.h header file.</para>
            <para>The following table lists the possible values for the type parameter supported for Windows Sockets 2:</para>
            <list type="table">
            <listheader>
            <term>Type</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SOCK_STREAM 1</term>
            <term>
            A socket type that provides sequenced, reliable, two-way, connection-based byte streams with an OOB data transmission mechanism.
            This socket type uses the Transmission Control Protocol (TCP) for the Internet address family (AF_INET or AF_INET6).
            </term>
            </item>
            <item>
            <term>SOCK_DGRAM 2</term>
            <term>
            A socket type that supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length.
            This socket type uses the User Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).
            </term>
            </item>
            <item>
            <term>SOCK_RAW 3</term>
            <term>
            A socket type that provides a raw socket that allows an application to manipulate the next upper-layer protocol header. To
            manipulate the IPv4 header, the IP_HDRINCL socket option must be set on the socket. To manipulate the IPv6 header, the
            IPV6_HDRINCL socket option must be set on the socket.
            </term>
            </item>
            <item>
            <term>SOCK_RDM 4</term>
            <term>
            A socket type that provides a reliable message datagram. An example of this type is the Pragmatic General Multicast (PGM)
            multicast protocol implementation in Windows, often referred to as reliable multicast programming. This type value is only
            supported if the Reliable Multicast Protocol is installed.
            </term>
            </item>
            <item>
            <term>SOCK_SEQPACKET 5</term>
            <term>A socket type that provides a pseudo-stream packet based on datagrams.</term>
            </item>
            </list>
            <para>
            In Windows Sockets 2, new socket types were introduced. An application can dynamically discover the attributes of each available
            transport protocol through the WSAEnumProtocols function. So an application can determine the possible socket type and protocol
            options for an address family and use this information when specifying this parameter. Socket type definitions in the Winsock2.h
            and Ws2def.h header files will be periodically updated as new socket types, address families, and protocols are defined.
            </para>
            <para>In Windows Sockets 1.1, the only possible socket types are <c>SOCK_DGRAM</c> and <c>SOCK_STREAM</c>.</para>
            </param>
            <param name="protocol">
            <para>
            The protocol to be used. The possible options for the protocol parameter are specific to the address family and socket type
            specified. Possible values for the protocol are defined are defined in the Winsock2.h and Wsrm.h header files.
            </para>
            <para>
            On the Windows SDK released for Windows Vista and later,, the organization of header files has changed and this parameter can be
            one of the values from the <c>IPPROTO</c> enumeration type defined in the Ws2def.h header file. Note that the Ws2def.h header
            file is automatically included in Winsock2.h, and should never be used directly.
            </para>
            <para>
            If a value of 0 is specified, the caller does not wish to specify a protocol and the service provider will choose the protocol
            to use.
            </para>
            <para>
            When the af parameter is AF_INET or AF_INET6 and the type is <c>SOCK_RAW</c>, the value specified for the protocol is set in the
            protocol field of the IPv6 or IPv4 packet header.
            </para>
            <para>The table below lists common values for the protocol although many other values are possible.</para>
            <list type="table">
            <listheader>
            <term>protocol</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>IPPROTO_ICMP 1</term>
            <term>
            The Internet Control Message Protocol (ICMP). This is a possible value when the af parameter is AF_UNSPEC, AF_INET, or AF_INET6
            and the type parameter is SOCK_RAW or unspecified. This protocol value is supported on Windows XP and later.
            </term>
            </item>
            <item>
            <term>IPPROTO_IGMP 2</term>
            <term>
            The Internet Group Management Protocol (IGMP). This is a possible value when the af parameter is AF_UNSPEC, AF_INET, or AF_INET6
            and the type parameter is SOCK_RAW or unspecified. This protocol value is supported on Windows XP and later.
            </term>
            </item>
            <item>
            <term>BTHPROTO_RFCOMM 3</term>
            <term>
            The Bluetooth Radio Frequency Communications (Bluetooth RFCOMM) protocol. This is a possible value when the af parameter is
            AF_BTH and the type parameter is SOCK_STREAM. This protocol value is supported on Windows XP with SP2 or later.
            </term>
            </item>
            <item>
            <term>IPPROTO_TCP 6</term>
            <term>
            The Transmission Control Protocol (TCP). This is a possible value when the af parameter is AF_INET or AF_INET6 and the type
            parameter is SOCK_STREAM.
            </term>
            </item>
            <item>
            <term>IPPROTO_UDP 17</term>
            <term>
            The User Datagram Protocol (UDP). This is a possible value when the af parameter is AF_INET or AF_INET6 and the type parameter
            is SOCK_DGRAM.
            </term>
            </item>
            <item>
            <term>IPPROTO_ICMPV6 58</term>
            <term>
            The Internet Control Message Protocol Version 6 (ICMPv6). This is a possible value when the af parameter is AF_UNSPEC, AF_INET,
            or AF_INET6 and the type parameter is SOCK_RAW or unspecified. This protocol value is supported on Windows XP and later.
            </term>
            </item>
            <item>
            <term>IPPROTO_RM 113</term>
            <term>
            The PGM protocol for reliable multicast. This is a possible value when the af parameter is AF_INET and the type parameter is
            SOCK_RDM. On the Windows SDK released for Windows Vista and later, this protocol is also called IPPROTO_PGM. This protocol value
            is only supported if the Reliable Multicast Protocol is installed.
            </term>
            </item>
            </list>
            </param>
            <param name="lpProtocolInfo">
            A pointer to a WSAPROTOCOL_INFO structure that defines the characteristics of the socket to be created. If this parameter is not
            <c>NULL</c>, the socket will be bound to the provider associated with the indicated <c>WSAPROTOCOL_INFO</c> structure.
            </param>
            <param name="g">
            <para>An existing socket group ID or an appropriate action to take when creating a new socket and a new socket group.</para>
            <para>
            If g is an existing socket group ID, join the new socket to this socket group, provided all the requirements set by this group
            are met.
            </para>
            <para>If g is not an existing socket group ID, then the following values are possible.</para>
            <list type="table">
            <listheader>
            <term>g</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>No group operation is performed.</term>
            </item>
            <item>
            <term>SG_UNCONSTRAINED_GROUP 0x01</term>
            <term>
            Create an unconstrained socket group and have the new socket be the first member. For an unconstrained group, Winsock does not
            constrain all sockets in the socket group to have been created with the same value for the type and protocol parameters.
            </term>
            </item>
            <item>
            <term>SG_CONSTRAINED_GROUP 0x02</term>
            <term>
            Create a constrained socket group and have the new socket be the first member. For a contrained socket group, Winsock constrains
            all sockets in the socket group to have been created with the same value for the type and protocol parameters. A constrained
            socket group may consist only of connection-oriented sockets, and requires that connections on all grouped sockets be to the
            same address on the same host.
            </term>
            </item>
            </list>
            <para>
            <c>Note</c> The SG_UNCONSTRAINED_GROUP and SG_CONSTRAINED_GROUP constants are not currently defined in a public header file.
            </para>
            </param>
            <param name="dwFlags">
            <para>A set of flags used to specify additional socket attributes.</para>
            <para>A combination of these flags may be set, although some combinations are not allowed.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSA_FLAG_OVERLAPPED 0x01</term>
            <term>
            Create a socket that supports overlapped I/O operations. Most sockets should be created with this flag set. Overlapped sockets
            can utilize WSASend, WSASendTo, WSARecv, WSARecvFrom, and WSAIoctl for overlapped I/O operations, which allow multiple
            operations to be initiated and in progress simultaneously. All functions that allow overlapped operation (WSASend, WSARecv,
            WSASendTo, WSARecvFrom, WSAIoctl) also support nonoverlapped usage on an overlapped socket if the values for parameters related
            to overlapped operations are NULL.
            </term>
            </item>
            <item>
            <term>WSA_FLAG_MULTIPOINT_C_ROOT 0x02</term>
            <term>
            Create a socket that will be a c_root in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO structure
            for the transport provider that creates the socket supports a multipoint or multicast mechanism and the control plane for a
            multipoint session is rooted. This would be indicated by the dwServiceFlags1 member of the WSAPROTOCOL_INFO structure with the
            XP1_SUPPORT_MULTIPOINT and XP1_MULTIPOINT_CONTROL_PLANE flags set. When the lpProtocolInfo parameter is not NULL, the
            WSAPROTOCOL_INFO structure for the transport provider is pointed to by the lpProtocolInfo parameter. When the lpProtocolInfo
            parameter is NULL, the WSAPROTOCOL_INFO structure is based on the transport provider selected by the values specified for the
            af, type, and protocol parameters. Refer to Multipoint and Multicast Semantics for additional information on a multipoint session.
            </term>
            </item>
            <item>
            <term>WSA_FLAG_MULTIPOINT_C_LEAF 0x04</term>
            <term>
            Create a socket that will be a c_leaf in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO structure
            for the transport provider that creates the socket supports a multipoint or multicast mechanism and the control plane for a
            multipoint session is non-rooted. This would be indicated by the dwServiceFlags1 member of the WSAPROTOCOL_INFO structure with
            the XP1_SUPPORT_MULTIPOINT flag set and the XP1_MULTIPOINT_CONTROL_PLANE flag not set. When the lpProtocolInfo parameter is not
            NULL, the WSAPROTOCOL_INFO structure for the transport provider is pointed to by the lpProtocolInfo parameter. When the
            lpProtocolInfo parameter is NULL, the WSAPROTOCOL_INFO structure is based on the transport provider selected by the values
            specified for the af, type, and protocol parameters. Refer to Multipoint and Multicast Semantics for additional information on a
            multipoint session.
            </term>
            </item>
            <item>
            <term>WSA_FLAG_MULTIPOINT_D_ROOT 0x08</term>
            <term>
            Create a socket that will be a d_root in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO structure
            for the transport provider that creates the socket supports a multipoint or multicast mechanism and the data plane for a
            multipoint session is rooted. This would be indicated by the dwServiceFlags1 member of the WSAPROTOCOL_INFO structure with the
            XP1_SUPPORT_MULTIPOINT and XP1_MULTIPOINT_DATA_PLANE flags set. When the lpProtocolInfo parameter is not NULL, the
            WSAPROTOCOL_INFO structure for the transport provider is pointed to by the lpProtocolInfo parameter. When the lpProtocolInfo
            parameter is NULL, the WSAPROTOCOL_INFO structure is based on the transport provider selected by the values specified for the
            af, type, and protocol parameters. Refer to Multipoint and Multicast Semantics for additional information on a multipoint session.
            </term>
            </item>
            <item>
            <term>WSA_FLAG_MULTIPOINT_D_LEAF 0x10</term>
            <term>
            Create a socket that will be a d_leaf in a multipoint session. This attribute is only allowed if the WSAPROTOCOL_INFO structure
            for the transport provider that creates the socket supports a multipoint or multicast mechanism and the data plane for a
            multipoint session is non-rooted. This would be indicated by the dwServiceFlags1 member of the WSAPROTOCOL_INFO structure with
            the XP1_SUPPORT_MULTIPOINT flag set and the XP1_MULTIPOINT_DATA_PLANE flag not set. When the lpProtocolInfo parameter is not
            NULL, the WSAPROTOCOL_INFO structure for the transport provider is pointed to by the lpProtocolInfo parameter. When the
            lpProtocolInfo parameter is NULL, the WSAPROTOCOL_INFO structure is based on the transport provider selected by the values
            specified for the af, type, and protocol parameters. Refer to Multipoint and Multicast Semantics for additional information on a
            multipoint session.
            </term>
            </item>
            <item>
            <term>WSA_FLAG_ACCESS_SYSTEM_SECURITY 0x40</term>
            <term>
            Create a socket that allows the the ability to set a security descriptor on the socket that contains a security access control
            list (SACL) as opposed to just a discretionary access control list (DACL). SACLs are used for generating audits and alarms when
            an access check occurs on the object. For a socket, an access check occurs to determine whether the socket should be allowed to
            bind to a specific address specified to the bind function. The ACCESS_SYSTEM_SECURITY access right controls the ability to get
            or set the SACL in an object's security descriptor. The system grants this access right only if the SE_SECURITY_NAME privilege
            is enabled in the access token of the requesting thread.
            </term>
            </item>
            <item>
            <term>WSA_FLAG_NO_HANDLE_INHERIT 0x80</term>
            <term>
            Create a socket that is non-inheritable. A socket handle created by the WSASocket or the socket function is inheritable by
            default. When this flag is set, the socket handle is non-inheritable. The GetHandleInformation function can be used to determine
            if a socket handle was created with the WSA_FLAG_NO_HANDLE_INHERIT flag set. The GetHandleInformation function will return that
            the HANDLE_FLAG_INHERIT value is set. This flag is supported on Windows 7 with SP1, Windows Server 2008 R2 with SP1, and later
            </term>
            </item>
            </list>
            <para>
            <c>Important</c> For multipoint sockets, only one of <c>WSA_FLAG_MULTIPOINT_C_ROOT</c> or <c>WSA_FLAG_MULTIPOINT_C_LEAF</c>
            flags can be specified, and only one of <c>WSA_FLAG_MULTIPOINT_D_ROOT</c> or <c>WSA_FLAG_MULTIPOINT_D_LEAF</c> flags can be
            specified. Refer to Multipoint and Multicast Semantics for additional information.
            </para>
            </param>
            <returns>
            <para>
            If no error occurs, <c>WSASocket</c> returns a descriptor referencing the new socket. Otherwise, a value of INVALID_SOCKET is
            returned, and a specific error code can be retrieved by calling WSAGetLastError.
            </para>
            <para><c>Note</c> This error code description is Microsoft-specific.</para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEAFNOSUPPORT</term>
            <term>The specified address family is not supported.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The lpProtocolInfo parameter is not in a valid part of the process address space.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>This value is true for any of the following conditions.</term>
            </item>
            <item>
            <term>WSAEINVALIDPROVIDER</term>
            <term>The service provider returned a version other than 2.2.</term>
            </item>
            <item>
            <term>WSAEINVALIDPROCTABLE</term>
            <term>The service provider returned an invalid or incomplete procedure table to the WSPStartup.</term>
            </item>
            <item>
            <term>WSAEMFILE</term>
            <term>No more socket descriptors are available.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>No buffer space is available. The socket cannot be created.</term>
            </item>
            <item>
            <term>WSAEPROTONOSUPPORT</term>
            <term>The specified protocol is not supported.</term>
            </item>
            <item>
            <term>WSAEPROTOTYPE</term>
            <term>The specified protocol is the wrong type for this socket.</term>
            </item>
            <item>
            <term>WSAEPROVIDERFAILEDINIT</term>
            <term>
            The service provider failed to initialize. This error is returned if a layered service provider (LSP) or namespace provider was
            improperly installed or the provider fails to operate correctly.
            </term>
            </item>
            <item>
            <term>WSAESOCKTNOSUPPORT</term>
            <term>The specified socket type is not supported in this address family.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSASocket</c> function causes a socket descriptor and any related resources to be allocated and associated with a
            transport-service provider. Most sockets should be created with the <c>WSA_FLAG_OVERLAPPED</c> attribute set in the dwFlags
            parameter. A socket created with this attribute supports the use of overlapped I/O operations which provide higher performance.
            By default, a socket created with the <c>WSASocket</c> function will not have this overlapped attribute set. In contrast, the
            socket function creates a socket that supports overlapped I/O operations as the default behavior.
            </para>
            <para>
            If the lpProtocolInfo parameter is <c>NULL</c>, Winsock will utilize the first available transport-service provider that
            supports the requested combination of address family, socket type and protocol specified in the af, type, and protocol parameters.
            </para>
            <para>
            If the lpProtocolInfo parameter is not <c>NULL</c>, the socket will be bound to the provider associated with the indicated
            WSAPROTOCOL_INFO structure. In this instance, the application can supply the manifest constant <c>FROM_PROTOCOL_INFO</c> as the
            value for any of af, type, or protocol parameters. This indicates that the corresponding values from the indicated
            <c>WSAPROTOCOL_INFO</c> structure ( <c>iAddressFamily</c>, <c>iSocketType</c>, <c>iProtocol</c>) are to be assumed. In any case,
            the values specified for af, type, and protocol are passed unmodified to the transport-service provider.
            </para>
            <para>
            When selecting a protocol and its supporting service provider based on af, type, and protocol, this procedure will only choose a
            base protocol or a protocol chain, not a protocol layer by itself. Unchained protocol layers are not considered to have partial
            matches on type or af, either. That is, they do not lead to an error code of WSAEAFNOSUPPORT or WSAEPROTONOSUPPORT, if no
            suitable protocol is found.
            </para>
            <para>
            <c>Note</c> The manifest constant <c>AF_UNSPEC</c> continues to be defined in the header file but its use is strongly
            discouraged, as this can cause ambiguity in interpreting the value of the protocol parameter.
            </para>
            <para>
            Applications are encouraged to use <c>AF_INET6</c> for the af parameter and create a dual-mode socket that can be used with both
            IPv4 and IPv6.
            </para>
            <para>
            If a socket is created using the <c>WSASocket</c> function, then the dwFlags parameter must have the <c>WSA_FLAG_OVERLAPPED</c>
            attribute set for the <c>SO_RCVTIMEO</c> or <c>SO_SNDTIMEO</c> socket options to function properly. Otherwise the timeout never
            takes effect on the socket.
            </para>
            <para>
            Connection-oriented sockets such as <c>SOCK_STREAM</c> provide full-duplex connections, and must be in a connected state before
            any data can be sent or received on them. A connection to a specified socket is established with a connect or WSAConnect
            function call. Once connected, data can be transferred using send/WSASend and recv/WSARecv calls. When a session has been
            completed, the closesocket function should be called to release the resources associated with the socket. For
            connection-oriented sockets, the shutdown function should be called to stop data transfer on the socket before calling the
            <c>closesocket</c> function.
            </para>
            <para>
            The communications protocols used to implement a reliable, connection-oriented socket ensure that data is not lost or
            duplicated. If data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable length
            of time, the connection is considered broken and subsequent calls will fail with the error code set to WSAETIMEDOUT.
            </para>
            <para>
            Connectionless, message-oriented sockets allow sending and receiving of datagrams to and from arbitrary peers using
            sendto/WSASendTo and recvfrom/WSARecvFrom. If such a socket is connected to a specific peer, datagrams can be sent to that peer
            using send/WSASend and can be received from (only) this peer using recv/WSARecv.
            </para>
            <para>
            Support for sockets with type <c>SOCK_RAW</c> is not required, but service providers are encouraged to support raw sockets
            whenever possible.
            </para>
            <para>
            The <c>WSASocket</c> function can be used to create a socket to be used by a service so that if another socket tries to bind to
            the same port used by the service, and audit record is generared. To enable this option, an application would need to do the following:
            </para>
            <list type="bullet">
            <item>
            <term>
            Call the AdjustTokenPrivileges function to enable the <c>SE_SECURITY_NAME</c> privilege in the access token for the process.
            This privilege is required to set the <c>ACCESS_SYSTEM_SECURITY</c> access rights on the security descriptor for an object.
            </term>
            </item>
            <item>
            <term>
            Call the <c>WSASocket</c> function to create a socket with dwFlag with the <c>WSA_FLAG_ACCESS_SYSTEM_SECURITY</c> option set.
            The <c>WSASocket</c> function will fail if the AdjustTokenPrivileges function is not called first to enable the
            <c>SE_SECURITY_NAME</c> privilege needed for this operation.
            </term>
            </item>
            <item>
            <term>
            Call the SetSecurityInfo function to set a security descriptor with a System Access Control List (SACL) on the socket. The
            socket handle returned by the <c>WSASocket</c> function is passed in the handle parameter. If the function succeeds, this will
            set the the <c>ACCESS_SYSTEM_SECURITY</c> access right on the security descriptor for the socket.
            </term>
            </item>
            <item>
            <term>
            Call the bindfunction to bind the socket to a specific port. If the <c>bind</c> function succeeds, then an audit entry is
            generated if another socket tries to bind to the same port.
            </term>
            </item>
            <item>
            <term>
            Call the AdjustTokenPrivileges function to remove the <c>SE_SECURITY_NAME</c> privilege in the access token for the process,
            since this is no longer needed.
            </term>
            </item>
            </list>
            <para>
            For more information on <c>ACCESS_SYSTEM_SECURITY</c>, see SACL Access Right and Audit Generation in the Authorization documentation.
            </para>
            <para>Socket Groups</para>
            <para>
            WinSock 2 introduced the notion of a socket group as a means for an application, or cooperating set of applications, to indicate
            to an underlying service provider that a particular set of sockets are related and that the group thus formed has certain
            attributes. Group attributes include relative priorities of the individual sockets within the group and a group quality of
            service specification.
            </para>
            <para>
            Applications that need to exchange multimedia streams over the network are an example where being able to establish a specific
            relationship among a set of sockets could be beneficial. It is up to the transport on how to treat socket groups.
            </para>
            <para>
            The <c>WSASocket</c> and WSAAccept functions can be used to explicitly create and join a socket group when creating a new
            socket. The socket group ID for a socket can be retrieved by using the getsockopt function with level parameter set to
            SOL_SOCKET and the optname parameter set to <c>SO_GROUP_ID</c>. A socket group and its associated socket group ID remain valid
            until the last socket belonging to this socket group is closed. Socket group IDs are unique across all processes for a given
            service provider. A socket group of zero indicates that the socket is not member of a socket group.
            </para>
            <para>
            The relative group priority of a socket group can be accessed by using the getsockopt function with the level parameter set to
            SOL_SOCKET and the optname parameter set to <c>SO_GROUP_PRIORITY</c>. The relative group priority of a socket group can be set
            by using setsockopt with the level parameter set to SOL_SOCKET and the optname parameter set to <c>SO_GROUP_PRIORITY</c>.
            </para>
            <para>
            The Winsock provider included with Windows allows the creation of socket groups and it enforces the SG_CONSTRAINED_GROUP. All
            sockets in a constrained socket group must be created with the same value for the type and protocol parameters. A constrained
            socket group may consist only of connection-oriented sockets, and requires that connections on all grouped sockets be to the
            same address on the same host. This is the only restriction applied to a socket group by the Winsock provider included with
            Windows. The socket group priority is not currently used by the Winsock provider or the TCP/IP stack included with Windows.
            </para>
            <para>Example Code</para>
            <para>The following example demonstrates the use of the <c>WSASocket</c> function.</para>
            <para>
            <c>Windows Phone 8:</c> The <c>WSASocketW</c> function is supported for Windows Phone Store apps on Windows Phone 8 and later.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>WSASocketW</c> function is supported for Windows Store apps on
            Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAStartup(System.UInt16,Vanara.PInvoke.Ws2_32.WSADATA@)">
            <summary>The <c>WSAStartup</c> function initiates use of the Winsock DLL by a process.</summary>
            <param name="wVersionRequired">TBD</param>
            <param name="lpWSAData">A pointer to the WSADATA data structure that is to receive details of the Windows Sockets implementation.</param>
            <returns>
            <para>If successful, the <c>WSAStartup</c> function returns zero. Otherwise, it returns one of the error codes listed below.</para>
            <para>
            The <c>WSAStartup</c> function directly returns the extended error code in the return value for this function. A call to the
            WSAGetLastError function is not needed and should not be used.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSASYSNOTREADY</term>
            <term>The underlying network subsystem is not ready for network communication.</term>
            </item>
            <item>
            <term>WSAVERNOTSUPPORTED</term>
            <term>The version of Windows Sockets support requested is not provided by this particular Windows Sockets implementation.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 operation is in progress.</term>
            </item>
            <item>
            <term>WSAEPROCLIM</term>
            <term>A limit on the number of tasks supported by the Windows Sockets implementation has been reached.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The lpWSAData parameter is not a valid pointer.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAStartup</c> function must be the first Windows Sockets function called by an application or DLL. It allows an
            application or DLL to specify the version of Windows Sockets required and retrieve details of the specific Windows Sockets
            implementation. The application or DLL can only issue further Windows Sockets functions after successfully calling <c>WSAStartup</c>.
            </para>
            <para>
            In order to support various Windows Sockets implementations and applications that can have functional differences from the
            latest version of Windows Sockets specification, a negotiation takes place in <c>WSAStartup</c>. The caller of <c>WSAStartup</c>
            passes in the wVersionRequested parameter the highest version of the Windows Sockets specification that the application
            supports. The Winsock DLL indicates the highest version of the Windows Sockets specification that it can support in its
            response. The Winsock DLL also replies with version of the Windows Sockets specification that it expects the caller to use.
            </para>
            <para>
            When an application or DLL calls the <c>WSAStartup</c> function, the Winsock DLL examines the version of the Windows Sockets
            specification requested by the application passed in the wVersionRequested parameter. If the version requested by the
            application is equal to or higher than the lowest version supported by the Winsock DLL, the call succeeds and the Winsock DLL
            returns detailed information in the WSADATA structure pointed to by the lpWSAData parameter. The <c>wHighVersion</c> member of
            the <c>WSADATA</c> structure indicates the highest version of the Windows Sockets specification that the Winsock DLL supports.
            The <c>wVersion</c> member of the <c>WSADATA</c> structure indicates the version of the Windows Sockets specification that the
            Winsock DLL expects the caller to use.
            </para>
            <para>
            If the <c>wVersion</c> member of the WSADATA structure is unacceptable to the caller, the application or DLL should call
            WSACleanup to release the Winsock DLL resources and fail to initialize the Winsock application. In order to support this
            application or DLL, it will be necessary to search for an updated version of the Winsock DLL to install on the platform.
            </para>
            <para>
            The current version of the Windows Sockets specification is version 2.2. The current Winsock DLL, Ws2_32.dll, supports
            applications that request any of the following versions of Windows Sockets specification:
            </para>
            <list type="bullet">
            <item>
            <term>1.0</term>
            </item>
            <item>
            <term>1.1</term>
            </item>
            <item>
            <term>2.0</term>
            </item>
            <item>
            <term>2.1</term>
            </item>
            <item>
            <term>2.2</term>
            </item>
            </list>
            <para>
            To get full access to the new syntax of a higher version of the Windows Sockets specification, the application must negotiate
            for this higher version. In this case, the wVersionRequested parameter should be set to request version 2.2. The application
            must also fully conform to that higher version of the Windows Socket specification, such as compiling against the appropriate
            header file, linking with a new library, or other special cases. The Winsock2.h header file for Winsock 2 support is included
            with the Microsoft Windows Software Development Kit (SDK).
            </para>
            <para>
            Windows Sockets version 2.2 is supported on Windows Server 2008, Windows Vista, Windows Server 2003, Windows XP, Windows 2000,
            Windows NT 4.0 with Service Pack 4 (SP4) and later, Windows Me, Windows 98, and Windows 95 OSR2. Windows Sockets version 2.2 is
            also supported on Windows 95 with the Windows Socket 2 Update. Applications on these platforms should normally request Winsock
            2.2 by setting the wVersionRequested parameter accordingly.
            </para>
            <para>
            On Windows 95 and versions of Windows NT 3.51 and earlier, Windows Sockets version 1.1 is the highest version of the Windows
            Sockets specification supported.
            </para>
            <para>
            It is legal and possible for an application or DLL written to use a lower version of the Windows Sockets specification that is
            supported by the Winsock DLL to successfully negotiate this lower version using the <c>WSAStartup</c> function. For example, an
            application can request version 1.1 in the wVersionRequested parameter passed to the <c>WSAStartup</c> function on a platform
            with the Winsock 2.2 DLL. In this case, the application should only rely on features that fit within the version requested. New
            Ioctl codes, new behavior of existing functions, and new functions should not be used. The version negotiation provided by the
            <c>WSAStartup</c> was primarily used to allow older Winsock 1.1 applications developed for Windows 95 and Windows NT 3.51 and
            earlier to run with the same behavior on later versions of Windows. The Winsock.h header file for Winsock 1.1 support is
            included with the Windows SDK.
            </para>
            <para>
            This negotiation in the <c>WSAStartup</c> function allows both the application or DLL that uses Windows Sockets and the Winsock
            DLL to support a range of Windows Sockets versions. An application or DLL can use the Winsock DLL if there is any overlap in the
            version ranges. Detailed information on the Windows Sockets implementation is provided in the WSADATA structure returned by the
            <c>WSAStartup</c> function.
            </para>
            <para>The following table shows how <c>WSAStartup</c> works with different applications and Winsock DLL versions.</para>
            <list type="table">
            <listheader>
            <term>Caller version support</term>
            <term>Winsock DLL version support</term>
            <term>wVersion requested</term>
            <term>wVersion returned</term>
            <term>wHighVersion returned</term>
            <term>End result</term>
            </listheader>
            <item>
            <term>1.1</term>
            <term>1.1</term>
            <term>1.1</term>
            <term>1.1</term>
            <term>1.1</term>
            <term>use 1.1</term>
            </item>
            <item>
            <term>1.0 1.1</term>
            <term>1.0</term>
            <term>1.1</term>
            <term>1.0</term>
            <term>1.0</term>
            <term>use 1.0</term>
            </item>
            <item>
            <term>1.0</term>
            <term>1.0 1.1</term>
            <term>1.0</term>
            <term>1.0</term>
            <term>1.1</term>
            <term>use 1.0</term>
            </item>
            <item>
            <term>1.1</term>
            <term>1.0 1.1</term>
            <term>1.1</term>
            <term>1.1</term>
            <term>1.1</term>
            <term>use 1.1</term>
            </item>
            <item>
            <term>1.1</term>
            <term>1.0</term>
            <term>1.1</term>
            <term>1.0</term>
            <term>1.0</term>
            <term>Application fails</term>
            </item>
            <item>
            <term>1.0</term>
            <term>1.1</term>
            <term>1.0</term>
            <term></term>
            <term></term>
            <term>WSAVERNOTSUPPORTED</term>
            </item>
            <item>
            <term>1.0 1.1</term>
            <term>1.0 1.1</term>
            <term>1.1</term>
            <term>1.1</term>
            <term>1.1</term>
            <term>use 1.1</term>
            </item>
            <item>
            <term>1.1 2.0</term>
            <term>1.0 1.1</term>
            <term>2.0</term>
            <term>1.1</term>
            <term>1.1</term>
            <term>use 1.1</term>
            </item>
            <item>
            <term>2.0</term>
            <term>1.0 1.1 2.0</term>
            <term>2.0</term>
            <term>2.0</term>
            <term>2.0</term>
            <term>use 2.0</term>
            </item>
            <item>
            <term>2.0 2.2</term>
            <term>1.0 1.1 2.0</term>
            <term>2.2</term>
            <term>2.0</term>
            <term>2.0</term>
            <term>use 2.0</term>
            </item>
            <item>
            <term>2.2</term>
            <term>1.0 1.1 2.0 2.1 2.2</term>
            <term>2.2</term>
            <term>2.2</term>
            <term>2.2</term>
            <term>use 2.2</term>
            </item>
            </list>
            <para>
            Once an application or DLL has made a successful <c>WSAStartup</c> call, it can proceed to make other Windows Sockets calls as
            needed. When it has finished using the services of the Winsock DLL, the application must call WSACleanup to allow the Winsock
            DLL to free internal Winsock resources used by the application.
            </para>
            <para>
            An application can call <c>WSAStartup</c> more than once if it needs to obtain the WSADATA structure information more than once.
            On each such call, the application can specify any version number supported by the Winsock DLL.
            </para>
            <para>
            The <c>WSAStartup</c> function typically leads to protocol-specific helper DLLs being loaded. As a result, the <c>WSAStartup</c>
            function should not be called from the DllMain function in a application DLL. This can potentially cause deadlocks. For more
            information, please see the DLL Main Function.
            </para>
            <para>
            An application must call the WSACleanup function for every successful time the <c>WSAStartup</c> function is called. This means,
            for example, that if an application calls <c>WSAStartup</c> three times, it must call <c>WSACleanup</c> three times. The first
            two calls to <c>WSACleanup</c> do nothing except decrement an internal counter; the final <c>WSACleanup</c> call for the task
            does all necessary resource deallocation for the task.
            </para>
            <para>
            <c>Note</c> An application can call the WSAGetLastError function to determine the extended error code for other Windows sockets
            functions as is normally done in Windows Sockets even if the <c>WSAStartup</c> function fails or the <c>WSAStartup</c> function
            was not called to properly initialize Windows Sockets before calling a Windows Sockets function. The <c>WSAGetLastError</c>
            function is one of the only functions in the Winsock 2.2 DLL that can be called in the case of a <c>WSAStartup</c> failure.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            <para>Examples</para>
            <para>
            The following code fragment demonstrates how an application that supports only version 2.2 of Windows Sockets makes a
            <c>WSAStartup</c> call:
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAStringToAddress(System.String,Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY,Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFO@,Vanara.PInvoke.Ws2_32.SOCKADDR,System.Int32@)">
            <summary>
            The <c>WSAStringToAddress</c> function converts a network address in its standard text presentation form into its numeric binary
            form in a sockaddr structure, suitable for passing to Windows Sockets routines that take such a structure.
            </summary>
            <param name="AddressString">
            A pointer to the zero-terminated string that contains the network address in standard text form to convert.
            </param>
            <param name="AddressFamily">The address family of the network address pointed to by the AddressString parameter.</param>
            <param name="lpProtocolInfo">
            The WSAPROTOCOL_INFO structure associated with the provider to be used. If this is <c>NULL</c>, the call is routed to the
            provider of the first protocol supporting the indicated AddressFamily.
            </param>
            <param name="lpAddress">
            A pointer to a buffer that is filled with a sockaddr structure for the address string if the function succeeds.
            </param>
            <param name="lpAddressLength">
            A pointer to the length, in bytes, of the buffer pointed to by the lpAddress parameter. If the function call is successful, this
            parameter returns a pointer to the size of the sockaddr structure returned in the lpAddress parameter. If the specified buffer
            is not large enough, the function fails with a specific error of WSAEFAULT and this parameter is updated with the required size
            in bytes.
            </param>
            <returns>
            <para>
            The return value for <c>WSAStringToAddress</c> is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is
            returned, and a specific error number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>The buffer pointed to by the lpAddress parameter is too small. Pass in a larger buffer.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>The functions was unable to translate the string into a sockaddr. See the following Remarks section for more information.</term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>
            The WS2_32.DLL has not been initialized. The application must first call WSAStartup before calling any Windows Socket functions.
            </term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There was insufficient memory to perform the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAStringToAddress</c> function converts a network address in standard text form into its numeric binary form in a
            sockaddr structure.
            </para>
            <para>
            Any missing components of the address will be defaulted to a reasonable value, if possible. For example, a missing port number
            will default to zero. If the caller wants the translation to be done by a particular provider, it should supply the
            corresponding WSAPROTOCOL_INFO structure in the lpProtocolInfo parameter.
            </para>
            <para>
            The <c>WSAStringToAddress</c> function fails (and returns WSAEINVAL) if the <c>sin_family</c> member of the SOCKADDR_IN
            structure, which is passed in the lpAddress parameter in the form of a <c>sockaddr</c> structure, is not set to AF_INET or AF_INET6.
            </para>
            <para>
            Support for IPv6 addresses using the <c>WSAStringToAddress</c> function was added on Windows XP with Service Pack 1 (SP1)and
            later. IPv6 must also be installed on the local computer for the <c>WSAStringToAddress</c> function to support IPv6 addresses.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAStringToAddress(System.String,Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY,System.IntPtr,Vanara.PInvoke.Ws2_32.SOCKADDR,System.Int32@)">
            <summary>
            The <c>WSAStringToAddress</c> function converts a network address in its standard text presentation form into its numeric binary
            form in a sockaddr structure, suitable for passing to Windows Sockets routines that take such a structure.
            </summary>
            <param name="AddressString">
            A pointer to the zero-terminated string that contains the network address in standard text form to convert.
            </param>
            <param name="AddressFamily">The address family of the network address pointed to by the AddressString parameter.</param>
            <param name="lpProtocolInfo">
            The WSAPROTOCOL_INFO structure associated with the provider to be used. If this is <c>NULL</c>, the call is routed to the
            provider of the first protocol supporting the indicated AddressFamily.
            </param>
            <param name="lpAddress">
            A pointer to a buffer that is filled with a sockaddr structure for the address string if the function succeeds.
            </param>
            <param name="lpAddressLength">
            A pointer to the length, in bytes, of the buffer pointed to by the lpAddress parameter. If the function call is successful, this
            parameter returns a pointer to the size of the sockaddr structure returned in the lpAddress parameter. If the specified buffer
            is not large enough, the function fails with a specific error of WSAEFAULT and this parameter is updated with the required size
            in bytes.
            </param>
            <returns>
            <para>
            The return value for <c>WSAStringToAddress</c> is zero if the operation was successful. Otherwise, the value SOCKET_ERROR is
            returned, and a specific error number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>The buffer pointed to by the lpAddress parameter is too small. Pass in a larger buffer.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>The functions was unable to translate the string into a sockaddr. See the following Remarks section for more information.</term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>
            The WS2_32.DLL has not been initialized. The application must first call WSAStartup before calling any Windows Socket functions.
            </term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There was insufficient memory to perform the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAStringToAddress</c> function converts a network address in standard text form into its numeric binary form in a
            sockaddr structure.
            </para>
            <para>
            Any missing components of the address will be defaulted to a reasonable value, if possible. For example, a missing port number
            will default to zero. If the caller wants the translation to be done by a particular provider, it should supply the
            corresponding WSAPROTOCOL_INFO structure in the lpProtocolInfo parameter.
            </para>
            <para>
            The <c>WSAStringToAddress</c> function fails (and returns WSAEINVAL) if the <c>sin_family</c> member of the SOCKADDR_IN
            structure, which is passed in the lpAddress parameter in the form of a <c>sockaddr</c> structure, is not set to AF_INET or AF_INET6.
            </para>
            <para>
            Support for IPv6 addresses using the <c>WSAStringToAddress</c> function was added on Windows XP with Service Pack 1 (SP1)and
            later. IPv6 must also be installed on the local computer for the <c>WSAStringToAddress</c> function to support IPv6 addresses.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAWaitForMultipleEvents(System.UInt32,Vanara.PInvoke.Ws2_32.WSAEVENT[],System.Boolean,System.UInt32,System.Boolean)">
            <summary>
            The <c>WSAWaitForMultipleEvents</c> function returns when one or all of the specified event objects are in the signaled state,
            when the time-out interval expires, or when an I/O completion routine has executed.
            </summary>
            <param name="cEvents">
            The number of event object handles in the array pointed to by lphEvents. The maximum number of event object handles is
            <c>WSA_MAXIMUM_WAIT_EVENTS</c>. One or more events must be specified.
            </param>
            <param name="lphEvents">
            <para>
            A pointer to an array of event object handles. The array can contain handles of objects of different types. It may not contain
            multiple copies of the same handle if the fWaitAll parameter is set to <c>TRUE</c>. If one of these handles is closed while the
            wait is still pending, the behavior of <c>WSAWaitForMultipleEvents</c> is undefined.
            </para>
            <para>The handles must have the <c>SYNCHRONIZE</c> access right. For more information, see Standard Access Rights.</para>
            </param>
            <param name="fWaitAll">
            A value that specifies the wait type. If <c>TRUE</c>, the function returns when the state of all objects in the lphEvents array
            is signaled. If <c>FALSE</c>, the function returns when any of the event objects is signaled. In the latter case, the return
            value minus <c>WSA_WAIT_EVENT_0</c> indicates the index of the event object whose state caused the function to return. If more
            than one event object became signaled during the call, this is the array index to the signaled event object with the smallest
            index value of all the signaled event objects.
            </param>
            <param name="dwTimeout">
            The time-out interval, in milliseconds. <c>WSAWaitForMultipleEvents</c> returns if the time-out interval expires, even if
            conditions specified by the fWaitAll parameter are not satisfied. If the dwTimeout parameter is zero,
            <c>WSAWaitForMultipleEvents</c> tests the state of the specified event objects and returns immediately. If dwTimeout is
            <c>WSA_INFINITE</c>, <c>WSAWaitForMultipleEvents</c> waits forever; that is, the time-out interval never expires.
            </param>
            <param name="fAlertable">
            A value that specifies whether the thread is placed in an alertable wait state so the system can execute I/O completion
            routines. If <c>TRUE</c>, the thread is placed in an alertable wait state and <c>WSAWaitForMultipleEvents</c> can return when
            the system executes an I/O completion routine. In this case, <c>WSA_WAIT_IO_COMPLETION</c> is returned and the event that was
            being waited on is not signaled yet. The application must call the <c>WSAWaitForMultipleEvents</c> function again. If
            <c>FALSE</c>, the thread is not placed in an alertable wait state and I/O completion routines are not executed.
            </param>
            <returns>
            <para>If the <c>WSAWaitForMultipleEvents</c> function succeeds, the return value upon success is one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Return Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSA_WAIT_EVENT_0 to (WSA_WAIT_EVENT_0 + cEvents - 1)</term>
            <term>
            If the fWaitAll parameter is TRUE, the return value indicates that all specified event objects is signaled. If the fWaitAll
            parameter is FALSE, the return value minus WSA_WAIT_EVENT_0 indicates the lphEvents array index of the signaled event object
            that satisfied the wait. If more than one event object became signaled during the call, the return value indicates the lphEvents
            array index of the signaled event object with the smallest index value of all the signaled event objects.
            </term>
            </item>
            <item>
            <term>WSA_WAIT_IO_COMPLETION</term>
            <term>
            The wait was ended by one or more I/O completion routines that were executed. The event that was being waited on is not signaled
            yet. The application must call the WSAWaitForMultipleEvents function again. This return value can only be returned if the
            fAlertable parameter is TRUE.
            </term>
            </item>
            <item>
            <term>WSA_WAIT_TIMEOUT</term>
            <term>
            The time-out interval elapsed and the conditions specified by the fWaitAll parameter were not satisfied. No I/O completion
            routines were executed.
            </term>
            </item>
            </list>
            <para>
            If the <c>WSAWaitForMultipleEvents</c> function fails, the return value is <c>WSA_WAIT_FAILED</c>. The following table lists
            values that can be used with WSAGetLastError to get extended error information.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSAENETDOWN</term>
            <term>The network subsystem has failed.</term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A blocking Windows Sockets 1.1 call is in progress, or the service provider is still processing a callback function.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>Not enough free memory was available to complete the operation.</term>
            </item>
            <item>
            <term>WSA_INVALID_HANDLE</term>
            <term>One or more of the values in the lphEvents array is not a valid event object handle.</term>
            </item>
            <item>
            <term>WSA_INVALID_PARAMETER</term>
            <term>The cEvents parameter does not contain a valid handle count.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAWaitForMultipleEvents</c> function determines whether the wait criteria have been met. If the criteria have not been
            met, the calling thread enters the wait state. It uses no processor time while waiting for the criteria to be met.
            </para>
            <para>
            The <c>WSAWaitForMultipleEvents</c> function returns when any one or all of the specified objects are in the signaled state, or
            when the time-out interval elapses.
            </para>
            <para>
            When the bWaitAll parameter is <c>TRUE</c>, the wait operation is completed only when the states of all objects have been set to
            signaled. The function does not modify the states of the specified objects until the states of all objects have been set to signaled.
            </para>
            <para>
            When bWaitAll parameter is <c>FALSE</c>, <c>WSAWaitForMultipleEvents</c> checks the handles in the lphEvents array in order
            starting with index 0, until one of the objects is signaled. If multiple objects become signaled, the function returns the index
            of the first handle in the lphEvents array whose object was signaled.
            </para>
            <para>
            This function is also used to perform an alertable wait by setting the fAlertable parameter to <c>TRUE</c>. This enables the
            function to return when the system executes an I/O completion routine by the calling thread.
            </para>
            <para>
            A thread must be in an alertable wait state in order for the system to execute I/O completion routines (asynchronous procedure
            calls or APCs). So if an application calls <c>WSAWaitForMultipleEvents</c> when there are pending asynchronous operations that
            have I/O completion routines and the fAlertable parameter is <c>FALSE</c>, then those I/O completion routines will not be
            executed even if those I/O operations are completed.
            </para>
            <para>
            If the fAlertable parameter is <c>TRUE</c> and one of the pending operations completes, the APC is executed and
            <c>WSAWaitForMultipleEvents</c> will return <c>WSA_IO_COMPLETION</c>. The pending event is not signaled yet. The application
            must call the <c>WSAWaitForMultipleEvents</c> function again.
            </para>
            <para>
            Applications that require an alertable wait state without waiting for any event objects to be signaled should use the Windows
            SleepEx function.
            </para>
            <para>The current implementation of <c>WSAWaitForMultipleEvents</c> calls the WaitForMultipleObjectsEx function.</para>
            <para>
            <c>Note</c> Use caution when calling the <c>WSAWaitForMultipleEvents</c> with code that directly or indirectly creates windows.
            If a thread creates any windows, it must process messages. Message broadcasts are sent to all windows in the system. A thread
            that uses <c>WSAWaitForMultipleEvents</c> with no time-out limit (the dwTimeout parameter set to <c>WSA_INFINITE</c>) may cause
            the system to become deadlocked.
            </para>
            <para>Example Code</para>
            <para>The following code example shows how to use the <c>WSAWaitForMultipleEvents</c> function.</para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.fd_set">
            <summary>
            The <c>fd_set</c> structure is used by various Windows Sockets functions and service providers, such as the select function, to
            place sockets into a "set" for various purposes, such as testing a given socket for readability using the readfds parameter of
            the <c>select</c> function.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.fd_set.fd_count">
            <summary>The number of sockets in the set.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.fd_set.fd_array">
            <summary>An array of sockets that are in the set.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WSANETWORKEVENTS">
            <summary>The <c>WSANETWORKEVENTS</c> structure is used to store a socket's internal information about network events.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSANETWORKEVENTS.lNetworkEvents">
            <summary>Indicates which of the FD_XXX network events have occurred.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSANETWORKEVENTS.iErrorCode">
            <summary>
            Array that contains any associated error codes, with an array index that corresponds to the position of event bits in
            <c>lNetworkEvents</c>. The identifiers FD_READ_BIT, FD_WRITE_BIT and others can be used to index the <c>iErrorCode</c> array.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WSANSCLASSINFO">
            <summary>The <c>WSANSCLASSINFO</c> structure provides individual parameter information for a specific Windows Sockets namespace.</summary>
            <remarks>
            The <c>WSANSCLASSINFO</c> structure is defined differently depending on whether ANSI or UNICODE is used. The above syntax block
            applies to ANSI; for UNICODE, the datatype for <c>lpszName</c> is <c>LPWSTR</c>.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSANSCLASSINFO.lpszName">
            <summary>String value associated with the parameter, such as SAPID, TCPPORT, and so forth.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSANSCLASSINFO.dwNameSpace">
            <summary>GUID associated with the namespace.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSANSCLASSINFO.dwValueType">
            <summary>Value type for the parameter, such as REG_DWORD or REG_SZ, and so forth.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSANSCLASSINFO.dwValueSize">
            <summary>Size of the parameter provided in <c>lpValue</c>, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSANSCLASSINFO.lpValue">
            <summary>Pointer to the value of the parameter.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WSAPOLLFD">
            <summary>The <c>WSAPOLLFD</c> structure stores socket information used by the WSAPoll function.</summary>
            <remarks>
            <para>The <c>WSAPOLLFD</c> structure is defined on Windows Vista and later.</para>
            <para>
            The <c>WSAPOLLFD</c> structure is used by the WSAPoll function to determine the status of one or more sockets. The set of
            sockets for which status is requested is specified in fdarray parameter, which is an array of <c>WSAPOLLFD</c> structures. An
            application sets the appropriate flags in the <c>events</c> member of the <c>WSAPOLLFD</c> structure to specify the type of
            status requested for each corresponding socket. The <c>WSAPoll</c> function returns the status of a socket in the <c>revents</c>
            member of the <c>WSAPOLLFD</c> structure.
            </para>
            <para>
            If the <c>fd</c> member of the <c>WSAPOLLFD</c> structure is set to a negative value, the structure is ignored by the WSAPoll
            function call, and the <c>revents</c> member is cleared upon return. This is useful to applications that maintain a fixed
            allocation for the fdarray parameter of <c>WSAPoll</c>; such applications need not waste resources compacting elements of the
            array for unused entries or reallocating memory. It is unnecessary to clear the <c>revents</c> member prior to calling the
            <c>WSAPoll</c> function.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPOLLFD.fd">
            <summary>
            <para>Type: <c>SOCKET</c></para>
            <para>The identifier of the socket for which to find status. This parameter is ignored if set to a negative value. See Remarks.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPOLLFD.events">
            <summary>
            <para>Type: <c>short</c></para>
            <para>A set of flags indicating the type of status being requested. This must be one or more of the following.</para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>POLLPRI</term>
            <term>Priority data may be read without blocking. This flag is not supported by the Microsoft Winsock provider.</term>
            </item>
            <item>
            <term>POLLRDBAND</term>
            <term>Priority band (out-of-band) data can be read without blocking.</term>
            </item>
            <item>
            <term>POLLRDNORM</term>
            <term>Normal data can be read without blocking.</term>
            </item>
            <item>
            <term>POLLWRNORM</term>
            <term>Normal data can be written without blocking.</term>
            </item>
            </list>
            <para>
            The POLLIN flag is defined as the combination of the <c>POLLRDNORM</c> and <c>POLLRDBAND</c> flag values. The POLLOUT flag
            is defined as the same as the <c>POLLWRNORM</c> flag value.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPOLLFD.revents">
            <summary>
            <para>Type: <c>short</c></para>
            <para>
            A set of flags that indicate, upon return from the WSAPoll function call, the results of the status query. This can a
            combination of the following flags.
            </para>
            <list type="table">
            <listheader>
            <term>Flag</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>POLLERR</term>
            <term>An error has occurred.</term>
            </item>
            <item>
            <term>POLLHUP</term>
            <term>A stream-oriented connection was either disconnected or aborted.</term>
            </item>
            <item>
            <term>POLLNVAL</term>
            <term>An invalid socket was used.</term>
            </item>
            <item>
            <term>POLLPRI</term>
            <term>Priority data may be read without blocking. This flag is not returned by the Microsoft Winsock provider.</term>
            </item>
            <item>
            <term>POLLRDBAND</term>
            <term>Priority band (out-of-band) data may be read without blocking.</term>
            </item>
            <item>
            <term>POLLRDNORM</term>
            <term>Normal data may be read without blocking.</term>
            </item>
            <item>
            <term>POLLWRNORM</term>
            <term>Normal data may be written without blocking.</term>
            </item>
            </list>
            <para>
            The POLLIN flag is defined as the combination of the <c>POLLRDNORM</c> and <c>POLLRDBAND</c> flag values. The POLLOUT flag
            is defined as the same as the <c>POLLWRNORM</c> flag value.
            </para>
            <para>
            For sockets that do not satisfy the status query, and have no error, the <c>revents</c> member is set to zero upon return.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WSAQUERYSET">
            <summary>
            The <c>WSAQUERYSET</c> structure provides relevant information about a given service, including service class ID, service name,
            applicable namespace identifier and protocol information, as well as a set of transport addresses at which the service listens.
            </summary>
            <remarks>
            <para>
            The <c>WSAQUERYSET</c> structure is used as part of the original namespace provider version 1 architecture available on Windows
            95 and later. A newer version 2 of the namespace architecture is available on Windows Vista and later.
            </para>
            <para>
            In most instances, applications interested in only a particular transport protocol should constrain their query by address
            family and protocol rather than by namespace. This would allow an application that needs to locate a TCP/IP service, for
            example, to have its query processed by all available namespaces such as the local hosts file, DNS, and NIS.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET.dwSize">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            The size, in bytes, of the <c>WSAQUERYSET</c> structure. This member is used as a versioning mechanism since the size of the
            <c>WSAQUERYSET</c> structure has changed on later versions of Windows.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET.lpszServiceInstanceName">
            <summary>
            <para>Type: <c>LPTSTR</c></para>
            <para>
            A pointer to an optional NULL-terminated string that contains service name. The semantics for using wildcards within the
            string are not defined, but can be supported by certain namespace providers.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET.lpServiceClassId">
            <summary>
            <para>Type: <c>LPGUID</c></para>
            <para>The GUID corresponding to the service class. This member is required to be set.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET.lpVersion">
            <summary>
            <para>Type: <c>LPWSAVERSION</c></para>
            <para>
            A pointer to an optional desired version number of the namespace provider. This member provides version comparison semantics
            (that is, the version requested must match exactly, or version must be not less than the value supplied).
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET.lpszComment">
            <summary>
            <para>Type: <c>LPTSTR</c></para>
            <para>This member is ignored for queries.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET.dwNameSpace">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            A namespace identifier that determines which namespace providers are queried. Passing a specific namespace identifier will
            result in only namespace providers that support the specified namespace being queried. Specifying <c>NS_ALL</c> will result
            in all installed and active namespace providers being queried.
            </para>
            <para>
            Options for the <c>dwNameSpace</c> member are listed in the Winsock2.h include file. Several new namespace providers are
            included with Windows Vista and later. Other namespace providers can be installed, so the following possible values are only
            those commonly available. Many other values are possible.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>NS_ALL</term>
            <term>All installed and active namespaces.</term>
            </item>
            <item>
            <term>NS_BTH</term>
            <term>The Bluetooth namespace. This namespace identifier is supported on Windows Vista and later.</term>
            </item>
            <item>
            <term>NS_DNS</term>
            <term>The domain name system (DNS) namespace.</term>
            </item>
            <item>
            <term>NS_EMAIL</term>
            <term>The email namespace. This namespace identifier is supported on Windows Vista and later.</term>
            </item>
            <item>
            <term>NS_NLA</term>
            <term>The network location awareness (NLA) namespace. This namespace identifier is supported on Windows XP and later.</term>
            </item>
            <item>
            <term>NS_PNRPNAME</term>
            <term>
            The peer-to-peer name space for a specific peer name. This namespace identifier is supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>NS_PNRPCLOUD</term>
            <term>
            The peer-to-peer name space for a collection of peer names. This namespace identifier is supported on Windows Vista and later.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET.lpNSProviderId">
            <summary>
            <para>Type: <c>LPGUID</c></para>
            <para>
            A pointer to an optional GUID of a specific namespace provider to query in the case where multiple namespace providers are
            registered under a single namespace such as <c>NS_DNS</c>. Passing the GUID for a specific namespace provider will result in
            only the specified namespace provider being queried. The WSAEnumNameSpaceProviders and WSAEnumNameSpaceProvidersEx functions
            can be called to retrieve the GUID for a namespace provider.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET.lpszContext">
            <summary>
            <para>Type: <c>LPTSTR</c></para>
            <para>A pointer to an optional starting point of the query in a hierarchical namespace.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET.dwNumberOfProtocols">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The size, in bytes, of the protocol constraint array. This member can be zero.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET.lpafpProtocols">
            <summary>
            <para>Type: <c>LPAFPROTOCOLS</c></para>
            <para>A pointer to an optional array of AFPROTOCOLS structures. Only services that utilize these protocols will be returned.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET.lpszQueryString">
            <summary>
            <para>Type: <c>LPTSTR</c></para>
            <para>
            A pointer to an optional NULL-terminated query string. Some namespaces, such as Whois++, support enriched SQL-like queries
            that are contained in a simple text string. This parameter is used to specify that string.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET.dwNumberOfCsAddrs">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>This member is ignored for queries.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET.lpcsaBuffer">
            <summary>
            <para>Type: <c>LPCSADDR_INFO</c></para>
            <para>This member is ignored for queries.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET.dwOutputFlags">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>This member is ignored for queries.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET.lpBlob">
            <summary>
            <para>Type: <c>LPBLOB</c></para>
            <para>
            An optional pointer to data that is used to query or set provider-specific namespace information. The format of this
            information is specific to the namespace provider.
            </para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAQUERYSET.#ctor(Vanara.PInvoke.Ws2_32.NS)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.WSAQUERYSET"/> struct.</summary>
            <param name="nameSpace">The name space.</param>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WSASERVICECLASSINFO">
            <summary>
            The <c>WSASERVICECLASSINFO</c> structure contains information about a specified service class. For each service class in Windows
            Sockets 2, there is a single <c>WSASERVICECLASSINFO</c> structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSASERVICECLASSINFO.lpServiceClassId">
            <summary>Unique Identifier (GUID) for the service class.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSASERVICECLASSINFO.lpszServiceClassName">
            <summary>Well known name associated with the service class.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSASERVICECLASSINFO.dwCount">
            <summary>Number of entries in <c>lpClassInfos</c>.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSASERVICECLASSINFO.lpClassInfos">
            <summary>Array of WSANSCLASSINFO structures that contains information about the service class.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.WSASERVICECLASSINFO.ClassInfos">
            <summary>Marshaled array of WSANSCLASSINFO structures that contains information about the service class.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SafeWSAEVENT">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> for <see cref="T:Vanara.PInvoke.Ws2_32.WSAEVENT"/> that is disposed using <see cref="M:Vanara.PInvoke.Ws2_32.WSACloseEvent(Vanara.PInvoke.Ws2_32.WSAEVENT)"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SafeWSAEVENT.#ctor(System.IntPtr,System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.SafeWSAEVENT"/> class and assigns an existing handle.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
            <param name="ownsHandle">
            <see langword="true"/> to reliably release the handle during the finalization phase; otherwise, <see langword="false"/> (not recommended).
            </param>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SafeWSAEVENT.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.SafeWSAEVENT"/> class.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SafeWSAEVENT.op_Implicit(Vanara.PInvoke.Ws2_32.SafeWSAEVENT)~Vanara.PInvoke.Ws2_32.WSAEVENT">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.SafeWSAEVENT"/> to <see cref="T:Vanara.PInvoke.Ws2_32.WSAEVENT"/>.</summary>
            <param name="h">The safe handle instance.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SafeWSAEVENT.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SafeWSA">
            <summary>
            A disposable class to manage initialization of the WSA library. See remarks for use.
            </summary>
            <example>
            <code>
            using (var wsa = SafeWSA.Initialize())
            {
               // Call WSA functions...
            }
            </code>
            Or, if you must have a certain version of the library, use the <c>InitDemandVersion</c> static method.
            <code>
            using (var wsa = SafeWSA.InitDemandVersion(Macros.MAKEWORD(1, 1)))
            {
               // Call WSA functions.
               // The above call with throw a VersionNotFoundException if that version is not supported.
            }
            </code>
            </example>
            <seealso cref="T:System.IDisposable" />
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SafeWSA.Initialize(System.UInt16)">
            <summary>Initiates use of the Winsock DLL by a process.</summary>
            <param name="wVersionRequired">The requested version of the WinSock library.</param>
            <returns>An object that holds the WinSock library while in scope. Upon disposal, <c>WSACleanup</c> is called.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SafeWSA.DemandVersion(System.UInt16)">
            <summary>
            Initiates use of the Winsock DLL by a process and throws an exception if <paramref name="wVersionRequired"/> isn't available.
            </summary>
            <param name="wVersionRequired">The required version of the WinSock library.</param>
            <returns>An object that holds the WinSock library while in scope. Upon disposal, <c>WSACleanup</c> is called.</returns>
            <exception cref="T:System.Data.VersionNotFoundException"></exception>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.SafeWSA.Data">
            <summary>Gets the WSADATA value returned by <c>WSAStartup</c>.</summary>
            <value>The data.</value>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.ADDRINFO_FLAGS">
            <summary>Flags that indicate options used in the GetAddrInfoW function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFO_FLAGS.AI_PASSIVE">
            <summary>The socket address will be used in a call to the bindfunction.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFO_FLAGS.AI_CANONNAME">
            <summary>The canonical name is returned in the first ai_canonname member.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFO_FLAGS.AI_NUMERICHOST">
            <summary>The nodename parameter passed to the GetAddrInfoW function must be a numeric string.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFO_FLAGS.AI_NUMERICSERV">
            <summary>Servicename must be a numeric port number.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFO_FLAGS.AI_ALL">
            <summary>
            If this bit is set, a request is made for IPv6 addresses and IPv4 addresses with AI_V4MAPPED.
            <para>This option is supported on Windows Vista and later.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFO_FLAGS.AI_ADDRCONFIG">
            <summary>
            The GetAddrInfoW will resolve only if a global address is configured. The IPv6 and IPv4 loopback address is not considered a
            valid global address. This option is only supported on Windows Vista and later.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFO_FLAGS.AI_V4MAPPED">
            <summary>
            If the GetAddrInfoW request for an IPv6 addresses fails, a name service request is made for IPv4 addresses and these
            addresses are converted to IPv4-mapped IPv6 address format.
            <para>This option is supported on Windows Vista and later.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFO_FLAGS.AI_NON_AUTHORITATIVE">
            <summary>
            The address information can be from a non-authoritative namespace provider.
            <para>This option is only supported on Windows Vista and later for the NS_EMAIL namespace.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFO_FLAGS.AI_SECURE">
            <summary>
            The address information is from a secure channel.
            <para>This option is only supported on Windows Vista and later for the NS_EMAIL namespace.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFO_FLAGS.AI_RETURN_PREFERRED_NAMES">
            <summary>
            The address information is for a preferred name for a user.
            <para>This option is only supported on Windows Vista and later for the NS_EMAIL namespace.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFO_FLAGS.AI_FQDN">
            <summary>
            If a flat name (single label) is specified, GetAddrInfoW will return the fully qualified domain name that the name
            eventually resolved to. The fully qualified domain name is returned in the ai_canonname member.
            <para>
            This is different than AI_CANONNAME bit flag that returns the canonical name registered in DNS which may be different than
            the fully qualified domain name that the flat name resolved to.
            </para>
            <para>
            Only one of the AI_FQDN and AI_CANONNAME bits can be set. The GetAddrInfoW function will fail if both flags are present with EAI_BADFLAGS.
            </para>
            <para>This option is supported on Windows 7, Windows Server 2008 R2, and later.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFO_FLAGS.AI_FILESERVER">
            <summary>
            A hint to the namespace provider that the hostname being queried is being used in a file share scenario. The namespace
            provider may ignore this hint.
            <para>This option is supported on Windows 7, Windows Server 2008 R2, and later.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFO_FLAGS.AI_DISABLE_IDN_ENCODING">
            <summary>
            Disable the automatic International Domain Name encoding using Punycode in the name resolution functions called by the
            GetAddrInfoW function.
            <para>This option is supported on Windows 8, Windows Server 2012, and later.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFO_FLAGS.AI_EXTENDED">
            <summary>Indicates this is extended ADDRINFOEX(2/..) struct</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFO_FLAGS.AI_RESOLUTION_HANDLE">
            <summary>Request resolution handle</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.NI">
            <summary>Customize processing of the GetNameInfoW function.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NI.NI_NOFQDN">
            <summary>Results in local hosts having only their Relative Distinguished Name (RDN) returned in the pNodeBuffer parameter.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NI.NI_NUMERICHOST">
            <summary>
            Returns the numeric form of the host name instead of its name. The numeric form of the host name is also returned if the
            host name cannot be resolved by DNS.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NI.NI_NAMEREQD">
            <summary>A host name that cannot be resolved by the DNS results in an error.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NI.NI_NUMERICSERV">
            <summary>
            Returns the port number of the service instead of its name. Also, if a host name is not found for an IP address (127.0.0.2,
            for example), the hostname is returned as the IP address.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NI.NI_DGRAM">
            <summary>
            Indicates that the service is a datagram service. This flag is necessary for the few services that provide different port
            numbers for UDP and TCP service.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SCOPE_LEVEL">
            <summary>The scope of the IPv6 transport address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SCOPE_LEVEL.ScopeLevelInterface">
            <summary>The transport address has interface-local scope.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SCOPE_LEVEL.ScopeLevelLink">
            <summary>The transport address has link-local scope.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SCOPE_LEVEL.ScopeLevelSubnet">
            <summary>The transport address has subnet-local scope.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SCOPE_LEVEL.ScopeLevelAdmin">
            <summary>The transport address has admin-local scope.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SCOPE_LEVEL.ScopeLevelSite">
            <summary>The transport address has site-local scope.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SCOPE_LEVEL.ScopeLevelOrganization">
            <summary>The transport address has organization-local scope.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SCOPE_LEVEL.ScopeLevelGlobal">
            <summary>The transport address has global scope.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SCOPE_LEVEL.ScopeLevelCount">
            <summary>The scope level count.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.ADDRINFOEX2W">
            <summary>
            The addrinfoex2 structure is used by the GetAddrInfoEx function to hold host address information when both a canonical name and
            a fully qualified domain name have been requested.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEX2W.ai_flags">
            <summary>
            <para>Flags that indicate options used in the GetAddrInfoEx function.</para>
            <para>
            Supported values for the <c>ai_flags</c> member are defined in the Winsock2.h include file and can be a combination of the
            following options.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AI_PASSIVE 0x01</term>
            <term>The socket address will be used in a call to the bindfunction.</term>
            </item>
            <item>
            <term>AI_CANONNAME 0x02</term>
            <term>The canonical name is returned in the first ai_canonname member.</term>
            </item>
            <item>
            <term>AI_NUMERICHOST 0x04</term>
            <term>The nodename parameter passed to the GetAddrInfoEx function must be a numeric string.</term>
            </item>
            <item>
            <term>AI_ALL 0x0100</term>
            <term>
            If this bit is set, a request is made for IPv6 addresses and IPv4 addresses with AI_V4MAPPED. This option is supported on
            Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AI_ADDRCONFIG 0x0400</term>
            <term>
            The GetAddrInfoEx will resolve only if a global address is configured. The IPv6 and IPv4 loopback address is not considered
            a valid global address. This option is supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AI_V4MAPPED 0x0800</term>
            <term>
            If the GetAddrInfoEx request for an IPv6 addresses fails, a name service request is made for IPv4 addresses and these
            addresses are converted to IPv4-mapped IPv6 address format. This option is supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AI_NON_AUTHORITATIVE 0x04000</term>
            <term>
            The address information is from non-authoritative results. When this option is set in the pHints parameter of GetAddrInfoEx,
            the NS_EMAIL namespace provider returns both authoritative and non-authoritative results. If this option is not set, then
            only authoritative results are returned. This option is only supported on Windows Vista and later for the NS_EMAIL namespace.
            </term>
            </item>
            <item>
            <term>AI_SECURE 0x08000</term>
            <term>
            The address information is from a secure channel. If the AI_SECURE bit is set, the NS_EMAIL namespace provider will return
            results that were obtained with enhanced security to minimize possible spoofing. When this option is set in the pHints
            parameter of GetAddrInfoEx, the NS_EMAIL namespace provider returns only results that were obtained with enhanced security
            to minimize possible spoofing. This option is only supported on Windows Vista and later for the NS_EMAIL namespace.
            </term>
            </item>
            <item>
            <term>AI_RETURN_PREFERRED_NAMES 0x010000</term>
            <term>
            The address information is for a preferred names for publication with a specific namespace. When this option is set in the
            pHints parameter of GetAddrInfoEx, no name should be provided in the pName parameter and the NS_EMAIL namespace provider
            will return preferred names for publication. This option is only supported on Windows Vista and later for the NS_EMAIL namespace.
            </term>
            </item>
            <item>
            <term>AI_FQDN 0x00020000</term>
            <term>
            The fully qualified domain name is returned in the first ai_fqdn member. When this option is set in the pHints parameter of
            GetAddrInfoEx and a flat name (single label) is specified in the pName parameter, the fully qualified domain name that the
            name eventually resolved to will be returned. This option is supported on Windows 7, Windows Server 2008 R2, and later.
            </term>
            </item>
            <item>
            <term>AI_FILESERVER 0x00040000</term>
            <term>
            A hint to the namespace provider that the hostname being queried is being used in a file share scenario. The namespace
            provider may ignore this hint. This option is supported on Windows 7, Windows Server 2008 R2, and later.
            </term>
            </item>
            <item>
            <term>AI_DISABLE_IDN_ENCODING 0x00080000</term>
            <term>
            Disable the automatic International Domain Name encoding using Punycode in the name resolution functions called by the
            GetAddrInfoEx function. This option is supported on Windows 8, Windows Server 2012, and later.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.ADDRINFOEX2W.ai_family">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The address family. Possible values for the address family are defined in the Winsock2.h include file.</para>
            <para>
            On the Windows SDK released for Windows Vista and later,, the organization of header files has changed and the possible
            values for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically
            included in Winsock2.h, and should never be used directly.
            </para>
            <para>
            The values currently supported are <c>AF_INET</c> or <c>AF_INET6</c>, which are the Internet address family formats for IPv4
            and IPv6. Other options for address family ( <c>AF_NETBIOS</c> for use with NetBIOS, for example) are supported if a Windows
            Sockets service provider for the address family is installed. Note that the values for the AF_ address family and PF_
            protocol family constants are identical (for example, <c>AF_UNSPEC</c> and <c>PF_UNSPEC</c>), so either constant can be used.
            </para>
            <para>The table below lists common values for the address family although many other values are possible.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AF_UNSPEC 0</term>
            <term>The address family is unspecified.</term>
            </item>
            <item>
            <term>AF_INET 2</term>
            <term>The Internet Protocol version 4 (IPv4) address family.</term>
            </item>
            <item>
            <term>AF_NETBIOS 17</term>
            <term>The NetBIOS address family. This address family is only supported if a Windows Sockets provider for NetBIOS is installed.</term>
            </item>
            <item>
            <term>AF_INET6 23</term>
            <term>The Internet Protocol version 6 (IPv6) address family.</term>
            </item>
            <item>
            <term>AF_IRDA 26</term>
            <term>
            The Infrared Data Association (IrDA) address family. This address family is only supported if the computer has an infrared
            port and driver installed.
            </term>
            </item>
            <item>
            <term>AF_BTH 32</term>
            <term>
            The Bluetooth address family. This address family is only supported if a Bluetooth adapter is installed on Windows Server
            2003 or later.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEX2W.ai_socktype">
            <summary>
            <para>The socket type. Possible values for the socket type are defined in the Winsock2.h include file.</para>
            <para>The following table lists the possible values for the socket type supported for Windows Sockets 2:</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SOCK_STREAM 1</term>
            <term>
            Provides sequenced, reliable, two-way, connection-based byte streams with an OOB data transmission mechanism. Uses the
            Transmission Control Protocol (TCP) for the Internet address family (AF_INET or AF_INET6). If the ai_family member is
            AF_IRDA, then SOCK_STREAM is the only supported socket type.
            </term>
            </item>
            <item>
            <term>SOCK_DGRAM 2</term>
            <term>
            Supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length. Uses the User
            Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).
            </term>
            </item>
            <item>
            <term>SOCK_RAW 3</term>
            <term>
            Provides a raw socket that allows an application to manipulate the next upper-layer protocol header. To manipulate the IPv4
            header, the IP_HDRINCL socket option must be set on the socket. To manipulate the IPv6 header, the IPV6_HDRINCL socket
            option must be set on the socket.
            </term>
            </item>
            <item>
            <term>SOCK_RDM 4</term>
            <term>
            Provides a reliable message datagram. An example of this type is the Pragmatic General Multicast (PGM) multicast protocol
            implementation in Windows, often referred to as reliable multicast programming.
            </term>
            </item>
            <item>
            <term>SOCK_SEQPACKET 5</term>
            <term>Provides a pseudo-stream packet based on datagrams.</term>
            </item>
            </list>
            <para>
            In Windows Sockets 2, new socket types were introduced. An application can dynamically discover the attributes of each
            available transport protocol through the WSAEnumProtocols function. So an application can determine the possible socket type
            and protocol options for an address family and use this information when specifying this parameter. Socket type definitions
            in the Winsock2.h and Ws2def.h header files will be periodically updated as new socket types, address families, and
            protocols are defined.
            </para>
            <para>In Windows Sockets 1.1, the only possible socket types are <c>SOCK_DATAGRAM</c> and <c>SOCK_STREAM</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEX2W.ai_protocol">
            <summary>
            <para>
            The protocol type. The possible options are specific to the address family and socket type specified. Possible values for
            the <c>ai_protocol</c> are defined in Winsock2.h and the Wsrm.h header files.
            </para>
            <para>
            On the Windows SDK released for Windows Vista and later,, the organization of header files has changed and this member can
            be one of the values from the <c>IPPROTO</c> enumeration type defined in the Ws2def.h header file. Note that the Ws2def.h
            header file is automatically included in Winsock2.h, and should never be used directly.
            </para>
            <para>
            If a value of 0 is specified for <c>ai_protocol</c>, the caller does not wish to specify a protocol and the service provider
            will choose the <c>ai_protocol</c> to use. For protocols other than IPv4 and IPv6, set <c>ai_protocol</c> to zero.
            </para>
            <para>The following table lists common values for the <c>ai_protocol</c> member although many other values are possible.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>IPPROTO_TCP 6</term>
            <term>
            The Transmission Control Protocol (TCP). This is a possible value when the ai_family member is AF_INET or AF_INET6 and the
            ai_socktype member is SOCK_STREAM.
            </term>
            </item>
            <item>
            <term>IPPROTO_UDP 17</term>
            <term>
            The User Datagram Protocol (UDP). This is a possible value when the ai_family member is AF_INET or AF_INET6 and the type
            parameter is SOCK_DGRAM.
            </term>
            </item>
            <item>
            <term>IPPROTO_RM 113</term>
            <term>
            The PGM protocol for reliable multicast. This is a possible value when the ai_family member is AF_INET and the ai_socktype
            member is SOCK_RDM. On the Windows SDK released for Windows Vista and later, this value is also called IPPROTO_PGM.
            </term>
            </item>
            </list>
            <para>If the <c>ai_family</c> member is <c>AF_IRDA</c>, then the <c>ai_protocol</c> must be 0.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEX2W.ai_addrlen">
            <summary>The length, in bytes, of the buffer pointed to by the <c>ai_addr</c> member.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEX2W.ai_canonname">
            <summary>The canonical name for the host.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEX2W.ai_addr">
            <summary>
            A pointer to a sockaddr structure. The <c>ai_addr</c> member in each returned <c>addrinfoex2</c> structure points to a
            filled-in socket address structure. The length, in bytes, of each returned <c>addrinfoex2</c> structure is specified in the
            <c>ai_addrlen</c> member.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEX2W.ai_blob">
            <summary>
            A pointer to data that is used to return provider-specific namespace information that is associated with the name beyond a
            list of addresses. The length, in bytes, of the buffer pointed to by <c>ai_blob</c> must be specified in the
            <c>ai_bloblen</c> member.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEX2W.ai_bloblen">
            <summary>The length, in bytes, of the <c>ai_blob</c> member.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEX2W.ai_provider">
            <summary>A pointer to the GUID of a specific namespace provider.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEX2W.ai_next">
            <summary>
            A pointer to the next structure in a linked list. This parameter is set to <c>NULL</c> in the last <c>addrinfoex2</c>
            structure of a linked list.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEX2W.ai_version">
            <summary>The version number of this structure. The value currently used for this version of the structure is 2.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEX2W.ai_fqdn">
            <summary>The fully qualified domain name for the host.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.ADDRINFOEX2W.addr">
            <summary>
            <para>Type: <c>struct sockaddr*</c></para>
            <para>
            A pointer to a sockaddr structure. The <c>ai_addr</c> member in each returned ADDRINFOW structure points to a filled-in
            socket address structure. The length, in bytes, of each returned <c>ADDRINFOW</c> structure is specified in the
            <c>ai_addrlen</c> member.
            </para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.ADDRINFOEX2W.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.ADDRINFOEXW">
            <summary>The <c>addrinfoex</c> structure is used by the GetAddrInfoEx function to hold host address information.</summary>
            <remarks>
            <para>
            The <c>addrinfoex</c> structure is used by the GetAddrInfoEx function to hold host address information. The <c>addrinfoex</c>
            structure is an enhanced version of the addrinfo and addrinfoW structures. The extra structure members are for blob data and the
            GUID for the namespace provider. The blob data is used to return additional provider-specific namespace information associated
            with a name. The format of data in the <c>ai_blob</c> member is specific to a particular namespace provider. Currently, blob
            data is used by the <c>NS_EMAIL</c> namespace provider to supply additional information.
            </para>
            <para>
            The <c>addrinfoex</c> structure is an enhanced version of the addrinfo and addrinfoW structure used with GetAddrInfoEx function.
            The <c>GetAddrInfoEx</c> function allows specifying the namespace provider to resolve the query. For use with the IPv6 and IPv4
            protocol, name resolution can be by the Domain Name System (DNS), a local hosts file, an email provider (the <c>NS_EMAIL</c>
            namespace), or by other naming mechanisms.
            </para>
            <para>
            When UNICODE or _UNICODE is defined, <c>addrinfoex</c> is defined to <c>addrinfoexW</c>, the Unicode version of this structure.
            The string parameters are defined to the <c>PWSTR</c> data type and the <c>addrinfoexW</c> structure is used.
            </para>
            <para>
            When UNICODE or _UNICODE is not defined, <c>addrinfoex</c> is defined to <c>addrinfoexA</c>, the ANSI version of this structure.
            The string parameters are of the <c>PCSTR</c> data type and the <c>addrinfoexA</c> structure is used.
            </para>
            <para>
            Upon a successful call to GetAddrInfoEx, a linked list of <c>addrinfoex</c> structures is returned in the ppResult parameter
            passed to the <c>GetAddrInfoEx</c> function. The list can be processed by following the pointer provided in the <c>ai_next</c>
            member of each returned <c>addrinfoex</c> structure until a <c>NULL</c> pointer is encountered. In each returned
            <c>addrinfoex</c> structure, the <c>ai_family</c>, <c>ai_socktype</c>, and <c>ai_protocol</c> members correspond to respective
            arguments in a socket or WSASocket function call. Also, the <c>ai_addr</c> member in each returned <c>addrinfoex</c> structure
            points to a filled-in socket address structure, the length of which is specified in its <c>ai_addrlen</c> member.
            </para>
            <para>Examples</para>
            <para>The following example demonstrates the use of the <c>addrinfoex</c> structure.</para>
            <para>
            <c>Note</c> Ensure that the development environment targets the newest version of Ws2tcpip.h which includes structure and
            function definitions for <c>ADDRINFOEX</c> and GetAddrInfoEx, respectively.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEXW.ai_flags">
            <summary>
            <para>Type: <c>int</c></para>
            <para>Flags that indicate options used in the GetAddrInfoEx function.</para>
            <para>
            Supported values for the <c>ai_flags</c> member are defined in the Winsock2.h include file and can be a combination of the
            following options.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AI_PASSIVE 0x01</term>
            <term>The socket address will be used in a call to the bindfunction.</term>
            </item>
            <item>
            <term>AI_CANONNAME 0x02</term>
            <term>
            The canonical name is returned in the first ai_canonname member. When both the AI_CANONNAME and AI_FQDN bits are set, an
            addrinfoex2 structure is returned not the addrinfoex structure.
            </term>
            </item>
            <item>
            <term>AI_NUMERICHOST 0x04</term>
            <term>The nodename parameter passed to the GetAddrInfoEx function must be a numeric string.</term>
            </item>
            <item>
            <term>AI_ALL 0x0100</term>
            <term>
            If this bit is set, a request is made for IPv6 addresses and IPv4 addresses with AI_V4MAPPED. This option is supported on
            Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AI_ADDRCONFIG 0x0400</term>
            <term>
            The GetAddrInfoEx will resolve only if a global address is configured. The IPv6 and IPv4 loopback address is not considered
            a valid global address. This option is only supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AI_V4MAPPED 0x0800</term>
            <term>
            If the GetAddrInfoEx request for an IPv6 addresses fails, a name service request is made for IPv4 addresses and these
            addresses are converted to IPv4-mapped IPv6 address format. This option is supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AI_NON_AUTHORITATIVE 0x04000</term>
            <term>
            The address information is from non-authoritative results. When this option is set in the pHints parameter of GetAddrInfoEx,
            the NS_EMAIL namespace provider returns both authoritative and non-authoritative results. If this option is not set, then
            only authoritative results are returned. In the ppResults parameter returned by GetAddrInfoEx, this flag is set in the
            ai_flags member of the addrinfoex structure for non-authoritative results. This option is only supported on Windows Vista
            and later for the NS_EMAIL namespace.
            </term>
            </item>
            <item>
            <term>AI_SECURE 0x08000</term>
            <term>
            The address information is from a secure channel. If the AI_SECURE bit is set, the NS_EMAIL namespace provider will return
            results that were obtained with enhanced security to minimize possible spoofing. When this option is set in the pHints
            parameter of GetAddrInfoEx, the NS_EMAIL namespace provider returns only results that were obtained with enhanced security
            to minimize possible spoofing. In the ppResults parameter returned by GetAddrInfoEx, this flag is set in the ai_flags member
            of the addrinfoex structure for results returned with enhanced security to minimize possible spoofing. This option is only
            supported on Windows Vista and later for the NS_EMAIL namespace.
            </term>
            </item>
            <item>
            <term>AI_RETURN_PREFERRED_NAMES 0x010000</term>
            <term>
            The address information is for a preferred names for publication with a specific namespace. When this option is set in the
            pHints parameter of GetAddrInfoEx, no name should be provided in the pName parameter and the NS_EMAIL namespace provider
            will return preferred names for publication. In the ppResults parameter returned by GetAddrInfoEx, this flag is set in the
            ai_flags member of the addrinfoex structure for results returned for preferred names for publication. This option is only
            supported on Windows Vista and later for the NS_EMAIL namespace.
            </term>
            </item>
            <item>
            <term>AI_FQDN 0x00020000</term>
            <term>
            The fully qualified domain name is returned in the first ai_canonicalname member. When this option is set in the pHints
            parameter of GetAddrInfoEx and a flat name (single label) is specified in the pName parameter, the fully qualified domain
            name that the name eventually resolved to will be returned. When both the AI_CANONNAME and AI_FQDN bits are set, an
            addrinfoex2 structure is returned not the addrinfoex structure. This option is supported on Windows 7, Windows Server 2008
            R2, and later.
            </term>
            </item>
            <item>
            <term>AI_FILESERVER 0x00040000</term>
            <term>
            A hint to the namespace provider that the hostname being queried is being used in a file share scenario. The namespace
            provider may ignore this hint. This option is supported on Windows 7, Windows Server 2008 R2, and later.
            </term>
            </item>
            <item>
            <term>AI_DISABLE_IDN_ENCODING 0x00080000</term>
            <term>
            Disable the automatic International Domain Name encoding using Punycode in the name resolution functions called by the
            GetAddrInfoEx function. This option is supported on Windows 8, Windows Server 2012, and later.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.ADDRINFOEXW.ai_family">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The address family. Possible values for the address family are defined in the Winsock2.h include file.</para>
            <para>
            On the Windows SDK released for Windows Vista and later,, the organization of header files has changed and the possible
            values for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically
            included in Winsock2.h, and should never be used directly.
            </para>
            <para>
            The values currently supported are <c>AF_INET</c> or <c>AF_INET6</c>, which are the Internet address family formats for IPv4
            and IPv6. Other options for address family ( <c>AF_NETBIOS</c> for use with NetBIOS, for example) are supported if a Windows
            Sockets service provider for the address family is installed. Note that the values for the AF_ address family and PF_
            protocol family constants are identical (for example, <c>AF_UNSPEC</c> and <c>PF_UNSPEC</c>), so either constant can be used.
            </para>
            <para>The table below lists common values for the address family although many other values are possible.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AF_UNSPEC 0</term>
            <term>The address family is unspecified.</term>
            </item>
            <item>
            <term>AF_INET 2</term>
            <term>The Internet Protocol version 4 (IPv4) address family.</term>
            </item>
            <item>
            <term>AF_NETBIOS 17</term>
            <term>The NetBIOS address family. This address family is only supported if a Windows Sockets provider for NetBIOS is installed.</term>
            </item>
            <item>
            <term>AF_INET6 23</term>
            <term>The Internet Protocol version 6 (IPv6) address family.</term>
            </item>
            <item>
            <term>AF_IRDA 26</term>
            <term>
            The Infrared Data Association (IrDA) address family. This address family is only supported if the computer has an infrared
            port and driver installed.
            </term>
            </item>
            <item>
            <term>AF_BTH 32</term>
            <term>
            The Bluetooth address family. This address family is only supported if a Bluetooth adapter is installed on Windows Server
            2003 or later.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEXW.ai_socktype">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The socket type. Possible values for the socket type are defined in the Winsock2.h include file.</para>
            <para>The following table lists the possible values for the socket type supported for Windows Sockets 2:</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SOCK_STREAM 1</term>
            <term>
            Provides sequenced, reliable, two-way, connection-based byte streams with an OOB data transmission mechanism. Uses the
            Transmission Control Protocol (TCP) for the Internet address family (AF_INET or AF_INET6). If the ai_family member is
            AF_IRDA, then SOCK_STREAM is the only supported socket type.
            </term>
            </item>
            <item>
            <term>SOCK_DGRAM 2</term>
            <term>
            Supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length. Uses the User
            Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).
            </term>
            </item>
            <item>
            <term>SOCK_RAW 3</term>
            <term>
            Provides a raw socket that allows an application to manipulate the next upper-layer protocol header. To manipulate the IPv4
            header, the IP_HDRINCL socket option must be set on the socket. To manipulate the IPv6 header, the IPV6_HDRINCL socket
            option must be set on the socket.
            </term>
            </item>
            <item>
            <term>SOCK_RDM 4</term>
            <term>
            Provides a reliable message datagram. An example of this type is the Pragmatic General Multicast (PGM) multicast protocol
            implementation in Windows, often referred to as reliable multicast programming.
            </term>
            </item>
            <item>
            <term>SOCK_SEQPACKET 5</term>
            <term>Provides a pseudo-stream packet based on datagrams.</term>
            </item>
            </list>
            <para>
            In Windows Sockets 2, new socket types were introduced. An application can dynamically discover the attributes of each
            available transport protocol through the WSAEnumProtocols function. So an application can determine the possible socket type
            and protocol options for an address family and use this information when specifying this parameter. Socket type definitions
            in the Winsock2.h and Ws2def.h header files will be periodically updated as new socket types, address families, and
            protocols are defined.
            </para>
            <para>In Windows Sockets 1.1, the only possible socket types are <c>SOCK_DATAGRAM</c> and <c>SOCK_STREAM</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEXW.ai_protocol">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            The protocol type. The possible options are specific to the address family and socket type specified. Possible values for
            the <c>ai_protocol</c> are defined in Winsock2.h and the Wsrm.h header files.
            </para>
            <para>
            On the Windows SDK released for Windows Vista and later,, the organization of header files has changed and this member can
            be one of the values from the <c>IPPROTO</c> enumeration type defined in the Ws2def.h header file. Note that the Ws2def.h
            header file is automatically included in Winsock2.h, and should never be used directly.
            </para>
            <para>
            If a value of 0 is specified for <c>ai_protocol</c>, the caller does not wish to specify a protocol and the service provider
            will choose the <c>ai_protocol</c> to use. For protocols other than IPv4 and IPv6, set <c>ai_protocol</c> to zero.
            </para>
            <para>The following table lists common values for the <c>ai_protocol</c> member although many other values are possible.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>IPPROTO_TCP 6</term>
            <term>
            The Transmission Control Protocol (TCP). This is a possible value when the ai_family member is AF_INET or AF_INET6 and the
            ai_socktype member is SOCK_STREAM.
            </term>
            </item>
            <item>
            <term>IPPROTO_UDP 17</term>
            <term>
            The User Datagram Protocol (UDP). This is a possible value when the ai_family member is AF_INET or AF_INET6 and the type
            parameter is SOCK_DGRAM.
            </term>
            </item>
            <item>
            <term>IPPROTO_RM 113</term>
            <term>
            The PGM protocol for reliable multicast. This is a possible value when the ai_family member is AF_INET and the ai_socktype
            member is SOCK_RDM. On the Windows SDK released for Windows Vista and later, this value is also called IPPROTO_PGM.
            </term>
            </item>
            </list>
            <para>If the <c>ai_family</c> member is <c>AF_IRDA</c>, then the <c>ai_protocol</c> must be 0.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEXW.ai_addrlen">
            <summary>
            <para>Type: <c>size_t</c></para>
            <para>The length, in bytes, of the buffer pointed to by the <c>ai_addr</c> member.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEXW.ai_canonname">
            <summary>
            <para>Type: <c>PCTSTR</c></para>
            <para>The canonical name for the host.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEXW.ai_addr">
            <summary>
            <para>Type: <c>struct sockaddr*</c></para>
            <para>
            A pointer to a sockaddr structure. The <c>ai_addr</c> member in each returned <c>addrinfoex</c> structure points to a
            filled-in socket address structure. The length, in bytes, of each returned <c>addrinfoex</c> structure is specified in the
            <c>ai_addrlen</c> member.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEXW.ai_blob">
            <summary>
            <para>Type: <c>void*</c></para>
            <para>
            A pointer to data that is used to return provider-specific namespace information that is associated with the name beyond a
            list of addresses. The length, in bytes, of the buffer pointed to by <c>ai_blob</c> must be specified in the
            <c>ai_bloblen</c> member.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEXW.ai_bloblen">
            <summary>
            <para>Type: <c>size_t</c></para>
            <para>The length, in bytes, of the <c>ai_blob</c> member.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEXW.ai_provider">
            <summary>
            <para>Type: <c>LPGUID</c></para>
            <para>A pointer to the GUID of a specific namespace provider.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOEXW.ai_next">
            <summary>
            <para>Type: <c>struct addrinfoex*</c></para>
            <para>
            A pointer to the next structure in a linked list. This parameter is set to <c>NULL</c> in the last <c>addrinfoex</c>
            structure of a linked list.
            </para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.ADDRINFOEXW.addr">
            <summary>
            <para>Type: <c>struct sockaddr*</c></para>
            <para>
            A pointer to a sockaddr structure. The <c>ai_addr</c> member in each returned ADDRINFOW structure points to a filled-in
            socket address structure. The length, in bytes, of each returned <c>ADDRINFOW</c> structure is specified in the
            <c>ai_addrlen</c> member.
            </para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.ADDRINFOEXW.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.ADDRINFOW">
            <summary>
            The <c>addrinfoex2</c> structure is used by the GetAddrInfoEx function to hold host address information when both a canonical
            name and a fully qualified domain name have been requested.
            </summary>
            <remarks>
            <para>The <c>addrinfoex2</c> structure is supported on Windows 8 and Windows Server 2012</para>
            <para>
            The <c>addrinfoex2</c> structure is used by the GetAddrInfoEx function to hold host address information when both the
            <c>AI_FQDN</c> and <c>AI_CANONNAME</c> bits are set in the <c>ai_flags</c> member of the optional addrinfoex structure provided
            in the hints parameter to the <c>GetAddrInfoEx</c> function. The <c>addrinfoex2</c> structure is an enhanced version of the
            <c>addrinfoex</c> structure that can return both the canonical name and the fully qualified domain name for the host. The extra
            structure members are for a version number of the structure and the fully qualified domain name for the host.
            </para>
            <para>
            The <c>addrinfoex2</c> structure used with GetAddrInfoEx function is an enhanced version of the addrinfo and addrinfoW
            structures used with the getaddrinfo and GetAddrInfoW functions. The <c>GetAddrInfoEx</c> function allows specifying the
            namespace provider to resolve the query. For use with the IPv6 and IPv4 protocol, name resolution can be by the Domain Name
            System (DNS), a local hosts file, an email provider (the <c>NS_EMAIL</c> namespace), or by other naming mechanisms.
            </para>
            <para>
            The blob data in tha <c>ai_blob</c> member is used to return additional provider-specific namespace information associated with
            a name. The format of data in the <c>ai_blob</c> member is specific to a particular namespace provider. Currently, blob data is
            used by the <c>NS_EMAIL</c> namespace provider to supply additional information.
            </para>
            <para>
            When UNICODE or _UNICODE is defined, <c>addrinfoex2</c> is defined to <c>addrinfoex2W</c>, the Unicode version of this
            structure. The string parameters are defined to the <c>PWSTR</c> data type and the <c>addrinfoex2W</c> structure is used.
            </para>
            <para>
            When UNICODE or _UNICODE is not defined, <c>addrinfoex2</c> is defined to <c>addrinfoex2A</c>, the ANSI version of this
            structure. The string parameters are of the <c>char *</c> data type and the <c>addrinfoex2A</c> structure is used.
            </para>
            <para>
            Upon a successful call to GetAddrInfoEx, a linked list of <c>addrinfoex2</c> structures is returned in the ppResult parameter
            passed to the <c>GetAddrInfoEx</c> function. The list can be processed by following the pointer provided in the <c>ai_next</c>
            member of each returned <c>addrinfoex2</c> structure until a <c>NULL</c> pointer is encountered. In each returned
            <c>addrinfoex2</c> structure, the <c>ai_family</c>, <c>ai_socktype</c>, and <c>ai_protocol</c> members correspond to respective
            arguments in a socket or WSASocket function call. Also, the <c>ai_addr</c> member in each returned <c>addrinfoex2</c> structure
            points to a filled-in socket address structure, the length of which is specified in its <c>ai_addrlen</c> member.
            </para>
            </remarks>
            <summary>The <c>addrinfo</c> structure is used by the getaddrinfo function to hold host address information.</summary>
            <remarks>
            <para>The <c>addrinfo</c> structure is used by the ANSI getaddrinfo function to hold host address information.</para>
            <para>The addrinfoW structure is the version of this structure used by the Unicode GetAddrInfoW function.</para>
            <para>
            Macros in the Ws2tcpip.h header file define a <c>ADDRINFOT</c> structure and a mixed-case function name of <c>GetAddrInfo</c>.
            The <c>GetAddrInfo</c> function should be called with the nodename and servname parameters of a pointer of type <c>TCHAR</c> and
            the hints and res parameters of a pointer of type <c>ADDRINFOT</c>. When UNICODE or _UNICODE is not defined, <c>ADDRINFOT</c> is
            defined to the <c>addrinfo</c> structure and <c>GetAddrInfo</c> is defined to getaddrinfo, the ANSI version of this function.
            When UNICODE or _UNICODE is defined, <c>ADDRINFOT</c> is defined to the addrinfoW structure and <c>GetAddrInfo</c> is defined to
            GetAddrInfoW, the Unicode version of this function.
            </para>
            <para>
            Upon a successful call to getaddrinfo, a linked list of <c>addrinfo</c> structures is returned in the res parameter passed to
            the <c>getaddrinfo</c> function. The list can be processed by following the pointer provided in the <c>ai_next</c> member of
            each returned <c>addrinfo</c> structure until a <c>NULL</c> pointer is encountered. In each returned <c>addrinfo</c> structure,
            the <c>ai_family</c>, <c>ai_socktype</c>, and <c>ai_protocol</c> members correspond to respective arguments in a socket or
            WSASocket function call. Also, the <c>ai_addr</c> member in each returned <c>addrinfo</c> structure points to a filled-in socket
            address structure, the length of which is specified in its <c>ai_addrlen</c> member.
            </para>
            <para>Support for getaddrinfo and the addrinfo struct on older versions of Windows</para>
            <para>
            The getaddrinfo function that uses the <c>addrinfo</c> structure was added to the Ws2_32.dll on Windows XP and later. The
            <c>addrinfo</c> structure is defined in the Ws2tcpip.h header file included with the Platform SDK released for Windows XP and
            later and the Windows SDK released for Windows Vista and later.
            </para>
            <para>
            To execute an application that uses the getaddrinfo function and the <c>addrinfo</c> structure on earlier versions of Windows
            (Windows 2000), then you need to include the Ws2tcpip.h and Wspiapi.h files. When the Wspiapi.h include file is added, the
            <c>getaddrinfo</c> function is defined to the WspiapiGetAddrInfo inline function in the Wspiapi.h file. At runtime, the
            WspiapiGetAddrInfo function is implemented in such a way that if the Ws2_32.dll or the Wship6.dll (the file containing
            <c>getaddrinfo</c> in the IPv6 Technology Preview for Windows 2000) does not include <c>getaddrinfo</c>, then a version of
            <c>getaddrinfo</c> is implemented inline based on code in the Wspiapi.h header file. This inline code will be used on older
            Windows platforms that do not natively support the <c>getaddrinfo</c> function.
            </para>
            <para>
            The IPv6 protocol is supported on Windows 2000 when the IPv6 Technology Preview for Windows 2000 is installed. Otherwise
            getaddrinfo support on versions of Windows earlier than Windows XP is limited to handling IPv4 name resolution.
            </para>
            <para>
            The GetAddrInfoW function that uses the addrinfoW structure is the Unicode version of the getaddrinfo function and associated
            <c>addrinfo</c> structure. The <c>GetAddrInfoW</c> function was added to the Ws2_32.dll in Windows XP with Service Pack 2 (SP2).
            The <c>GetAddrInfoW</c> function and the <c>addrinfoW</c> structure cannot be used on versions of Windows earlier than Windows
            XP with SP2.
            </para>
            <para>Examples</para>
            <para>The following code example shows the use of the <c>addrinfo</c> structure.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOW.ai_flags">
            <summary>
            <para>Type: <c>int</c></para>
            <para>Flags that indicate options used in the getaddrinfo function.</para>
            <para>
            Supported values for the <c>ai_flags</c> member are defined in the Ws2def.h header file on the Windows SDK for Windows 7 and
            later. These values are defined in the Ws2tcpip.h header file on the Windows SDK for Windows Server 2008 and Windows Vista.
            These values are defined in the Ws2tcpip.h header file on the Platform SDK for Windows Server 2003, and Windows XP.
            Supported values for the <c>ai_flags</c> member can be a combination of the following options.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AI_PASSIVE 0x01</term>
            <term>The socket address will be used in a call to the bindfunction.</term>
            </item>
            <item>
            <term>AI_CANONNAME 0x02</term>
            <term>The canonical name is returned in the first ai_canonname member.</term>
            </item>
            <item>
            <term>AI_NUMERICHOST 0x04</term>
            <term>The nodename parameter passed to the getaddrinfo function must be a numeric string.</term>
            </item>
            <item>
            <term>AI_ALL 0x0100</term>
            <term>
            If this bit is set, a request is made for IPv6 addresses and IPv4 addresses with AI_V4MAPPED. This option is supported on
            Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AI_ADDRCONFIG 0x0400</term>
            <term>
            The getaddrinfo will resolve only if a global address is configured. The IPv6 and IPv4 loopback address is not considered a
            valid global address. This option is supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AI_V4MAPPED 0x0800</term>
            <term>
            If the getaddrinfo request for IPv6 addresses fails, a name service request is made for IPv4 addresses and these addresses
            are converted to IPv4-mapped IPv6 address format. This option is supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AI_NON_AUTHORITATIVE 0x04000</term>
            <term>
            The address information can be from a non-authoritative namespace provider. This option is only supported on Windows Vista
            and later for the NS_EMAIL namespace.
            </term>
            </item>
            <item>
            <term>AI_SECURE 0x08000</term>
            <term>
            The address information is from a secure channel. This option is only supported on Windows Vista and later for the NS_EMAIL namespace.
            </term>
            </item>
            <item>
            <term>AI_RETURN_PREFERRED_NAMES 0x010000</term>
            <term>
            The address information is for a preferred name for a user. This option is only supported on Windows Vista and later for the
            NS_EMAIL namespace.
            </term>
            </item>
            <item>
            <term>AI_FQDN 0x00020000</term>
            <term>
            If a flat name (single label) is specified, getaddrinfo will return the fully qualified domain name that the name eventually
            resolved to. The fully qualified domain name is returned in the ai_canonname member. This is different than AI_CANONNAME bit
            flag that returns the canonical name registered in DNS which may be different than the fully qualified domain name that the
            flat name resolved to. Only one of the AI_FQDN and AI_CANONNAME bits can be set. The getaddrinfo function will fail if both
            flags are present with EAI_BADFLAGS. This option is supported on Windows 7, Windows Server 2008 R2, and later.
            </term>
            </item>
            <item>
            <term>AI_FILESERVER 0x00040000</term>
            <term>
            A hint to the namespace provider that the hostname being queried is being used in a file share scenario. The namespace
            provider may ignore this hint. This option is supported on Windows 7, Windows Server 2008 R2, and later.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.ADDRINFOW.ai_family">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The address family. Possible values for the address family are defined in the Winsock2.h include file.</para>
            <para>
            On the Windows SDK released for Windows Vista and later,, the organization of header files has changed and the possible
            values for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically
            included in Winsock2.h, and should never be used directly.
            </para>
            <para>
            The values currently supported are <c>AF_INET</c> or <c>AF_INET6</c>, which are the Internet address family formats for IPv4
            and IPv6. Other options for address family ( <c>AF_NETBIOS</c> for use with NetBIOS, for example) are supported if a Windows
            Sockets service provider for the address family is installed. Note that the values for the AF_ address family and PF_
            protocol family constants are identical (for example, <c>AF_UNSPEC</c> and <c>PF_UNSPEC</c>), so either constant can be used.
            </para>
            <para>The table below lists common values for the address family although many other values are possible.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AF_UNSPEC 0</term>
            <term>The address family is unspecified.</term>
            </item>
            <item>
            <term>AF_INET 2</term>
            <term>The Internet Protocol version 4 (IPv4) address family.</term>
            </item>
            <item>
            <term>AF_NETBIOS 17</term>
            <term>The NetBIOS address family. This address family is only supported if a Windows Sockets provider for NetBIOS is installed.</term>
            </item>
            <item>
            <term>AF_INET6 23</term>
            <term>The Internet Protocol version 6 (IPv6) address family.</term>
            </item>
            <item>
            <term>AF_IRDA 26</term>
            <term>
            The Infrared Data Association (IrDA) address family. This address family is only supported if the computer has an infrared
            port and driver installed.
            </term>
            </item>
            <item>
            <term>AF_BTH 32</term>
            <term>
            The Bluetooth address family. This address family is only supported if a Bluetooth adapter is installed on Windows Server
            2003 or later.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOW.ai_socktype">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The socket type. Possible values for the socket type are defined in the Winsock2.h header file.</para>
            <para>The following table lists the possible values for the socket type supported for Windows Sockets 2:</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SOCK_STREAM 1</term>
            <term>
            Provides sequenced, reliable, two-way, connection-based byte streams with an OOB data transmission mechanism. Uses the
            Transmission Control Protocol (TCP) for the Internet address family (AF_INET or AF_INET6). If the ai_family member is
            AF_IRDA, then SOCK_STREAM is the only supported socket type.
            </term>
            </item>
            <item>
            <term>SOCK_DGRAM 2</term>
            <term>
            Supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum length. Uses the User
            Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).
            </term>
            </item>
            <item>
            <term>SOCK_RAW 3</term>
            <term>
            Provides a raw socket that allows an application to manipulate the next upper-layer protocol header. To manipulate the IPv4
            header, the IP_HDRINCL socket option must be set on the socket. To manipulate the IPv6 header, the IPV6_HDRINCL socket
            option must be set on the socket.
            </term>
            </item>
            <item>
            <term>SOCK_RDM 4</term>
            <term>
            Provides a reliable message datagram. An example of this type is the Pragmatic General Multicast (PGM) multicast protocol
            implementation in Windows, often referred to as reliable multicast programming.
            </term>
            </item>
            <item>
            <term>SOCK_SEQPACKET 5</term>
            <term>Provides a pseudo-stream packet based on datagrams.</term>
            </item>
            </list>
            <para>
            In Windows Sockets 2, new socket types were introduced. An application can dynamically discover the attributes of each
            available transport protocol through the WSAEnumProtocols function. So an application can determine the possible socket type
            and protocol options for an address family and use this information when specifying this parameter. Socket type definitions
            in the Winsock2.h and Ws2def.h header files will be periodically updated as new socket types, address families, and
            protocols are defined.
            </para>
            <para>In Windows Sockets 1.1, the only possible socket types are <c>SOCK_DATAGRAM</c> and <c>SOCK_STREAM</c>.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOW.ai_protocol">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            The protocol type. The possible options are specific to the address family and socket type specified. Possible values for
            the <c>ai_protocol</c> are defined in the Winsock2.h and Wsrm.h header files.
            </para>
            <para>
            On the Windows SDK released for Windows Vista and later, the organization of header files has changed and this member can be
            one of the values from the <c>IPPROTO</c> enumeration type defined in the Ws2def.h header file. Note that the Ws2def.h
            header file is automatically included in Winsock2.h, and should never be used directly.
            </para>
            <para>
            If a value of 0 is specified for <c>ai_protocol</c>, the caller does not wish to specify a protocol and the service provider
            will choose the <c>ai_protocol</c> to use. For protocols other than IPv4 and IPv6, set <c>ai_protocol</c> to zero.
            </para>
            <para>The following table lists common values for the <c>ai_protocol</c> member although many other values are possible.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>IPPROTO_TCP 6</term>
            <term>
            The Transmission Control Protocol (TCP). This is a possible value when the ai_family member is AF_INET or AF_INET6 and the
            ai_socktype member is SOCK_STREAM.
            </term>
            </item>
            <item>
            <term>IPPROTO_UDP 17</term>
            <term>
            The User Datagram Protocol (UDP). This is a possible value when the ai_family member is AF_INET or AF_INET6 and the type
            parameter is SOCK_DGRAM.
            </term>
            </item>
            <item>
            <term>IPPROTO_RM 113</term>
            <term>
            The PGM protocol for reliable multicast. This is a possible value when the ai_family member is AF_INET and the ai_socktype
            member is SOCK_RDM. On the Windows SDK released for Windows Vista and later, this value is also called IPPROTO_PGM.
            </term>
            </item>
            </list>
            <para>If the <c>ai_family</c> member is <c>AF_IRDA</c>, then the <c>ai_protocol</c> must be 0.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOW.ai_addrlen">
            <summary>
            <para>Type: <c>size_t</c></para>
            <para>The length, in bytes, of the buffer pointed to by the <c>ai_addr</c> member.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOW.ai_canonname">
            <summary>
            <para>Type: <c>char*</c></para>
            <para>The canonical name for the host.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOW.ai_addr">
            <summary>
            <para>Type: <c>struct sockaddr*</c></para>
            <para>
            A pointer to a sockaddr structure. The <c>ai_addr</c> member in each returned <c>addrinfo</c> structure points to a
            filled-in socket address structure. The length, in bytes, of each returned <c>addrinfo</c> structure is specified in the
            <c>ai_addrlen</c> member.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.ADDRINFOW.ai_next">
            <summary>
            <para>Type: <c>struct addrinfo*</c></para>
            <para>
            A pointer to the next structure in a linked list. This parameter is set to <c>NULL</c> in the last <c>addrinfo</c> structure
            of a linked list.
            </para>
            </summary>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.ADDRINFOW.addr">
            <summary>
            <para>Type: <c>struct sockaddr*</c></para>
            <para>
            A pointer to a sockaddr structure. The <c>ai_addr</c> member in each returned ADDRINFOW structure points to a filled-in
            socket address structure. The length, in bytes, of each returned <c>ADDRINFOW</c> structure is specified in the
            <c>ai_addrlen</c> member.
            </para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.ADDRINFOW.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SCOPE_ID">
            <summary>The scope identifier for the IPv6 transport address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SCOPE_ID.Value">
            <summary>A ULONG representation of the IPv6 scope identifier.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.SCOPE_ID.Zone">
            <summary>
            <para>
            The zone index that identifies the zone to which the transport address pertains. Zones of the different scopes are
            instantiated as follows:
            </para>
            <list type="bullet">
            <item>Each interface on a node comprises a single zone of interface-local scope.</item>
            <item>Each link, and the interfaces attached to that link, comprise a single zone of link-local scope.</item>
            <item>There is a single zone of global scope that comprises all of the links and interfaces in the Internet.</item>
            <item>The boundaries of zones of scope other than interface-local, link-local, and global are defined by network administrators.</item>
            </list>
            <para>A value of zero specifies the default zone.</para>
            </summary>
            <value>The zone index.</value>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.SCOPE_ID.Level">
            <summary>
            <para>
            The scope of the IPv6 transport address. This scope must be the same as the IPv6 scope value that is embedded in the IPv6
            transport address. This member can be one of the following:
            </para>
            <para><strong>ScopeLevelInterface</strong></para>
            <para>The transport address has interface-local scope.</para>
            <para><strong>ScopeLevelLink</strong></para>
            <para>The transport address has link-local scope.</para>
            <para><strong>ScopeLevelSubnet</strong></para>
            <para>The transport address has subnet-local scope.</para>
            <para><strong>ScopeLevelAdmin</strong></para>
            <para>The transport address has admin-local scope.</para>
            <para><strong>ScopeLevelSite</strong></para>
            <para>The transport address has site-local scope.</para>
            <para><strong>ScopeLevelOrganization</strong></para>
            <para>The transport address has organization-local scope.</para>
            <para><strong>ScopeLevelGlobal</strong></para>
            <para>The transport address has global scope.</para>
            </summary>
            <value>The level.</value>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN">
            <summary>The SOCKADDR_IN structure specifies a transport address and port for the AF_INET address family.</summary>
            <remarks>
            All of the data in the SOCKADDR_IN structure, except for the address family, must be specified in network-byte-order (big-endian).
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKADDR_IN.sin_family">
            <summary>The address family for the transport address. This member should always be set to AF_INET.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKADDR_IN.sin_port">
            <summary>A transport protocol port number.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKADDR_IN.sin_addr">
            <summary>An IN_ADDR structure that contains an IPv4 transport address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKADDR_IN.sin_zero">
            <summary>Reserved for system use. A WSK application should set the contents of this array to zero.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR_IN.#ctor(Vanara.PInvoke.Ws2_32.IN_ADDR,System.UInt16)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN"/> struct.</summary>
            <param name="addr">An IN_ADDR structure that contains an IPv4 transport address.</param>
            <param name="port">A transport protocol port number.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR_IN.op_Implicit(Vanara.PInvoke.Ws2_32.IN_ADDR)~Vanara.PInvoke.Ws2_32.SOCKADDR_IN">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.IN_ADDR"/> to <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN"/>.</summary>
            <param name="addr">The addr.</param>
            <returns>The resulting <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN"/> instance from the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR_IN.ToString">
            <summary>Converts to string.</summary>
            <returns>A <see cref="T:System.String"/> that represents this instance.</returns>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE">
            <summary>The SOCKADDR_STORAGE structure is a generic structure that specifies a transport address.</summary>
            <remarks>
            A WSK application typically does not directly access any of the members of the SOCKADDR_STORAGE structure except for the
            <c>ss_family</c> member. Instead, a pointer to a SOCKADDR_STORAGE structure is normally cast to a pointer to the specific
            SOCKADDR structure type that corresponds to a particular address family.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE.ss_family">
            <summary>
            The address family for the transport address. For more information about supported address families, see WSK Address Families.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE.__ss_pad1">
            <summary>A padding of 6 bytes that puts the <c>__ss_align</c> member on an eight-byte boundary within the structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE.__ss_align">
            <summary>A 64-bit value that forces the structure to be 8-byte aligned.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE.__ss_pad2">
            <summary>A padding of an additional 112 bytes that brings the total size of the SOCKADDR_STORAGE structure to 128 bytes.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE.op_Explicit(Vanara.PInvoke.Ws2_32.SOCKADDR_IN6@)~Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6"/> to <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE"/>.</summary>
            <param name="addr">The address.</param>
            <returns>The resulting <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE"/> instance from the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE.op_Explicit(Vanara.PInvoke.Ws2_32.SOCKADDR_IN@)~Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN"/> to <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE"/>.</summary>
            <param name="addr">The address.</param>
            <returns>The resulting <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE"/> instance from the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE.op_Explicit(Vanara.PInvoke.Ws2_32.SOCKADDR)~Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR"/> to <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE"/>.</summary>
            <param name="addr">The address.</param>
            <returns>The resulting <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE"/> instance from the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE.op_Explicit(System.Net.IPAddress)~Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE">
            <summary>Performs an explicit conversion from <see cref="T:System.Net.IPAddress"/> to <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE"/>.</summary>
            <param name="addr">The address.</param>
            <returns>The resulting <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE"/> instance from the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE.op_Explicit(Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE)~Vanara.PInvoke.Ws2_32.SOCKADDR">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE"/> to <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR"/>.</summary>
            <param name="addr">The addr.</param>
            <returns>The resulting <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR"/> instance from the conversion.</returns>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SOCKET_ADDRESS">
            <summary>The <c>SOCKET_ADDRESS</c> structure stores protocol-specific address information.</summary>
            <remarks>
            <para>
            The SOCKADDR structure pointed to by the <c>lpSockaddr</c> member varies depending on the protocol or address family selected.
            For example, the <c>sockaddr_in6</c> structure is used for an IPv6 socket address while the <c>sockaddr_in4</c> structure is
            used for an IPv4 socket address. The address family is the first member of all of the <c>SOCKADDR</c> structures. The address
            family is used to determine which structure is used.
            </para>
            <para>
            On the Microsoft Windows Software Development Kit (SDK) released for Windows Vista and later, the organization of header files
            has changed and the <c>SOCKET_ADDRESS</c> structure is defined in the Ws2def.h header file. Note that the Ws2def.h header file
            is automatically included in Winsock2.h, and should never be used directly.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKET_ADDRESS.lpSockaddr">
            <summary>A pointer to a socket address represented as a SOCKADDR structure.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKET_ADDRESS.iSockaddrLength">
            <summary>The length, in bytes, of the socket address.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKET_ADDRESS.GetSOCKADDR">
            <summary>Gets the <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_INET"/> from this instance.</summary>
            <returns>The <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_INET"/> value pointed to by this instance.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKET_ADDRESS.ToString">
            <summary>Converts to string.</summary>
            <returns>A <see cref="T:System.String"/> that represents this instance.</returns>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SOCKET_ADDRESS_LIST">
            <summary>The SOCKET_ADDRESS_LIST structure defines a variable-sized list of transport addresses.</summary>
            <remarks>
            <para>
            A WSK application passes a buffer to the WskControlSocket function when the WSK application queries the current list of local
            transport addresses that match a socket's address family. If the call to the <c>WskControlSocket</c> function succeeds, the
            buffer contains a SOCKET_ADDRESS_LIST structure followed by the SOCKADDR structures for each of the local transport addresses
            that match the socket's address family. The WSK subsystem fills in the <c>Address</c> array and sets the <c>iAddressCount</c>
            member to the number of entries in the array. The <c>lpSockaddr</c> pointers in each of the SOCKET_ADDRESS structures in the
            array point to the specific SOCKADDR structure type that corresponds to the address family that the WSK application specified
            when it created the socket.
            </para>
            <para>For more information about querying the current list of local transport addresses, see SIO_ADDRESS_LIST_QUERY.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKET_ADDRESS_LIST.iAddressCount">
            <summary>The number of transport addresses in the list.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKET_ADDRESS_LIST.Address">
            <summary>A variable-sized array of SOCKET_ADDRESS structures. The SOCKET_ADDRESS structure is defined as follows:</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SOCKET_PROCESSOR_AFFINITY">
            <summary>
            The <c>SOCKET_PROCESSOR_AFFINITY</c> structure contains the association between a socket and an RSS processor core and NUMA node..
            </summary>
            <remarks>
            <para>
            The <c>SOCKET_PROCESSOR_AFFINITY</c> structure is supported on Windows 8, and Windows Server 2012, and later versions of the
            operating system.
            </para>
            <para>
            The SIO_QUERY_RSS_PROCESSOR_INFO IOCTL is used to determine the association between a socket and an RSS processor core and NUMA
            node. This IOCTL returns a <c>SOCKET_PROCESSOR_AFFINITY</c> structure that contains the processor number and the NUMA node ID.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKET_PROCESSOR_AFFINITY.Processor">
            <summary>
            A structure to represent a system wide processor number. This PROCESSOR_NUMBER structure contains a group number and
            relative processor number within the group.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKET_PROCESSOR_AFFINITY.NumaNodeId">
            <summary>The NUMA node ID.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKET_PROCESSOR_AFFINITY.Reserved">
            <summary>A value reserved for future use.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WSABUF">
            <summary>The <c>WSABUF</c> structure enables the creation or manipulation of a data buffer used by some Winsock functions.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSABUF.len">
            <summary>The length of the buffer, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSABUF.buf">
            <summary>A pointer to the buffer.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WSAMSG">
            <summary>
            The <c>WSAMSG</c> structure is used with the WSARecvMsg and WSASendMsg functions to store address and optional control
            information about connected and unconnected sockets as well as an array of buffers used to store message data.
            </summary>
            <remarks>
            <para>
            In the Microsoft Windows Software Development Kit (SDK), the version of this structure for use on Windows Vistais defined with
            the data type for the <c>dwBufferCount</c> and <c>dwFlags</c> members as a <c>ULONG</c>. When compiling an application if the
            target platform is Windows Vista and later ( <c>NTDDI_VERSION &gt;= NTDDI_LONGHORN, _WIN32_WINNT &gt;= 0x0600</c>, or <c>WINVER
            &gt;= 0x0600</c>), the data type for the <c>dwBufferCount</c> and <c>dwFlags</c> members is a <c>ULONG</c>.
            </para>
            <para>
            <c>Windows Server 2003 and Windows XP:</c> When compiling an application, the data type for the <c>dwBufferCount</c> and
            <c>dwFlags</c> members is a <c>DWORD</c>.
            </para>
            <para>
            On the Windows SDK released for Windows Vista and later, the <c>WSAMSG</c> structure is defined in the Ws2def.h header file.
            Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly
            </para>
            <para>
            If the datagram or control data is truncated during the transmission, the function being used in association with the
            <c>WSAMSG</c> structure returns SOCKET_ERROR and a call to the WSAGetLastError function returns WSAEMSGSIZE. It is up to the
            application to determine what was truncated by checking for MSG_TRUNC and/or MSG_CTRUNC flags.
            </para>
            <para>Use of the Control Member</para>
            <para>
            The following table summarizes the various uses of control data available for use in the <c>Control</c> member for IPv4 and IPv6.
            </para>
            <list type="table">
            <listheader>
            <term>Protocol</term>
            <term>cmsg_level</term>
            <term>cmsg_type</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>IPv4</term>
            <term>IPPROTO_IP</term>
            <term>IP_ORIGINAL_ARRIVAL_IF</term>
            <term>
            Receives the original IPv4 arrival interface where the packet was received for datagram sockets. This control data is used by
            firewalls when a Teredo, 6to4, or ISATAP tunnel is used for IPv4 NAT traversal. The cmsg_data[] member in the WSAMSG structure
            is a ULONG that contains the IF_INDEX defined in the Ifdef.h header file. For more information, see the IPPROTO_IP Socket
            Options for the IP_ORIGINAL_ARRIVAL_IF socket option. Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP:
            The IP_ORIGINAL_ARRIVAL_IF cmsg_type is not supported.
            </term>
            </item>
            <item>
            <term>IPv4</term>
            <term>IPPROTO_IP</term>
            <term>IP_PKTINFO</term>
            <term>Specifies/receives packet information for an IPv4 socket. For more information, see the IP_PKTINFO socket option.</term>
            </item>
            <item>
            <term>IPv6</term>
            <term>IPPROTO_IPV6</term>
            <term>IPV6_DSTOPTS</term>
            <term>Specifies/receives destination options.</term>
            </item>
            <item>
            <term>IPv6</term>
            <term>IPPROTO_IPV6</term>
            <term>IPV6_HOPLIMIT</term>
            <term>Specifies/receives hop limit. For more information, see the IPPROTO_IPV6 Socket Options for the IPV6_HOPLIMIT socket option.</term>
            </item>
            <item>
            <term>IPv6</term>
            <term>IPPROTO_IPV6</term>
            <term>IPV6_HOPOPTS</term>
            <term>Specifies/receives hop-by-hop options.</term>
            </item>
            <item>
            <term>IPv6</term>
            <term>IPPROTO_IPV6</term>
            <term>IPV6_NEXTHOP</term>
            <term>Specifies next-hop address.</term>
            </item>
            <item>
            <term>IPv6</term>
            <term>IPPROTO_IPV6</term>
            <term>IPV6_PKTINFO</term>
            <term>Specifies/receives packet information for an IPv6 socket. For more information, see the IPV6_PKTINFO socket option.</term>
            </item>
            <item>
            <term>IPv6</term>
            <term>IPPROTO_IPV6</term>
            <term>IPV6_RTHDR</term>
            <term>Specifies/receives routing header.</term>
            </item>
            </list>
            <para>
            Control data is made up of one or more control data objects, each beginning with a <c>WSACMSGHDR</c> structure, defined as the following.
            </para>
            <para>
            <c>Note</c> The transport, not the application, fills out the header information in the <c>WSACMSGHDR</c> structure. The
            application simply sets the needed socket options and provides the adequate buffer size.
            </para>
            <para>The members of the <c>WSACMSGHDR</c> structure are as follows:</para>
            <list type="table">
            <listheader>
            <term>Term</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>cmsg_len</term>
            <term>
            The number of bytes of data starting from the beginning of the WSACMSGHDR to the end of data (excluding padding bytes that may
            follow data).
            </term>
            </item>
            <item>
            <term>cmsg_level</term>
            <term>The protocol that originated the control information.</term>
            </item>
            <item>
            <term>cmsg_type</term>
            <term>The protocol-specific type of control information.</term>
            </item>
            </list>
            <para>The following macros are used to navigate the data objects:</para>
            <para>
            Returns a pointer to the first control data object. Returns a <c>NULL</c> pointer if there is no control data in the
            <c>WSAMSG</c> structure, such as when the <c>Control</c> member is a <c>NULL</c> pointer.
            </para>
            <para>
            Returns a pointer to the next control data object, or <c>NULL</c> if there are no more data objects. If the pcmsg parameter is
            <c>NULL</c>, a pointer to the first control data object is returned.
            </para>
            <para>
            Returns a pointer to the first byte of data (referred to as the <c>cmsg_data</c> member, though it is not defined in the structure).
            </para>
            <para>
            Returns the total size of a control data object, given the amount of data. Used to allocate the correct amount of buffer space.
            Includes alignment padding.
            </para>
            <para>Returns the value in <c>cmsg_len</c> given the amount of data. Includes alignment padding.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAMSG.name">
            <summary>
            <para>Type: <c>LPSOCKADDR</c></para>
            <para>
            A pointer to a SOCKET_ADDRESS structure that stores information about the remote address. Used only with unconnected sockets.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAMSG.namelen">
            <summary>
            <para>Type: <c>INT</c></para>
            <para>
            The length, in bytes, of the SOCKET_ADDRESS structure pointed to in the <c>pAddr</c> member. Used only with unconnected sockets.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAMSG.lpBuffers">
            <summary>
            <para>Type: <c>LPWSABUF</c></para>
            <para>
            An array of WSABUF structures used to receive the message data. The capability of the <c>lpBuffers</c> member to contain
            multiple buffers enables the use of scatter/gather I/O.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAMSG.dwBufferCount">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The number of buffers pointed to in the <c>lpBuffers</c> member.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAMSG.Control">
            <summary>
            <para>Type: <c>WSABUF</c></para>
            <para>A structure of WSABUF type used to specify optional control data. See Remarks.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAMSG.dwFlags">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            One or more control flags, specified as the logical <c>OR</c> of values. The possible values for <c>dwFlags</c> member on
            input are defined in the Winsock2.h header file. The possible values for <c>dwFlags</c> member on output are defined in the
            Ws2def.h header file which is automatically included by the Winsock2.h header file.
            </para>
            <list type="table">
            <listheader>
            <term>Flags on input</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MSG_PEEK</term>
            <term>
            Peek at the incoming data. The data is copied into the buffer, but is not removed from the input queue. This flag is valid
            only for non-overlapped sockets.
            </term>
            </item>
            </list>
            <list type="table">
            <listheader>
            <term>Flag returned</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MSG_BCAST</term>
            <term>The datagram was received as a link-layer broadcast or with a destination IP address that is a broadcast address.</term>
            </item>
            <item>
            <term>MSG_MCAST</term>
            <term>The datagram was received with a destination IP address that is a multicast address.</term>
            </item>
            <item>
            <term>MSG_TRUNC</term>
            <term>The datagram was truncated. More data was present than the process allocated room for.</term>
            </item>
            <item>
            <term>MSG_CTRUNC</term>
            <term>The control (ancillary) data was truncated. More control data was present than the process allocated room for.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WinSockIOControlCode">
            <summary>
            <para>
            Some of the socket IOCTL opcodes for Windows Sockets 2 are summarized in the following table. More detailed information is in
            the Winsock reference on <c>Winsock IOCTLs</c> and the <c>WSPIoctl</c> function. There are other new protocol-specific IOCTL
            opcodes that can be found in the protocol-specific annex.
            </para>
            <para>A complete list of <c>Winsock IOCTLs</c> are available in the Winsock reference.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WinSockIOControlCode.SIO_ADDRESS_LIST_CHANGE">
            <summary>Requests notification of changes in information reported through SIO_ADDRESS_LIST_QUERY</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WinSockIOControlCode.SIO_ADDRESS_LIST_QUERY">
            <summary>
            Obtains a list of local transport addresses of the socket's protocol family to which the application can bind. The list of
            addresses varies based on address family and some addresses are excluded from the list.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WinSockIOControlCode.SIO_ADDRESS_LIST_SORT">
            <summary>
            Allows application developers to sort a list of IPv6 and IPv4 destination addresses to determine the best available address
            for making a connection.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WinSockIOControlCode.SIO_ASSOCIATE_HANDLE">
            <summary>Associates the socket with the specified handle of a companion interface.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WinSockIOControlCode.SIO_ENABLE_CIRCULAR_QUEUEING">
            <summary>Enables circular queuing.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WinSockIOControlCode.SIO_FIND_ROUTE">
            <summary>Requests the route to the specified address to be discovered.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WinSockIOControlCode.SIO_FLUSH">
            <summary>Discards current contents of the sending queue.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WinSockIOControlCode.SIO_GET_BROADCAST_ADDRESS">
            <summary>Retrieves the protocol-specific broadcast address to be used in WSPSendTo.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WinSockIOControlCode.SIO_GET_EXTENSION_FUNCTION_POINTER">
            <summary>Gets the function pointer for the WSASendMsg function obtained at run time.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WinSockIOControlCode.SIO_GET_GROUP_QOS">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WinSockIOControlCode.SIO_GET_QOS">
            <summary>Retrieves current flow specifications for the socket.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WinSockIOControlCode.SIO_MULTICAST_SCOPE">
            <summary>Specifies the scope over which multicast transmissions will occur.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WinSockIOControlCode.SIO_MULTIPOINT_LOOPBACK">
            <summary>Controls whether data sent in a multipoint session will also be received by the same socket on the local host.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WinSockIOControlCode.SIO_QUERY_RSS_PROCESSOR_INFO">
            <summary>Queries the association between a socket and an RSS processor core and NUMA node.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WinSockIOControlCode.SIO_QUERY_TARGET_PNP_HANDLE">
            <summary>Obtains socket descriptor of the next provider in the chain on which current socket depends in regards to PnP.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WinSockIOControlCode.SIO_ROUTING_INTERFACE_CHANGE">
            <summary>
            Requests notification of changes in information reported through SIO_ROUTING_INTERFACE_QUERY for the specified address.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WinSockIOControlCode.SIO_ROUTING_INTERFACE_QUERY">
            <summary>Obtains the address of the local interface that should be used to send to the specified address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WinSockIOControlCode.SIO_SET_GROUP_QOS">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WinSockIOControlCode.SIO_SET_QOS">
            <summary>Establishes new flow specifications for the socket.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WinSockIOControlCode.SIO_TRANSLATE_HANDLE">
            <summary>Obtains a corresponding handle for socket s that is valid in the context of a companion interface.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IOC_IN">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IOC_INOUT">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IOC_OUT">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IOC_VOID">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IOCPARM_MASK">
            <summary/>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SIO_GET_INTERFACE_LIST">
            <summary>
            It is used to return information about each interface on the local machine. Nothing is required on input, but on output, an array of INTERFACE_INFO structures is returned.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SIO_GET_INTERFACE_LIST_EX">
            <summary>
            This ioctl is the same as SIO_GET_INTERFACE_LIST except the structure returned contains embedded SOCKET_ADDRESS structure to describe each local interface, as opposed to SOCKADDR_GEN structure. This removes the dependency the size of the socket address structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SIO_GET_MULTICAST_FILTER">
            <summary>
            This ioctl retrieves the multicast filter set on a given socket. The multicast state is set with the SIO_SET_MULTICAST_FILTER ioctl. This ioctl requires an IGMPv3-enabled network and is supported in only Windows XP.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SIO_SET_MULTICAST_FILTER">
            <summary>
            This ioctl sets the multicast state. The input parameter is a struct ip_msfilter.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SIOCGIPMSFILTER">
            <summary>
            This ioctl retrieves the multicast filter set on a given socket. The multicast state is set with the SIO_SET_MULTICAST_FILTER ioctl. This ioctl requires an IGMPv3-enabled network and is supported in only Windows XP.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SIOCGMSFILTER">
            <summary>
            Enables an application to retrieve a list of the IPv4 or IPv6 source addresses that comprise the source filter along with the current mode on a given interface index and a multicast group for a socket. The source filter may either include or exclude the set of source address, depending on the filter mode (MCAST_INCLUDE or MCAST_EXCLUDE), which is defined in the GROUP_FILTER structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SIOCSIPMSFILTER">
            <summary>
            This ioctl sets the multicast state. The input parameter is a struct ip_msfilter.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SIOCSMSFILTER">
            <summary>
            Enables an application to specify or modify a list of IPv4 or IPv6 source addresses on a given interface index and to specify or modify a multicast group for a socket. The source filter can include or exclude the set of source address, depending on the filter mode (MCAST_INCLUDE or MCAST_EXCLUDE), which is defined in the GROUP_FILTER structure of the BPXYIOCC macro. The application can join multiple source multicast groups on a single socket; it also can join the same group on multiple interfaces on the same socket. However, there is a maximum limit of 20 groups per single UDP socket and there is a maximum limit of 256 groups per single RAW socket.
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.MULTICAST_MODE_TYPE">
            <summary>The <c>MULTICAST_MODE_TYPE</c> enumeration specifies the filter mode for multicast group addresses.</summary>
            <remarks>
            <para>This enumeration is supported on Windows Vistaand later.</para>
            <para>
            The <c>MULTICAST_MODE_TYPE</c> enumeration is used in the <c>gf_fmode</c> member of the GROUP_SOURCE_REQ structure to determine
            if a list of IP addresses should included or excluded. The values from this enumeration can also be used in the
            <c>imsf_fmode</c> member of the ip_msfilter structure.
            </para>
            <para>
            The <c>MULTICAST_MODE_TYPE</c> enumeration is defined in the Ws2ipdef.h header file which is automatically included in the
            Ws2tcpip.h header file. The Ws2ipdef.h header files should never be used directly.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.MULTICAST_MODE_TYPE.MCAST_INCLUDE">
            <summary>The filter contains a list of IP addresses to include.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.MULTICAST_MODE_TYPE.MCAST_EXCLUDE">
            <summary>The filter contains a list of IP addresses to exclude.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32._IOR(System.Char,System.UInt32,System.Type)">
            <summary>
            Used for an ioctl that reads data from the device driver. The driver will be allowed to return sizeof(data_type) bytes to the user.
            </summary>
            <param name="x">The type.</param>
            <param name="y">The value.</param>
            <param name="t">The type from which a size is extracted.</param>
            <returns>IOCtrl value.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32._IOW(System.Char,System.UInt32,System.Type)">
            <summary>Used for an ioctl that writes data to the device driver.</summary>
            <param name="x">The type.</param>
            <param name="y">The value.</param>
            <param name="t">The type from which a size is extracted.</param>
            <returns>IOCtrl value.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.GROUP_FILTER_SIZE(System.Int32)">
            <summary>Gets the size, in bytes, of an GROUP_FILTER with a number of SOCKADDR_STORAGE items.</summary>
            <param name="numsrc">The number of SOCKADDR_STORAGE sources.</param>
            <returns>Size, in bytes.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.IP_MSFILTER_SIZE(System.Int32)">
            <summary>Gets the size, in bytes, of an IP_MSFILTER with a number of IN_ADDR items.</summary>
            <param name="NumSources">The number of IN_ADDR sources.</param>
            <returns>Size, in bytes.</returns>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.GROUP_FILTER">
            <summary>The <c>GROUP_FILTER</c> structure provides multicast filtering parameters for multicast IPv6 or IPv4 addresses.</summary>
            <remarks>
            <para>
            The <c>GROUP_FILTER</c> structure is used with either IPv6 or IPv4 multicast addresses. The <c>GROUP_FILTER</c> structure is
            passed as an argument for the <c>SIOCGMSFILTER</c> and <c>SIOCSMSFILTER</c> IOCTLs.
            </para>
            <para>
            The <c>GROUP_FILTER</c> structure and related structures used for multicast programming are based on IETF recommendations in
            sections 5 and 8.2 of RFC 3768. For more information, see http://www.ietf.org/rfc/rfc3678.txt.
            </para>
            <para>
            On Windows Vista and later, a set of socket options are available for multicast programming that support IPv6 and IPv4
            addresses. These socket options are IP agnostic and can be used on both IPv6 and IPv4. These IP agnostic options use the
            GROUP_REQ and the GROUP_SOURCE_REQ structures and are the preferred socket options for multicast programming on Windows Vista
            and later.
            </para>
            <para>The GetAdaptersAddresses function can be used to obtain interface index information required for the gf_interface member.</para>
            <para>
            The <c>GROUP_FILTER</c> structure and the Ioctls that use this structure are only valid on datagram and raw sockets (the socket
            type must be <c>SOCK_DGRAM</c> or <c>SOCK_RAW</c>).
            </para>
            <para>
            The <c>GROUP_FILTER</c> structure is defined in the Ws2ipdef.h header file which is automatically included in the Ws2tcpip.h
            header file. The Ws2ipdef.h header files should never be used directly.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.GROUP_FILTER.gf_interface">
            <summary>The interface index of the local interface for the multicast group to filter.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.GROUP_FILTER.gf_group">
            <summary>The multicast address group that should be filtered. This may be either an IPv6 or IPv4 multicast address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.GROUP_FILTER.gf_fmode">
            <summary>
            <para>The multicast filter mode.</para>
            <para>
            This member can be one of the values from the MULTICAST_MODE_TYPE enumeration type defined in the Ws2ipdef.h header file.
            This member determines if the list of IP addresses in the <c>gf_numsrc</c> member should be included or excluded.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>MCAST_INCLUDE</term>
            <term>The filter contains a list of IP addresses to include.</term>
            </item>
            <item>
            <term>MCAST_EXCLUDE</term>
            <term>The filter contains a list of IP addresses to exclude.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.GROUP_FILTER.gf_numsrc">
            <summary>The number of multicast filter source address entries in the <c>gf_slist</c> member.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.GROUP_FILTER.gf_slist">
            <summary>
            An array of SOCKADDR_STORAGE structures specifying the multicast source addresses to include or exclude. These IP addresses
            may be either IPv6 or IPv4 addresses, but they must be the same address family (IPv6 or IPv4) as the address specified in
            the <c>gf_group</c> member..
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.IP_MSFILTER">
            <summary>The <c>ip_msfilter</c> structure provides multicast filtering parameters for IPv4 addresses.</summary>
            <remarks>
            <para>
            The <c>ip_msfilter</c> structure is used with IPv4 addresses. The <c>ip_msfilter</c> structure is passed as an argument for the
            <c>SIO_GET_MULTICAST_FILTER</c> and <c>SIO_SET_MULTICAST_FILTER</c> IOCTLs.
            </para>
            <para>
            The <c>ip_msfilter</c> structure and related structures used for IPv4 multicast programming are based on IETF recommendations in
            sections 4 and 8.1 of RFC 3768. For more information, see http://www.ietf.org/rfc/rfc3678.txt.
            </para>
            <para>
            On Windows Vista and later, a set of socket options are available for multicast programming that support IPv6 and IPv4
            addresses. These socket options are IP agnostic and can be used on both IPv6 and IPv4. These IP agnostic options use the
            GROUP_REQ and the GROUP_SOURCE_REQ structures and the <c>SIOCSMSFILTER</c> and <c>SIOCGMSFILTER</c> IOCTLs. These are the
            preferred socket options and IOCTLs for multicast programming on Windows Vista and later.
            </para>
            <para>
            The <c>imsf_interface</c> member can be an interface index. Any IPv4 address in the 0.x.x.x block (first octet of 0) except for
            the IPv4 address of 0.0.0.0 is treated as an interface index. An interface index is a 24-bit number. The 0.0.0.0/8 IPv4 address
            block is not used (this range is reserved). The GetAdaptersAddresses function can be used to obtain interface index information
            to use for the <c>imsf_interface</c> member.
            </para>
            <para>
            It is recommended that a local IPv4 address or interface index always be specified in the <c>imsf_interface</c> member of the
            <c>ip_msfilter</c> structure, rather than use the default interface. This is particularly important on computers with multiple
            network interfaces and multiple public IPv4 addresses.
            </para>
            <para>
            The default interface used for IPv4 multicast is determined by the networking stack in Windows. An application can determine the
            default interface used for IPv4 multicast using the GetIpForwardTable function to retrieve the IPv4 routing table. The network
            interface with the lowest value for the routing metric for a destination IP address of 224.0.0.0 is the default interface for
            IPv4 multicast. The routing table can also be displayed from the command prompt with the following command:
            </para>
            <para><c>route print</c></para>
            <para>
            The IP_MULTICAST_IF socket option can be used to set the default interface to send IPv4 multicast packets. This socket option
            does not change the default interface used to receive IPv4 multicast packets.
            </para>
            <para>
            A typical IPv4 multicast application would use the IP_ADD_MEMBERSHIP socket option with the ip_mreq structure or the
            <c>IP_ADD_SOURCE_MEMBERSHIP</c> socket option with the ip_mreq_source structure to join a multicast group and listen for
            multicast packets on a specific interface. The <c>IP_MULTICAST_IF</c> socket option would be used to set the interface to send
            IPv4 multicast packets to the multicast group. The most common scenario would be a multicast application that listens and sends
            on the same interface for a multicast group. Multiple sockets might be used by a multicast application with one socket for
            listening and one or more sockets for sending.
            </para>
            <para>
            On the Microsoft Windows Software Development Kit (SDK) released for Windows Vista and later, the organization of header files
            has changed and the <c>ip_msfilter</c> structure is defined in the Ws2ipdef.h header file which is automatically included in the
            Ws2tcpip.h header file. The Ws2ipdef.h header files should never be used directly.
            </para>
            <para>
            <c>Note</c> The <c>IP_MSFILTER</c> and <c>PIP_MSFILTER</c> derived structures are only defined on the Windows SDK released with
            Windows Vista and later. The <c>ip_msfilter</c> structure should be used on earlier versions of the Windows SDK.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IP_MSFILTER.imsf_multiaddr">
            <summary>The IPv4 address of the multicast group.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IP_MSFILTER.imsf_interface">
            <summary>
            <para>
            The local IPv4 address of the interface or the interface index on which the multicast group should be filtered. This value
            is in network byte order. If this member specifies an IPv4 address of 0.0.0.0, the default IPv4 multicast interface is used.
            </para>
            <para>To use an interface index of 1 would be the same as an IP address of 0.0.0.1.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IP_MSFILTER.imsf_fmode">
            <summary>
            <para>
            The multicast filter mode to be used. This parameter can be either MCAST_INCLUDE (value of 0) to include particular
            multicast sources, or MCAST_EXCLUDE (value of 1) to exclude traffic from specified sources.
            </para>
            <para>On Windows Server 2003 and Windows XP, these values are defined in the Ws2tcpip.h header file.</para>
            <para>
            On Windows Vistaand later, these values are defined as enumeration values in the MULTICAST_MODE_TYPE enumeration defined in
            the Ws2ipdef.h header file.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IP_MSFILTER.imsf_numsrc">
            <summary>The number of sources in the <c>imsf_slist</c> member.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.IP_MSFILTER.imsf_slist">
            <summary>An array of in_addr structures that specify the IPv4 multicast source addresses to include or exclude.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6">
            <summary>The SOCKADDR_IN6 structure specifies a transport address and port for the AF_INET6 address family.</summary>
            <remarks>
            <para>
            All of the data in the SOCKADDR_IN6 structure, except for the address family, must be specified in network-byte-order (big-endian).
            </para>
            <para>
            The size of the SOCKADDR_IN6 structure is too large to fit in the memory space that is provided by a SOCKADDR structure. For a
            structure that is guaranteed to be large enough to contain a transport address for all possible address families, see SOCKADDR_STORAGEa&gt;.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6.sin6_family">
            <summary>The address family for the transport address. This member should always be set to AF_INET6.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6.sin6_port">
            <summary>A transport protocol port number.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6.sin6_flowinfo">
            <summary>The IPv6 flow information.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6.sin6_addr">
            <summary>An IN6_ADDR structure that contains an IPv6 transport address.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6.sin6_scope_id">
            <summary>A ULONG representation of the IPv6 scope identifier that is defined in the <c>sin6_scope_struct</c> member.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6.#ctor(System.Byte[],System.UInt32,System.UInt16)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6"/> struct.</summary>
            <param name="addr">A byte array that contains an IPv6 transport address.</param>
            <param name="scope_id">
            A ULONG representation of the IPv6 scope identifier that is defined in the <c>sin6_scope_struct</c> member.
            </param>
            <param name="port">A transport protocol port number.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6.#ctor(Vanara.PInvoke.Ws2_32.IN6_ADDR,System.UInt32,System.UInt16)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6"/> struct.</summary>
            <param name="addr">An IN6_ADDR structure that contains an IPv6 transport address.</param>
            <param name="scope_id">
            A ULONG representation of the IPv6 scope identifier that is defined in the <c>sin6_scope_struct</c> member.
            </param>
            <param name="port">A transport protocol port number.</param>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6.op_Implicit(Vanara.PInvoke.Ws2_32.IN6_ADDR)~Vanara.PInvoke.Ws2_32.SOCKADDR_IN6">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.IN6_ADDR"/> to <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6"/>.</summary>
            <param name="addr">The address.</param>
            <returns>The resulting <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6"/> instance from the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6_PAIR">
            <summary>
            The <c>SOCKADDR_IN6_PAIR</c> structure contains pointers to a pair of IP addresses that represent a source and destination
            address pair.
            </summary>
            <remarks>
            <para>The <c>SOCKADDR_IN6_PAIR</c> structure is defined on Windows Vista and later.</para>
            <para>
            Any IPv4 addresses in the <c>SOCKADDR_IN6_PAIR</c> structure must be represented in the IPv4-mapped IPv6 address format which
            enables an IPv6 only application to communicate with an IPv4 node. For more information on the IPv4-mapped IPv6 address format,
            see Dual-Stack Sockets.
            </para>
            <para>The <c>SOCKADDR_IN6_PAIR</c> structure is used by the CreateSortedAddressPairs function.</para>
            <para>Note that the Ws2ipdef.h header file is automatically included in Ws2tcpip.h header file, and should never be used directly.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6_PAIR._SourceAddress">
            <summary>The source address</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6_PAIR._DestinationAddress">
            <summary>The destination address</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6_PAIR.SourceAddress">
            <summary>
            A pointer to an IP source address represented as a SOCKADDR_IN6 structure. The address family is in host byte order and the
            IPv6 address, port, flow information, and zone ID are in network byte order.
            </summary>
            <value>The source address.</value>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6_PAIR.DestinationAddress">
            <summary>
            A pointer to an IP source address represented as a SOCKADDR_IN6 structure. The address family is in host byte order and the
            IPv6 address, port, flow information, and zone ID are in network byte order.
            </summary>
            <value>The destination address.</value>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6_PAIR.op_Implicit(Vanara.PInvoke.Ws2_32.SOCKADDR_IN6_PAIR)~Vanara.PInvoke.Ws2_32.SOCKADDR_IN6_PAIR_NATIVE">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6_PAIR"/> to <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6_PAIR_NATIVE"/>.</summary>
            <param name="unmgd">The unmanaged value.</param>
            <returns>The resulting <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6_PAIR_NATIVE"/> instance from the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6_PAIR.ToString">
            <summary>Converts to string.</summary>
            <returns>A <see cref="T:System.String"/> that represents this instance.</returns>
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6_PAIR_NATIVE">
            <summary>
            The <c>SOCKADDR_IN6_PAIR</c> structure contains pointers to a pair of IP addresses that represent a source and destination
            address pair.
            </summary>
            <remarks>
            <para>The <c>SOCKADDR_IN6_PAIR</c> structure is defined on Windows Vista and later.</para>
            <para>
            Any IPv4 addresses in the <c>SOCKADDR_IN6_PAIR</c> structure must be represented in the IPv4-mapped IPv6 address format which
            enables an IPv6 only application to communicate with an IPv4 node. For more information on the IPv4-mapped IPv6 address format,
            see Dual-Stack Sockets.
            </para>
            <para>The <c>SOCKADDR_IN6_PAIR</c> structure is used by the CreateSortedAddressPairs function.</para>
            <para>Note that the Ws2ipdef.h header file is automatically included in Ws2tcpip.h header file, and should never be used directly.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6_PAIR_NATIVE.SourceAddress">
            <summary>
            A pointer to an IP source address represented as a SOCKADDR_IN6 structure. The address family is in host byte order and the
            IPv6 address, port, flow information, and zone ID are in network byte order.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6_PAIR_NATIVE.DestinationAddress">
            <summary>
            A pointer to an IP source address represented as a SOCKADDR_IN6 structure. The address family is in host byte order and the
            IPv6 address, port, flow information, and zone ID are in network byte order.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6_PAIR_NATIVE.ToString">
            <summary>Converts to string.</summary>
            <returns>A <see cref="T:System.String"/> that represents this instance.</returns>
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SOCKADDR_INET">
            <summary>The <c>SOCKADDR_INET</c> union contains an IPv4, an IPv6 address, or an address family.</summary>
            <remarks>
            <para>The <c>SOCKADDR_INET</c> union is defined on Windows Vista and later.</para>
            <para>
            The <c>SOCKADDR_INET</c> union is a convenience structure for accessing an IPv4 address, an IPv6 address, or the IP address
            family without having to cast the sockaddr structure.
            </para>
            <para>The <c>SOCKADDR_INET</c> union is the data type of the <c>Prefix</c> member in the IP_ADDRESS_PREFIX structure</para>
            <para>Note that the Ws2ipdef.h header file is automatically included in Ws2tcpip.h header file, and should never be used directly.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKADDR_INET.Ipv4">
            <summary>
            An IPv4 address represented as a SOCKADDR_IN structure containing the address family and the IPv4 address. The address
            family is in host byte order and the IPv4 address is in network byte order.
            <para>
            On the Windows SDK released for Windows Vista and later, the organization of header files has changed and the SOCKADDR_IN
            structure is defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in
            Winsock2.h, and should never be used directly.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKADDR_INET.Ipv6">
            <summary>
            An IPv6 address represented as a SOCKADDR_IN6 structure containing the address family and the IPv6 address. The address
            family is in host byte order and the IPv6 address is in network byte order.
            <para>
            On the Windows SDK released for Windows Vista and later, the organization of header files has changed and the SOCKADDR_IN6
            structure is defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in
            Winsock2.h, and should never be used directly.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.SOCKADDR_INET.si_family">
            <summary>
            The address family.
            <para>
            Possible values for the address family are listed in the Ws2def.h header file. Note that the values for the AF_ address
            family and PF_ protocol family constants are identical (for example, AF_INET and PF_INET), so either constant can be
            used.The Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly.
            </para>
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR_INET.Equals(Vanara.PInvoke.Ws2_32.SOCKADDR_INET)">
            <summary>Specifies whether this instance is equal to the specified object.</summary>
            <param name="other">The object to test for equality.</param>
            <returns><see langword="true"/> if <paramref name="other"/> is equal to this instance.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR_INET.Equals(Vanara.PInvoke.Ws2_32.SOCKADDR_IN)">
            <summary>Specifies whether this instance is equal to the specified object.</summary>
            <param name="other">The object to test for equality.</param>
            <returns><see langword="true"/> if <paramref name="other"/> is equal to this instance.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR_INET.Equals(Vanara.PInvoke.Ws2_32.SOCKADDR_IN6)">
            <summary>Specifies whether this instance is equal to the specified object.</summary>
            <param name="other">The object to test for equality.</param>
            <returns><see langword="true"/> if <paramref name="other"/> is equal to this instance.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR_INET.op_Implicit(Vanara.PInvoke.Ws2_32.SOCKADDR_IN)~Vanara.PInvoke.Ws2_32.SOCKADDR_INET">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN"/> to <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_INET"/>.</summary>
            <param name="address">The address.</param>
            <returns>The resulting <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_INET"/> instance from the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR_INET.op_Implicit(Vanara.PInvoke.Ws2_32.SOCKADDR_IN6)~Vanara.PInvoke.Ws2_32.SOCKADDR_INET">
            <summary>Performs an implicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_IN6"/> to <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_INET"/>.</summary>
            <param name="address">The address.</param>
            <returns>The resulting <see cref="T:Vanara.PInvoke.Ws2_32.SOCKADDR_INET"/> instance from the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SOCKADDR_INET.ToString">
            <summary>Converts to string.</summary>
            <returns>A <see cref="T:System.String"/> that represents this instance.</returns>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.LPNSPV2CLEANUP">
            <summary>
            The <c>NSPv2Cleanup</c> function notifies a namespace service provider version-2 (NSPv2) provider that a client session has terminated.
            </summary>
            <param name="lpProviderId">A pointer to the GUID of the namespace provider to be notified.</param>
            <param name="pvClientSessionArg">A pointer to the client session.</param>
            <returns>
            <para>
            The function should return <c>NO_ERROR</c> (zero) if the routine succeeds. It should return <c>SOCKET_ERROR</c> (that is, 1) if
            the routine fails and it must set the appropriate error code using WSASetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There is not enough memory available to perform this operation.</term>
            </item>
            <item>
            <term>WSAEACCES</term>
            <term>The calling routine does not have sufficient privileges to initialize the service.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more parameters were invalid, or missing, for this provider.</term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>The operation is not supported. This error is returned if the namespace provider does not implement this function.</term>
            </item>
            <item>
            <term>WSASERVICE_NOT_FOUND</term>
            <term>Service is unknown. The service cannot be found in the specified namespace.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>NSPv2Cleanup</c> function is used as part of the namespace service provider version-2 (NSPv2) architecture available on
            Windows Vista and later.
            </para>
            <para>
            On Windows Vista and Windows Server 2008, the <c>NSPv2Cleanup</c> function can only be used for operations on NS_EMAIL namespace providers.
            </para>
            <para>
            The NSPv2Startup function is called each time a new client process begins using namespace provider. Providers may use the client
            session argument pointed to by the ppvClientSessionArg parameter to store information about this session. If a value was
            specified for the client session argument in the call to the <c>NSPv2Startup</c> function, then this same client session
            argument can be passed in the pvClientSessionArg parameter to the <c>NSPv2Cleanup</c> function to notify namespace provider that
            the client session has terminated.
            </para>
            <para>
            The <c>NSPv2Cleanup</c> function is called when an application is finished using a Windows Sockets namespace service provider.
            The <c>NSPv2Cleanup</c> allows the namespace provider to free any of namespace provider resources that were allocated for the
            client session.
            </para>
            <para>
            The NSPv2Startup function must be called successfully before calling the <c>NSPv2Cleanup</c> function. It is permissible to make
            more than one <c>NSPv2Startup</c> call. However, for each <c>NSPv2Startup</c> call, a corresponding <c>NSPv2Cleanup</c> call
            must also be issued. Only the final <c>NSPv2Cleanup</c> for the service provider does the actual cleanup; the preceding calls
            decrement an internal reference count in the service provider.
            </para>
            <para>
            The NSPv2Startup, NSPv2ClientSessionRundown, and <c>NSPv2Cleanup</c> functions are optional, dependent on the requirements of
            the NSPv2 provider.
            </para>
            <para>
            If the <c>NSPv2Cleanup</c> function isn't implemented, then calls to that function should be intercepted by a stub function that
            returns WSAEOPNOTSUPP. The NSPv2 function pointer to the unimplemented <c>NSPv2Cleanup</c> function in the NSPV2_ROUTINE
            structure should point be to the stub function.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.LPNSPV2CLIENTSESSIONRUNDOWN">
            <summary>
            The <c>NSPv2ClientSessionRundown</c> function notifies a namespace service provider version-2 (NSPv2) provider that the client
            session is terminating.
            </summary>
            <param name="lpProviderId">A pointer to the GUID of the specific namespace provider to notify.</param>
            <param name="pvClientSessionArg">A pointer to the client session that is terminating.</param>
            <returns>
            <para>
            The function should return <c>NO_ERROR</c> (zero) if the routine succeeds. It should return <c>SOCKET_ERROR</c> (that is, 1) if
            the routine fails and it must set the appropriate error code using WSASetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There is not enough memory available to perform this operation.</term>
            </item>
            <item>
            <term>WSAEACCES</term>
            <term>The calling routine does not have sufficient privileges to install the service.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more parameters were invalid, or missing, for this provider.</term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>
            The operation is not supported. This error is returned if the namespace provider does not implement this function. This error
            can also be returned if the specified dwControlCode is an unrecognized command.
            </term>
            </item>
            <item>
            <term>WSASERVICE_NOT_FOUND</term>
            <term>Service is unknown. The service cannot be found in the specified namespace.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>NSPv2ClientSessionRundown</c> function is used as part of the namespace service provider version-2 (NSPv2) architecture
            available on Windows Vista and later.
            </para>
            <para>
            On Windows Vista and Windows Server 2008, the <c>NSPv2ClientSessionRundown</c> function can only be used for operations on
            NS_EMAIL namespace providers.
            </para>
            <para>
            The NSPv2Startup function is called each time a new client process begins using namespace provider. Providers may use the client
            session argument pointed to by the ppvClientSessionArg parameter to store information about this session. If a value was
            specified for the client session argument in the call to the <c>NSPv2Startup</c> function, then this same client session
            argument is passed in the pvClientSessionArg parameter to the <c>NSPv2ClientSessionRundown</c> function.
            </para>
            <para>
            The NSPv2Startup, <c>NSPv2ClientSessionRundown</c>, and NSPv2Cleanup functions are optional, dependent on the requirements of
            the NSPv2 provider.
            </para>
            <para>
            If the <c>NSPv2ClientSessionRundown</c> function isn't implemented, then calls to that function should be intercepted by a stub
            function that returns WSAEOPNOTSUPP. The NSPv2 function pointer to the unimplemented <c>NSPv2ClientSessionRundown</c> function
            in the NSPV2_ROUTINE structure should point be to the stub function.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.LPNSPV2LOOKUPSERVICEBEGIN">
            <summary>
            The NSPv2LookupServiceBegin function initiates a client query of a namespace version-2 service provider that is constrained by
            the information contained within a WSAQUERYSET2 structure.
            </summary>
            <param name="lpProviderId">A pointer to the identifier for the namespace service provider to query.</param>
            <param name="lpqsRestrictions">A pointer to the search criteria. See Remarks.</param>
            <param name="dwControlFlags">
            <para>
            A set of flags that affect the search. This parameter can be a combination of the following values defined in the Winsock2.h
            header file.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>LUP_DEEP 0x0001</term>
            <term>Queries down the hierarchy of a provider as opposed to just the first level.</term>
            </item>
            <item>
            <term>LUP_CONTAINERS 0x0002</term>
            <term>Returns containers only.</term>
            </item>
            <item>
            <term>LUP_NOCONTAINERS 0x0004</term>
            <term>Returns no containers.</term>
            </item>
            <item>
            <term>LUP_NEAREST 0x0008</term>
            <term>If possible, returns results in the order of distance. The measure of distance is provider specific.</term>
            </item>
            <item>
            <term>LUP_RETURN_NAME 0x0010</term>
            <term>Retrieves the name as **lpszServiceInstanceName**.</term>
            </item>
            <item>
            <term>LUP_RETURN_TYPE 0x0020</term>
            <term>Retrieves the type as **lpServiceClassId**.</term>
            </item>
            <item>
            <term>LUP_RETURN_VERSION 0x0040</term>
            <term>Retrieves the version as **lpVersion**.</term>
            </item>
            <item>
            <term>LUP_RETURN_COMMENT 0x0080</term>
            <term>Retrieves the comment as **lpszComment**.</term>
            </item>
            <item>
            <term>LUP_RETURN_ADDR 0x0100</term>
            <term>Retrieves the addresses as **lpcsaBuffer**.</term>
            </item>
            <item>
            <term>LUP_RETURN_BLOB 0x0200</term>
            <term>Retrieves the private data as **lpBlob**.</term>
            </item>
            <item>
            <term>LUP_RETURN_ALIASES 0x0400</term>
            <term>
            Any available alias information is to be returned in successive calls to NSPv2LookupServiceNextEx, and each alias returned will
            have the **RESULT_IS_ALIAS** flag set.
            </term>
            </item>
            <item>
            <term>LUP_RETURN_QUERY_STRING 0x0800</term>
            <term>Retrieves the query string as **lpszQueryString**.</term>
            </item>
            <item>
            <term>LUP_RETURN_ALL 0x0ff0</term>
            <term>Retrieves information including the name, type, version, comment, address, blob, aliases, and query string.</term>
            </item>
            <item>
            <term>LUP_FLUSHCACHE 0x1000</term>
            <term>If the provider has cached information, ignore the cache and query the namespace itself.</term>
            </item>
            <item>
            <term>LUP_FLUSHPREVIOUS 0x2000</term>
            <term>
            Used as a value for the dwControlFlags parameter in NSPv2LookupServiceNextEx. Setting this flag instructs the provider to
            discard the last result set, which was too large for the supplied buffer, and move on to the next result set.
            </term>
            </item>
            <item>
            <term>LUP_NON_AUTHORITATIVE 0x4000</term>
            <term>Indicates that the namespace provider should included non-authoritative results for names.</term>
            </item>
            <item>
            <term>LUP_RES_RESERVICE 0x8000</term>
            <term>
            Indicates whether prime response is in the remote or local part of CSADDR_INFO structure. The other part must be usable in
            either case. This option applies only to service instance requests.
            </term>
            </item>
            <item>
            <term>LUP_SECURE 0x8000</term>
            <term>Indicates that the namespace provider should use a secure query. This option only applies to name query requests.</term>
            </item>
            <item>
            <term>LUP_RETURN_PREFERRED_NAMES 0x10000</term>
            <term>Indicates that the namespace provider should return only preferred names.</term>
            </item>
            <item>
            <term>LUP_ADDRCONFIG 0x100000</term>
            <term>Indicates that the namespace provider should return the address configuration.</term>
            </item>
            <item>
            <term>LUP_DUAL_ADDR 0x200000</term>
            <term>
            Indicates that the namespace provider should return the dual addresses. This option only applies to dual-mode sockets (IPv6 and
            IPv4 mapped addresses).
            </term>
            </item>
            <item>
            <term>LUP_DISABLE_IDN_ENCODING 0x800000</term>
            <term>
            Indicates that the namespace provider should disable automatic International Domain Names encoding. This value is supported on
            Windows 8 and Windows Server 2012
            </term>
            </item>
            </list>
            </param>
            <param name="lpvClientSessionArg">A pointer to the client session.</param>
            <param name="lphLookup">
            A pointer to the handle to be used in subsequent calls to NSPv2LookupServiceNextEx in order to retrieve the results set.
            </param>
            <returns>
            <para>
            The function should return <c>NO_ERROR</c> (zero) if the routine succeeds. It should return <c>SOCKET_ERROR</c> (that is, 1) if
            the routine fails and it must set the appropriate error code using WSASetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more parameters were invalid, or missing, for this provider.</term>
            </item>
            <item>
            <term>WSANO_DATA</term>
            <term>The name was found in the database, but it does not have the correct associated data that is resolved for.</term>
            </item>
            <item>
            <term>WSASERVICE_NOT_FOUND</term>
            <term>The service is unknown. The service cannot be found in the specified namespace.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There is not enough memory available to perform this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The NSPv2LookupServiceBegin function is used as part of the namespace service provider version-2 (NSPv2) architecture available
            on Windows Vista and later.
            </para>
            <para>
            On Windows Vista and Windows Server 2008, the NSPv2LookupServiceBegin function can only be used for operations on NS_EMAIL
            namespace providers.
            </para>
            <para>
            The NSPv2LookupServiceBegin function only returns a handle, which should be used by subsequent calls to NSPv2LookupServiceNextEx
            to get the actual results. Because this operation cannot be canceled, it should be implemented to execute quickly. While it is
            acceptable to initiate a network query, this function should not require a response to return successfully.
            </para>
            <para>
            The NSPv2Startup function is called each time a new client process begins using namespace provider. Providers may use the client
            session argument pointed to by the ppvClientSessionArg parameter to store information about this session. If a value was
            specified for the client session argument in the call to the <c>NSPv2Startup</c> function, then this same client session
            argument is passed in the lpvClientSessionArg parameter to the NSPv2LookupServiceBegin function.
            </para>
            <para>
            If <c>LUP_CONTAINERS</c> is specified in a call, avoid all other restriction values. If any are supplied, the name service
            provider must decide if it can support this restriction over the containers. If not, it should return an error.
            </para>
            <para>
            Some name service providers may have other means of finding containers. For example, containers can all be of some well-known
            type, or of a set of well-known types, and therefore a query restriction could be created for finding them. No matter what other
            means the name service provider has for locating containers, <c>LUP_CONTAINERS</c> and <c>LUP_NOCONTAINERS</c> take precedence.
            Therefore, if a query restriction is given that includes containers, specifying <c>LUP_NOCONTAINERS</c> will prevent the
            container items from being returned. Similarly, no matter what the query restriction, if <c>LUP_CONTAINERS</c> is given, only
            containers should be returned. If a namespace does not support containers and <c>LUP_CONTAINERS</c> is specified, it should
            return WSANO_DATA.
            </para>
            <para>The preferred method of obtaining the containers within another container, is the call:</para>
            <para>
            followed by the requisite number of NSPv2LookupServiceNextEx calls. This will return all containers contained immediately within
            the starting context; that is, it is not a deep query. With this, one can map the address space structure by walking the
            hierarchy, perhaps enumerating the content of selected containers. Subsequent uses of NSPv2LookupServiceBegin use the containers
            returned from a previous call.
            </para>
            <para>Forming Queries</para>
            <para>
            The WSAQUERYSET2 structure is used as an input parameter to NSPv2LookupServiceBegin to qualify the query. The following table
            lists **WSAQUERYSET2** member names and describes how the **WSAQUERYSET2** is used to construct a query. Members labeled as
            optional and dependent on the requirements of the NSPv2 provider may be supplied as a **NULL** pointer when unused as a search
            criteria by the namespace provider. For more information, see Query-Related Data Structures.
            </para>
            <list type="table">
            <listheader>
            <term>WSAQUERYSET2 member name</term>
            <term>Query interpretation</term>
            </listheader>
            <item>
            <term>**dwSize**</term>
            <term>Will be set to sizeof(WSAQUERYSET2). This is a versioning mechanism.</term>
            </item>
            <item>
            <term>**lpszServiceInstanceName**</term>
            <term>
            A string that contains the service name. The semantics for wildcarding within the string are not defined, but can be supported
            by certain namespace providers. This member is optional, dependent on the requirements of the NSPv2 service provider.
            </term>
            </item>
            <item>
            <term>**lpVersion**</term>
            <term>
            The desired version number that provides version comparison semantics (that is, version must match exactly, or version must be
            not less than the value supplied). This member is optional, dependent on the requirements of the NSPv2 service provider.
            </term>
            </item>
            <item>
            <term>**lpszComment**</term>
            <term>This member is ignored for queries.</term>
            </item>
            <item>
            <term>**dwNameSpace**</term>
            <term>The identifier of a single namespace in which to constrain the search, or **NS_ALL** to include all namespaces.</term>
            </item>
            <item>
            <term>**lpNSProviderId**</term>
            <term>
            The GUID of a specific namespace provider that limits the query to this provider only. This member is optional, dependent on the
            requirements of the NSPv2 service provider.
            </term>
            </item>
            <item>
            <term>**lpszContext**</term>
            <term>
            The starting point of the query in a hierarchical namespace. This member is optional, dependent on the requirements of the NSPv2
            service provider.
            </term>
            </item>
            <item>
            <term>**dwNumberOfProtocols**</term>
            <term>The size, in bytes, of the number of entries in the protocol constraint array. This member can be zero.</term>
            </item>
            <item>
            <term>**lpafpProtocols**</term>
            <term>
            An array of AFPROTOCOLS structures. Only services that use these protocols will be returned. It is permissable for the value
            **AF_UNSPEC** to appear as a protocol family value, signifying a wildcard. Namespace providers may supply information about any
            service that uses the corresponding protocol, regardless of address family. This member is optional, dependent on the
            requirements of the NSPv2 service provider.
            </term>
            </item>
            <item>
            <term>**lpszQueryString**</term>
            <term>
            Some namespaces (such as whois++) support rich SQL-like queries contained in a simple text string. This parameter is used to
            specify that string.This member is optional, dependent on the requirements of the NSPv2 service provider.
            </term>
            </item>
            <item>
            <term>**dwNumberOfCsAddrs**</term>
            <term>This member is ignored for queries.</term>
            </item>
            <item>
            <term>**lpcsaBuffer**</term>
            <term>This member is ignored for queries.</term>
            </item>
            <item>
            <term>**dwOutputFlags**</term>
            <term>This member is ignored for queries.</term>
            </item>
            <item>
            <term>**lpBlob**</term>
            <term>A pointer to a provider-specific entity. This member is optional, dependent on the requirements of the NSPv2 service provider.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.LPNSPV2LOOKUPSERVICEEND">
            <summary>
            The <c>NSPv2LookupServiceEnd</c> function is called to free the handle after previous calls to NSPv2LookupServiceBegin and NSPv2LookupServiceNextEx.
            </summary>
            <param name="hLookup">The handle obtained previously by a call to NSPv2LookupServiceBegin.</param>
            <returns>
            <para>
            The function should return <c>NO_ERROR</c> (zero) if the routine succeeds. It should return <c>SOCKET_ERROR</c> (that is, 1) if
            the routine fails and it must set the appropriate error code using WSASetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSA_INVALID_HANDLE</term>
            <term>The handle is not valid.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There is not enough memory available to perform this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>NSPv2LookupServiceEnd</c> function is used as part of the namespace service provider version-2 (NSPv2) architecture
            available on Windows Vista and later.
            </para>
            <para>
            On Windows Vista and Windows Server 2008, the <c>NSPv2LookupServiceEnd</c> function can only be used for operations on NS_EMAIL
            namespace providers.
            </para>
            <para>
            It is possible to receive an NSPv2LookupServiceBegin function call on another thread while processing an
            NSPv2LookupServiceNextEx. This indicates that the client has canceled the request and the provider should close the handle and
            return from the <c>NSPv2LookupServiceNextEx</c> function call as well, setting the last error to <c>WSA_E_CANCELLED</c>.
            </para>
            <para>
            In Windows Sockets 2, conflicting error codes are defined for <c>WSAECANCELLED</c> and WSA_E_CANCELLED. The error code
            <c>WSAECANCELLED</c> will be removed in a future version and only WSA_E_CANCELLED will remain. Namespace Providers should use
            the WSA_E_CANCELLED error code to maintain compatibility with the widest possible range of applications.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.LPNSPV2LOOKUPSERVICENEXTEX">
            <summary>
            The <c>NSPv2LookupServiceNextEx</c> function is called after obtaining a handle from a previous call to NSPv2LookupServiceBegin
            in order to retrieve the requested information from a namespace version-2 service provider.
            </summary>
            <param name="hAsyncCall">A handle returned from the previous call to NSPv2LookupServiceBegin used for asynchronous calls.</param>
            <param name="hLookup">A handle returned from the previous call to NSPv2LookupServiceBegin.</param>
            <param name="dwControlFlags">
            The flags used to control the next operation. Currently, only <c>LUP_FLUSHPREVIOUS</c> is defined as a means to handle a result
            set that is too large. If an application cannot supply a large enough buffer, setting <c>LUP_FLUSHPREVIOUS</c> instructs the
            provider to discard the last result set, which was too large, and move to the next set for this call.
            </param>
            <param name="lpdwBufferLength">
            The size, in bytes, on input, that is contained in the buffer pointed to by lpqsResults. On output, if the function fails and
            the error is WSAEFAULT, then it contains the minimum size, in bytes to pass for the lpqsResults to retrieve the record.
            </param>
            <param name="lpqsResults">A pointer to a memory block that will contain, on return, one result set in a WSAQUERYSET2 structure.</param>
            <returns>
            <para>
            The function should return <c>NO_ERROR</c> (zero) if the routine succeeds. It should return <c>SOCKET_ERROR</c> (that is, 1) if
            the routine fails and it must set the appropriate error code using WSASetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSA_E_CANCELLED</term>
            <term>
            A call to NSPv2LookupServiceEnd was made while this call was still processing. The call has been canceled. The data in the
            lpqsResults buffer is undefined. In Windows Sockets 2, conflicting error codes are defined for WSAECANCELLED (10103) and
            WSA_E_CANCELLED (10111).The error code WSAECANCELLED will be removed in a future version and only WSA_E_CANCELLED will remain.
            Namespace providers should use the WSA_E_CANCELLED error code to maintain compatibility with the widest possible range of applications.
            </term>
            </item>
            <item>
            <term>WSA_E_NO_MORE</term>
            <term>
            There is no more data available. In Windows Sockets 2, conflicting error codes are defined for WSAENOMORE (10102) and
            WSA_E_NO_MORE (10110).The error code WSAENOMORE will be removed in a future version and only WSA_E_NO_MORE will remain.
            Namespace providers should use the WSA_E_NO_MORE error code to maintain compatibility with the widest possible range of applications.
            </term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The lpqsResults buffer was too small to contain a WSAQUERYSET set.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more parameters are invalid, or missing, for this provider.</term>
            </item>
            <item>
            <term>WSA_INVALID_HANDLE</term>
            <term>The specified lookup handle is invalid.</term>
            </item>
            <item>
            <term>WSANO_DATA</term>
            <term>The name was found in the database, but no data, matching the given restrictions, was located.</term>
            </item>
            <item>
            <term>WSASERVICE_NOT_FOUND</term>
            <term>The service is unknown. The service cannot be found in the specified namespace.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There is not enough memory available to perform this operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>NSPv2LookupServiceNextEx</c> function is used as part of the namespace service provider version-2 (NSPv2) architecture
            available on Windows Vista and later.
            </para>
            <para>
            On Windows Vista and Windows Server 2008, the <c>NSPv2LookupServiceNextEx</c> function can only be used for operations on
            NS_EMAIL namespace providers.
            </para>
            <para>
            The provider will pass a WSAQUERYSET2 structure in the lpqsResults buffer. The client should call the
            <c>NSPv2LookupServiceNextEx</c> function until it returns <c>WSA_E_NOMORE</c>, indicating that all the <c>WSAQUERYSET2</c>
            structures have been returned.
            </para>
            <para>
            The dwControlFlags specified in this function and the ones specified at the time of NSPv2LookupServiceBegin are handled as
            "restrictions" for the purpose of combination. The restrictions are combined between the ones at <c>NSPv2LookupServiceBegin</c>
            time and the ones at <c>NSPv2LookupServiceNextEx</c> time. Therefore, the flags at <c>NSPv2LookupServiceNextEx</c> can never
            increase the amount of data returned beyond what was requested at <c>NSPv2LookupServiceBegin</c>, although it is not an error to
            specify more or less flags. The flags specified at a given <c>NSPv2LookupServiceNextEx</c> apply only to that call.
            </para>
            <para>
            The dwControlFlags <c>LUP_FLUSHPREVIOUS</c> and <c>LUP_RES_SERVICE</c> are exceptions to the combined restrictions rule (because
            they are behavior flags instead of "restriction" flags). If either flag is used in <c>NSPv2LookupServiceNextEx</c>, they have
            their defined effect regardless of the setting of the same flags at NSPv2LookupServiceBegin.
            </para>
            <para>
            For example, if <c>LUP_RETURN_VERSION</c> is specified at NSPv2LookupServiceBegin, the service provider retrieves records
            including the version. If <c>LUP_RETURN_VERSION</c> is not specified at <c>NSPv2LookupServiceNextEx</c>, the returned
            information does not include the version, even though it was available. No error is generated.
            </para>
            <para>
            Also for example, if <c>LUP_RETURN_BLOB</c> is not specified at NSPv2LookupServiceBegin, but is specified at
            <c>NSPv2LookupServiceNextEx</c>, the returned information does not include the private data. No error is generated.
            </para>
            <para>
            The <c>NSPv2LookupServiceNextEx</c> function is typically called at least twice. The first time to get the size of the needed
            buffer to receive the WSAQUERYSET2 pointed to by the lpqsResults parameter, and the second time to get the actual query result
            set. On the first call, the NSPv2 provider should return the size necessary for the <c>WSAQUERYSET2</c> results.
            </para>
            <para>
            The WSAQUERYSET2 structure pointed to by the lpqsResults parameter that is returned is only useful in the same process context,
            since several of the members in the <c>WSAQUERYSET2</c> structure contains pointers to the actual data returned. If the query
            result needs to be passed to another process (using RPC, for example), then it will be necessary to serialize and marshal the
            data returned in the <c>WSAQUERYSET2</c> structure pointed to by the lpqsResults parameter including the data pointed to by
            members in the <c>WSAQUERYSET2</c> structure. The data needs to be serialized in a form that can be passed across process
            boundaries. Just passing a copy of the <c>WSAQUERYSET2</c> structure is insufficient, since only pointers to data will be passed
            and the actual data will be unavailable to other processes.
            </para>
            <para>Query Results</para>
            <para>
            The following table lists WSAQUERYSET2 and describes how query results are represented in the **WSAQUERYSET2** structure. For
            more information, see Query-Related Data Structures.
            </para>
            <list type="table">
            <listheader>
            <term>WSAQUERYSET2 member name</term>
            <term>Result interpretation</term>
            </listheader>
            <item>
            <term>**dwSize**</term>
            <term>The size, in bytes, of WSAQUERYSET2 structure. This is used as a versioning mechanism.</term>
            </item>
            <item>
            <term>**lpszServiceInstanceName**</term>
            <term>A string that contains the service name.</term>
            </item>
            <item>
            <term>**lpVersion**</term>
            <term>References version number of the particular service instance.</term>
            </item>
            <item>
            <term>**lpszComment**</term>
            <term>
            A comment string supplied by service instance. This member is optional, dependent on the requirements of the NSPv2 service provider.
            </term>
            </item>
            <item>
            <term>**dwNameSpace**</term>
            <term>The namespace identifier in which the name or service instance was found.</term>
            </item>
            <item>
            <term>**lpNSProviderId**</term>
            <term>The specific namespace provider that supplied this query result.</term>
            </item>
            <item>
            <term>**lpszContext**</term>
            <term>The context point in a hierarchical namespace at which the service is located.</term>
            </item>
            <item>
            <term>**dwNumberOfProtocols**</term>
            <term>This member is undefined for results.</term>
            </item>
            <item>
            <term>**lpafpProtocols**</term>
            <term>This member is undefined for results. All needed protocol information is in the CSADDR_INFO structures.</term>
            </item>
            <item>
            <term>**lpszQueryString**</term>
            <term>
            When dwControlFlags includes **LUP_RETURN_QUERY_STRING**, this member returns the unparsed remainder of the
            **lpszServiceInstanceName** specified in the original query. For example, in a namespace that identifies services by
            hierarchical names that specify a host name and a file path within that host, the address returned might be the host address and
            the unparsed remainder might be the file path. If the **lpszServiceInstanceName** is fully parsed and
            **LUP_RETURN_QUERY_STRING** is used, this member is null or points to a zero-length string.
            </term>
            </item>
            <item>
            <term>**dwNumberOfCsAddrs**</term>
            <term>The number of elements in the array of CSADDR_INFO structures.</term>
            </item>
            <item>
            <term>**lpcsaBuffer**</term>
            <term>A pointer to an array of CSADDR_INFO structures, with one complete transport address contained within each element.</term>
            </item>
            <item>
            <term>**dwOutputFlags**</term>
            <term>The **RESULT_IS_ALIAS** flag indicates this is an alias result.</term>
            </item>
            <item>
            <term>**lpBlob**</term>
            <term>A pointer to a provider-specific entity. This member is optional, dependent on the requirements of the NSPv2 service provider.</term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.LPNSPV2SETSERVICEEX">
            <summary>
            The <c>NSPv2SetServiceEx</c> function registers or deregisters a name or service instance within a namespace of a namespace
            service provider version-2 (NSPv2) provider.
            </summary>
            <param name="hAsyncCall">A handle returned from the previous call to NSPv2LookupServiceBegin used for asynchronous calls.</param>
            <param name="lpProviderId">A pointer to the GUID of the specific namespace provider in which the name or service is registered.</param>
            <param name="lpqsRegInfo">The property information to be updated upon registration.</param>
            <param name="essOperation">
            <para>The type of operation requested.</para>
            <para>
            This parameter can be one of the values from the <c>WSAESETSERVICEOP</c> enumeration type defined in the Winsock2.h header file.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>RNRSERVICE_REGISTER 0</term>
            <term>
            Register the service. For the Service Advertising Protocol (SAP) namespace used within a NetWare environment, this means sending
            a periodic broadcast. This is an NOP for the Domain Name System (DNS) namespace. For persistent data stores this means updating
            the address information.
            </term>
            </item>
            <item>
            <term>RNRSERVICE_DEREGISTER 1</term>
            <term>
            Deregister the service. For the SAP namespace, this means stop sending the periodic broadcast. This is a NOP for the DNS
            namespace. For persistent data stores this means deleting address information.
            </term>
            </item>
            <item>
            <term>RNRSERVICE_DELETE 2</term>
            <term>
            Delete the service from dynamic name and persistent spaces. For services represented by multiple CSADDR_INFO structures (using
            the SERVICE_MULTIPLE flag), only the supplied address will be deleted, and this must match exactly the corresponding
            **CSADDR_INFO** structure supplied when the service was registered.
            </term>
            </item>
            </list>
            </param>
            <param name="dwControlFlags">
            <para>A set of flags that controls the operation requested.</para>
            <para>The possible values for this parameter are defined in the Winsock2.h header file.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SERVICE_MULTIPLE 0x00000001</term>
            <term>
            Control the scope of the operation. When this value is set, the action is only performed on the given address set. A register
            operation does not invalidate existing addresses and a deregister operation only invalidates the given set of addresses. When
            this value is absent, service addresses are managed as a group. A register or deregister invalidates all existing addresses
            before adding the given address set.
            </term>
            </item>
            </list>
            </param>
            <param name="lpvClientSessionArg">A pointer to the client session.</param>
            <returns>
            <para>
            The function should return <c>NO_ERROR</c> (zero) if the routine succeeds. It should return <c>SOCKET_ERROR</c> (that is, 1) if
            the routine fails and it must set the appropriate error code using WSASetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There is not enough memory available to perform this operation.</term>
            </item>
            <item>
            <term>WSAEACCES</term>
            <term>The calling routine does not have sufficient privileges to install the service.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more parameters were invalid, or missing, for this provider.</term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>
            The operation is not supported. This error is returned if the namespace provider does not implement this function. This error
            can also be returned if the specified dwControlCode is an unrecognized command.
            </term>
            </item>
            <item>
            <term>WSASERVICE_NOT_FOUND</term>
            <term>Service is unknown. The service cannot be found in the specified namespace.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>NSPv2SetServiceEx</c> function is used as part of the namespace service provider version-2 (NSPv2) architecture available
            on Windows Vista and later.
            </para>
            <para>
            On Windows Vista and Windows Server 2008, the <c>NSPv2SetServiceEx</c> function can only be used for operations on NS_EMAIL
            namespace providers.
            </para>
            <para>
            The NSPv2Startup function is called each time a new client process begins using namespace provider. Providers may use the client
            session argument pointed to by the ppvClientSessionArg parameter to store information about this session. This client session
            argument can be passed to the <c>NSPv2SetServiceEx</c> function in the lpvClientSessionArg parameter.
            </para>
            <para>
            The <c>NSPv2SetServiceEx</c> function is optional, dependent on the requirements of the NSPv2 provider. If the
            <c>NSPv2SetServiceEx</c> function isn't implemented, then the NSPv2 function pointer can be to a stub function that always
            returns <c>NO_ERROR</c>.
            </para>
            <para>The following table lists the possible combination of values for essOperation and dwControlFlags parameters.</para>
            <list type="table">
            <listheader>
            <term>essOperation</term>
            <term>dwControlFlags</term>
            <term>Service already exists</term>
            <term>Service does not exist</term>
            </listheader>
            <item>
            <term>**RNRSERVICE_REGISTER**</term>
            <term>None</term>
            <term>Overwrites the object. Uses only addresses specified. Object is REGISTERED.</term>
            <term>Creates a new object. Uses only addresses specified. Object is REGISTERED.</term>
            </item>
            <item>
            <term>**RNRSERVICE_REGISTER**</term>
            <term>**SERVICE_MULTIPLE**</term>
            <term>Updates object. Adds new addresses to existing set. Object is REGISTERED.</term>
            <term>Creates a new object. Uses all addresses specified. Object is REGISTERED.</term>
            </item>
            <item>
            <term>**RNRSERVICE_DEREGISTER**</term>
            <term>None</term>
            <term>Removes all addresses, but does not remove object from namespace. Object is DEREGISTERED.</term>
            <term>WSASERVICE_NOT_FOUND</term>
            </item>
            <item>
            <term>**RNRSERVICE_DEREGISTER**</term>
            <term>**SERVICE_MULTIPLE**</term>
            <term>
            Updates object. Removes only addresses that are specified. Only mark object as DEREGISTERED if no addresses are present. Does
            not remove from the namespace.
            </term>
            <term>WSASERVICE_NOT_FOUND</term>
            </item>
            <item>
            <term>**RNRSERVICE_DELETE**</term>
            <term>None</term>
            <term>Removes object from the namespace.</term>
            <term>WSASERVICE_NOT_FOUND</term>
            </item>
            <item>
            <term>**RNRSERVICE_DELETE**</term>
            <term>**SERVICE_MULTIPLE**</term>
            <term>Removes only addresses that are specified. Only removes object from the namespace if no addresses remain.</term>
            <term>WSASERVICE_NOT_FOUND</term>
            </item>
            </list>
            <para>
            When the dwControlFlags parameter is set to <c>SERVICE_MULTIPLE</c>, this enables an application to manage its addresses
            independently. This is useful when the application must manage its protocols individually or when the service resides on more
            than one computer. For example, when a service uses more than one protocol, one listening socket may abort, but the other
            sockets remain operational. In this example, the service could deregister the aborted address without affecting the other addresses.
            </para>
            <para>
            When using <c>SERVICE_MULTIPLE</c>, an application must not let old addresses remain in the object. This can happen if the
            application aborts without issuing a <c>RNRSERVICE_DEREGISTER</c> request. When a service registers, it should store its
            addresses. On its next call, the service should explicitly deregister these old addresses before registering new addresses.
            </para>
            <para>
            If the <c>NSPv2SetServiceEx</c> function isn't implemented, then calls to that function should be intercepted by a stub function
            that returns WSAEOPNOTSUPP. The NSPv2 function pointer to the unimplemented <c>NSPv2SetServiceEx</c> function in the
            NSPV2_ROUTINE structure should point be to the stub function.
            </para>
            <para>Service Properties</para>
            <para>
            The following table lists WSAQUERYSET2 member names and describes how service property data is represented. Members labeled as
            optional and dependent on the requirements of the NSPv2 provider may be supplied as a **NULL** pointer when unused by the
            namespace provider.
            </para>
            <list type="table">
            <listheader>
            <term>WSAQUERYSET2 member name</term>
            <term>Service property description</term>
            </listheader>
            <item>
            <term>**dwSize**</term>
            <term>Set to the sizeof(WSAQUERYSET2). This is a versioning mechanism.</term>
            </item>
            <item>
            <term>**lpszServiceInstanceName**</term>
            <term>A string that contains the service instance name.</term>
            </item>
            <item>
            <term>**lpVersion**</term>
            <term>The service instance version number. This member is optional, dependent on the requirements of the NSPv2 service provider.</term>
            </item>
            <item>
            <term>**lpszComment**</term>
            <term>A comment string. This member is optional, dependent on the requirements of the NSPv2 service provider.</term>
            </item>
            <item>
            <term>**dwNameSpace**</term>
            <term>The namespace identifier. This member is optional, dependent on the requirements of the NSPv2 service provider.</term>
            </item>
            <item>
            <term>**lpNSProviderId**</term>
            <term>
            The provider identifier. Note that the namespace provider identifier is also passed in the lpProviderId parameter. This member
            is optional, dependent on the requirements of the NSPv2 service provider.
            </term>
            </item>
            <item>
            <term>**lpszContext**</term>
            <term>
            The starting point of the query in a hierarchical namespace. This member is optional, dependent on the requirements of the NSPv2
            service provider.
            </term>
            </item>
            <item>
            <term>**dwNumberOfProtocols**</term>
            <term>
            The size, in bytes, of the number of entries in the protocol constraint array. This member can be zero.This member is optional,
            dependent on the requirements of the NSPv2 service provider.
            </term>
            </item>
            <item>
            <term>**lpafpProtocols**</term>
            <term>An array of AFPROTOCOLS structures. This member is optional, dependent on the requirements of the NSPv2 service provider.</term>
            </item>
            <item>
            <term>**lpszQueryString**</term>
            <term>
            Some namespaces (such as whois++) support rich SQL-like queries contained in a simple text string. This parameter is used to
            specify that string.This member is optional, dependent on the requirements of the NSPv2 service provider.
            </term>
            </item>
            <item>
            <term>**dwNumberOfCsAddrs**</term>
            <term>The number of elements in the array of CSADDR_INFO structures referenced by lpcsaBuffer.</term>
            </item>
            <item>
            <term>**lpcsaBuffer**</term>
            <term>A pointer to an array of CSADDR_INFO structures that contain the address or addresses that the service is listening on.</term>
            </item>
            <item>
            <term>**dwOutputFlags**</term>
            <term>This member is optional, dependent on the requirements of the NSPv2 service provider.</term>
            </item>
            <item>
            <term>**lpBlob**</term>
            <term>
            A pointer to a provider-specific entity. This member is required for the NS_EMAIL namespace. This member is optional, dependent
            on the requirements for other NSPv2 service providers.
            </term>
            </item>
            </list>
            <para>
            **Note** It is acceptable for the **iProtocol** member of the CSADDR_INFO structure to contain the manifest constant
              **IPROTOCOL_ANY**, indicating a wildcard value. The namespace provider should substitute an acceptable value for the given
              address family and socket type.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.LPNSPV2STARTUP">
            <summary>
            The <c>NSPv2Startup</c> function notifies a namespace service provider version-2 (NSPv2) provider that a new client process is
            to begin using the provider.
            </summary>
            <param name="lpProviderId">A pointer to the GUID of the specific namespace provider to notify.</param>
            <param name="ppvClientSessionArg"/>
            <returns>
            <para>
            The function should return <c>NO_ERROR</c> (zero) if the routine succeeds. It should return <c>SOCKET_ERROR</c> (that is, 1) if
            the routine fails and it must set the appropriate error code using WSASetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There is not enough memory available to perform this operation.</term>
            </item>
            <item>
            <term>WSAEACCES</term>
            <term>The calling routine does not have sufficient privileges to initialize the service.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more parameters were invalid, or missing, for this provider.</term>
            </item>
            <item>
            <term>WSAEOPNOTSUPP</term>
            <term>The operation is not supported. This error is returned if the namespace provider does not implement this function.</term>
            </item>
            <item>
            <term>WSASERVICE_NOT_FOUND</term>
            <term>Service is unknown. The service cannot be found in the specified namespace.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>NSPv2Startup</c> function is used as part of the namespace service provider version-2 (NSPv2) architecture available on
            Windows Vista and later.
            </para>
            <para>
            On Windows Vista and Windows Server 2008, the <c>NSPv2Startup</c> function can only be used for operations on NS_EMAIL namespace providers.
            </para>
            <para>
            The <c>NSPv2Startup</c> function is called each time a new client process begins using namespace provider. Providers may use the
            client session argument pointed to by the ppvClientSessionArg parameter to store information about this session. The value in
            the ppvClientSessionArg parameter will be passed to subsequent NSPv2 function calls in the same session. The client session
            argument may <c>NULL</c>, if the namespace provider does not require this information.
            </para>
            <para>
            The <c>NSPv2Startup</c> function is called when a new client session initializes. The <c>NSPv2Startup</c> and NSPv2Cleanup
            functions must be called as pairs.
            </para>
            <para>
            The <c>NSPv2Startup</c> function must be called successfully before calling the NSPv2Cleanup function. It is permissible to make
            more than one <c>NSPv2Startup</c> call. However, for each <c>NSPv2Startup</c> call, a corresponding <c>NSPv2Cleanup</c> call
            must also be issued. Only the final <c>NSPv2Cleanup</c> for the service provider does the actual cleanup; the preceding calls
            decrement an internal reference count in the namespace service provider.
            </para>
            <para>
            The <c>NSPv2Startup</c>, NSPv2ClientSessionRundown, and NSPv2Cleanup functions are optional, dependent on the requirements of
            the NSPv2 provider.
            </para>
            <para>
            If the <c>NSPv2Startup</c> function isn't implemented, then calls to that function should be intercepted by a stub function that
            returns WSAEOPNOTSUPP. The NSPv2 function pointer to the unimplemented <c>NSPv2Startup</c> function in the NSPV2_ROUTINE
            structure should point be to the stub function.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WSC_PROVIDER_INFO_TYPE">
            <summary>The WSC_PROVIDER_AUDIT_INFO structure is not currently used.</summary>
            <remarks>The WSC_PROVIDER_AUDIT_INFO structure is not currently used.</remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSC_PROVIDER_INFO_TYPE.ProviderInfoLspCategories">
            <summary>
            The LSP category information for a protocol entry in a layered protocol. The information class should point to a DWORD value
            containing the appropriate LSP category flags implemented by LSP.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSC_PROVIDER_INFO_TYPE.ProviderInfoAudit">
            <summary>
            The LSP class information for audit information for the LSP entry. The information class should point to a
            WSC_PROVIDER_AUDIT_INFO structure containing an audit record for the LSP.
            </summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WPUCompleteOverlappedRequest(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.WSAOVERLAPPED@,System.UInt32,System.UInt32,System.Int32@)">
            <summary>
            The <c>WPUCompleteOverlappedRequest</c> function performs overlapped I/O completion notification for overlapped I/O operations.
            </summary>
            <param name="s">The service provider socket created by WPUCreateSocketHandle.</param>
            <param name="lpOverlapped">
            A pointer to a WSAOVERLAPPED structure associated with the overlapped I/O operation whose completion is to be notified.
            </param>
            <param name="dwError">The completion status of the overlapped I/O operation whose completion is to be notified.</param>
            <param name="cbTransferred">
            The number of bytes transferred to or from client buffers (the direction of the transfer depends on the send or receive nature
            of the overlapped I/O operation whose completion is to be notified).
            </param>
            <param name="lpErrno">A pointer to the error code resulting from execution of this function.</param>
            <returns>
            <para>
            If no error occurs, <c>WPUCompleteOverlappedRequest</c> returns zero and notifies completion of the overlapped I/O operation
            according to the mechanism selected by the client (signals an event found in the WSAOVERLAPPED structure referenced by
            lpOverlapped and/or queues a completion status report to the completion port associated with the socket if a completion port is
            associated). Otherwise, <c>WPUCompleteOverlappedRequest</c> returns SOCKET_ERROR, and a specific error code is available in lpErrno.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEINVAL</term>
            <term>The socket passed in the s parameter is not a socket created by WPUCreateSocketHandle.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WPUCompleteOverlappedRequest</c> function performs overlapped I/O completion notification for overlapped I/O operations
            where the client-specified completion mechanism is something other than user modeasynchronous procedure call (APC). This
            function can only be used for socket handles created by WPUCreateSocketHandle.
            </para>
            <para>
            **Note** This function is different from other functions with the "WPU" prefix in that it is not accessed through the upcall
            table. Instead, it is exported directly by Ws2_32.dll. Service providers that need to call this function should link with
            WS2_32.lib or use appropriate operating system functions such as LoadLibrary and GetProcAddress to retrieve the function pointer.
            </para>
            <para>
            The function **WPUCompleteOverlappedRequest** is used by service providers that do not implement Installable File System (IFS)
            functionality directly for the socket handles they expose. It performs completion notification for any overlapped I/O request
            for which the specified completion notification is other than a user-mode APC. **WPUCompleteOverlappedRequest** is supported
            only for the socket handles created by WPUCreateSocketHandle and not for sockets created by a service provider directly.
            </para>
            <para>
            If the client selects a user-mode APC as the notification method, the service provider should use WPUQueueApc or another
            appropriate operating system function to perform the completion notification. If user-mode APC is not selected by the client, a
            service provider that does not implement IFS functionality directly cannot determine whether or not the client has associated a
            completion port with the socket handle. Thus, it cannot determine whether the completion notification method should be queuing a
            completion status record to a completion port or signaling an event found in the WSAOVERLAPPED structure. The Windows Socket 2
            architecture keeps track of any completion port association with a socket created by WPUCreateSocketHandle and can make a
            correct decision between completion port-based notification or event-based notification.
            </para>
            <para>
            When <c>WPUCompleteOverlappedRequest</c> queues a completion indication, it sets the <c>InternalHigh</c> member of the
            WSAOVERLAPPED structure to the count of bytes transferred. Then, it sets the <c>Internal</c> member to some OS-dependent value
            other than the special value WSS_OPERATION_IN_PROGRESS. There may be some slight delay after <c>WPUCompleteOverlappedRequest</c>
            returns before these values appear, since processing may occur asynchronously. However, the <c>InternalHigh</c> value (byte
            count) is guaranteed to be set by the time <c>Internal</c> is set.
            </para>
            <para>
            <c>WPUCompleteOverlappedRequest</c> works as stated (performs the completion notification as requested by the client) whether or
            not the socket handle has been associated with a completion port.
            </para>
            <para><c>Interaction with WSPGetOverlappedResult</c></para>
            <para>
            The behavior of <c>WPUCompleteOverlappedRequest</c> places some constraints on how a service provider implements
            WSPGetOverlappedResult since only the <c>Offset</c> and <c>OffsetHigh</c> members of the WSAOVERLAPPED structure are exclusively
            controlled by the service provider, yet three values (byte count, flags, and error) must be retrieved from the structure by
            <c>WSPGetOverlappedResult</c>. A service provider may accomplish this any way it chooses as long as it interacts with the
            behavior of <c>WPUCompleteOverlappedRequest</c> properly. However, a typical implementation is as follows:
            </para>
            <list type="bullet">
            <item>
            <term>At the start of overlapped processing, the service provider sets <c>Internal</c> to WSS_OPERATION_IN_PROGRESS.</term>
            </item>
            <item>
            <term>
            When the I/O operation has been completed, the provider sets <c>OffsetHigh</c> to the Windows Socket 2 error code resulting from
            the operation, sets <c>Offset</c> to the flags resulting from the I/O operation, and calls <c>WPUCompleteOverlappedRequest</c>,
            passing the transfer byte count as one of the parameters. <c>WPUCompleteOverlappedRequest</c> eventually sets
            <c>InternalHigh</c> to the transfer byte count, then sets <c>Internal</c> to a value other than WSS_OPERATION_IN_PROGRESS.
            </term>
            </item>
            <item>
            <term>
            When WSPGetOverlappedResult is called, the service provider checks <c>Internal</c>. If it is WSS_OPERATION_IN_PROGRESS, the
            provider waits on the event handle in the <c>hEvent</c> member or returns an error, based on the setting of the FWAIT flag of
            <c>WSPGetOverlappedResult</c>. If not in progress, or after completion of waiting, the provider returns the values from
            <c>InternalHigh</c>, <c>OffsetHigh</c>, and <c>Offset</c> as the transfer count, operation result error code, and flags respectively.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAAdvertiseProvider(System.Guid@,Vanara.PInvoke.Ws2_32.NSPV2_ROUTINE@)">
            <summary>
            The <c>WSAAdvertiseProvider</c> function makes a specific namespace version-2 provider available for all eligible clients.
            </summary>
            <param name="puuidProviderId">A pointer to the provider ID of the namespace provider to be advertised.</param>
            <param name="pNSPv2Routine">
            A pointer to a <c>NSPV2_ROUTINE</c> structure with the namespace service provider version-2 entry points supported by the provider.
            </param>
            <returns>
            <para>If no error occurs, WSAProviderCompleteAsyncCall returns zero.</para>
            <para>
            If the function fails, the return value is SOCKET_ERROR. To get extended error information, call WSAGetLastError, which returns
            one of the following extended error values.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There was insufficient memory to perform the operation.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>An internal error occurred.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            A parameter was not valid. This error is returned if the puuidProviderId or pNSPv2Routine parameters were **NULL**. This error
            is also returned if the NSPv2LookupServiceBegin, NSPv2LookupServiceNextEx, or NSPv2LookupServiceEnd members of the NSPV2_ROUTINE
            structure pointed to by the pNSPv2Routine parameter are NULL. A namespace version-2 provider must at least support name
            resolution which this minimum set of functions.
            </term>
            </item>
            <item>
            <term>WSAEINVALIDPROVIDER</term>
            <term>The namespace provider could not be found for the specified puuidProviderId parameter.</term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>
            The Ws2_32.dll has not been initialized. The application must first call WSAStartup before calling any Windows Sockets functions.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAAdvertiseProvider</c> function is used as part of the namespace service provider version-2 (NSPv2) architecture
            available on Windows Vista and later.
            </para>
            <para>
            On Windows Vista and Windows Server 2008, the <c>WSAAdvertiseProvider</c> function can only be used for operations on NS_EMAIL
            namespace providers.
            </para>
            <para>
            The <c>WSAAdvertiseProvider</c> function advertises an instance of a NSPv2 provider for clients to find. If the instance to be
            advertised is an instance of an application-type provider (a namespace provider where the <c>dwProvideType</c> member of the
            NAPI_PROVIDER_INSTALLATION_BLOB structure is <c>ProviderType_Application</c>), the advertised provider instance will be visible
            to all the client processes running under the same user and in the same session as the caller of <c>WSAAdvertiseProvider</c>.
            </para>
            <para>
            In general, NSPv2 providers are implemented in processes other than the calling applications. NSPv2 providers are not activated
            as a result of client activity. Each provider hosting application decides when to make a specific provider available or
            unavailable by calling the <c>WSAAdvertiseProvider</c> and WSAUnadvertiseProvider functions. The client activity only results in
            attempts to contact the provider, when available (when the namespace provider is advertised).
            </para>
            <para>
            The <c>WSAAdvertiseProvider</c> function is called by any application that wants to make a specific provider available for all
            eligible clients (currently all the applications running with the same credentials as the hosting application, and in the same
            user session).
            </para>
            <para>
            A process can implement and advertise multiple providers at the same time. Windows Sockets will manage the namespace providers
            by dispatching calls to the correct one. It will also hide RPC interface details and translates cross-process calls into
            in-process calls. So that the NSPv2 provider has only to implement a table of entry point functions similar to the NSP_ROUTINE
            structure used by an NSPv1 provider. A NSPv2 provider does not have to worry about RPC specific requirements (data marshalling
            and serialization, for example).
            </para>
            <para>
            The <c>WSAAdvertiseProvider</c> caller passes a pointer to an NSPV2_ROUTINE structure in the pNSPv2Routine parameter with the
            NSPv2 entry points supported by the provider.
            </para>
            <para>The WSAUnadvertiseProvider function makes a specific namespace provider no longer available for clients.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAProviderCompleteAsyncCall(Vanara.PInvoke.HANDLE,System.Int32)">
            <summary>
            The <c>WSAProviderCompleteAsyncCall</c> function notifies a client when an asynchronous call to a namespace version-2 provider
            is completed.
            </summary>
            <param name="hAsyncCall">
            The handle passed to the asynchronous call being completed. This handle is passed by the client to the namespace version-2
            provider in the asynchronous function call.
            </param>
            <param name="iRetCode">The return code for the asynchronous call to the namespace version-2 provider.</param>
            <returns>
            <para>If no error occurs, <c>WSAProviderCompleteAsyncCall</c> returns zero.</para>
            <para>
            If the function fails, the return value is SOCKET_ERROR. To get extended error information, call WSAGetLastError, which returns
            one of the following extended error values.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There was insufficient memory to perform the operation.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>An internal error occurred.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>A parameter was not valid. This error is returned if the hAsyncCall parameter was **NULL**.</term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>
            The Ws2_32.dll has not been initialized. The application must first call WSAStartup before calling any Windows Sockets functions.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAProviderCompleteAsyncCall</c> function is used as part of the namespace service provider version-2 (NSPv2)
            architecture available on Windows Vista and later.
            </para>
            <para>
            On Windows Vista and Windows Server 2008, the WSAUnadvertiseProvider function can only be used for operations on NS_EMAIL
            namespace providers. Asynchronous calls to NSPv2 providers are not supported on Windows Vista and Windows Server 2008. So the
            <c>WSAProviderCompleteAsyncCall</c> is not currently applicable. This function is planned for use in later versions of Windows
            when asynchronous calls to namespace providers are supported.
            </para>
            <para>
            In general, NSPv2 providers are implemented in processes other than the calling applications. NSPv2 providers are not activated
            as result of client activity. Each provider hosting application decides when to make a specific provider available or
            unavailable by calling the WSAAdvertiseProvider and WSAUnadvertiseProvider functions. The client activity only results in
            attempts to contact the provider, when available (when the namespace provider is advertised).
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAUnadvertiseProvider(System.Guid@)">
            <summary>
            The <c>WSAUnadvertiseProvider</c> function makes a specific namespace version-2 provider no longer available for clients.
            </summary>
            <param name="puuidProviderId">A pointer to the provider ID of the namespace provider.</param>
            <returns>
            <para>
            If no error occurs, <c>WSAUnadvertiseProvider</c> returns zero. Otherwise, it returns <c>SOCKET_ERROR</c>, and a specific error
            code is available by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEINVAL</term>
            <term>A parameter was not valid. This error is returned if the puuidProviderId parameter was **NULL**.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSAUnadvertiseProvider</c> function is used as part of the namespace service provider version-2 (NSPv2) architecture
            available on Windows Vista and later.
            </para>
            <para>
            On Windows Vista and Windows Server 2008, the <c>WSAUnadvertiseProvider</c> function can only be used for operations on NS_EMAIL
            namespace providers.
            </para>
            <para>
            In general, NSPv2 providers are implemented in processes other than the calling applications. NSPv2 providers are not activated
            as result of client activity. Each provider hosting application decides when to make a specific provider available or
            unavailable by calling the WSAAdvertiseProvider and <c>WSAUnadvertiseProvider</c> functions. The client activity only results in
            attempts to contact the provider, when available (when the namespace provider is advertised).
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCDeinstallProvider(System.Guid@,System.Int32@)">
            <summary>
            The <c>WSCDeinstallProvider</c> function removes the specified transport provider from the system configuration database.
            </summary>
            <param name="lpProviderId">
            A pointer to a globally unique identifier (GUID) for the provider. This value is stored within each WSAProtocol_Info structure.
            </param>
            <param name="lpErrno">A pointer to the error code if the function fails.</param>
            <returns>
            <para>
            If no error occurs, <c>WSCDeinstallProvider</c> returns zero. Otherwise, it returns <c>SOCKET_ERROR</c>, and a specific error
            code is available in lpErrno.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEINVAL</term>
            <term>The lpProviderId parameter does not specify a valid provider.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The lpErrno parameter is not in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the
            administrative privileges required to write to the Windows Sockets registry, or a failure occurred when opening a catalog entry.
            </term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>
            Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSCDeinstallProvider</c> function removes the common Windows Sockets 2 configuration information for the specified
            provider. After this routine completes successfully, the configuration information stored in the registry will be changed.
            However, any Ws2_32.dll instances currently in memory will not be able to recognize this change.
            </para>
            <para>
            On success, <c>WSCDeinstallProvider</c> will attempt to alert all interested applications that have registered for notification
            of the change by calling WSAProviderConfigChange.
            </para>
            <para>
            The <c>WSCDeinstallProvider</c> function can only be called by a user logged on as a member of the Administrators group. If
            <c>WSCDeinstallProvider</c> is called by a user that is not a member of the Administrators group, the function call will fail
            and <c>WSANO_RECOVERY</c> is returned in the lpErrno parameter.
            </para>
            <para>
            For computers running Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC).
            If an application that contains this function is executed by a user logged on as a member of the Administrators group other than
            the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a
            <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If the application on Windows Vista or Windows Server 2008
            lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must
            then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
            </para>
            <para>
            The caller of this function must remove any additional files or service providerspecific configuration information that is
            needed to completely uninstall the service provider.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCDeinstallProvider32(System.Guid@,System.Int32@)">
            <summary>
            The <c>WSCDeinstallProvider32</c> function removes the specified 32-bit transport provider from the system configuration database.
            </summary>
            <param name="lpProviderId">
            A pointer to a globally unique identifier (GUID) for the provider. This value is stored within each WSAProtocol_Info structure.
            </param>
            <param name="lpErrno">A pointer to the error code if the function fails.</param>
            <returns>
            <para>
            If no error occurs, <c>WSCDeinstallProvider32</c> returns zero. Otherwise, it returns <c>SOCKET_ERROR</c>, and a specific error
            code is available in lpErrno.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEINVAL</term>
            <term>The lpProviderId parameter does not specify a valid provider.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The lpErrno parameter is not in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the
            administrative privileges required to write to the Windows Sockets registry, or a failure occurred when opening a catalog entry.
            </term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>
            Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>WSCDeinstallProvider32</c> is a strictly 32-bit version of WSCDeinstallProvider. On a 64-bit computer, all calls not
            specifically 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that
            execute on a 64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve
            compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
            </para>
            <para>
            The <c>WSCDeinstallProvider32</c> function removes the common Windows Sockets 2 configuration information for the specified
            32-bit provider. After this routine completes successfully, the configuration information stored in the registry will be
            changed. However, any Ws2_32.dll instances currently in memory will not be able to recognize this change.
            </para>
            <para>
            On success, <c>WSCDeinstallProvider32</c> will attempt to alert all interested applications that have registered for
            notification of the change by calling WSAProviderConfigChange.
            </para>
            <para>
            The <c>WSCDeinstallProvider32</c> function can only be called by a user logged on as a member of the Administrators group. If
            <c>WSCDeinstallProvider32</c> is called by a user that is not a member of the Administrators group, the function call will fail
            and <c>WSANO_RECOVERY</c> is returned in the lpErrno parameter.
            </para>
            <para>
            For computers running Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC).
            If an application that contains this function is executed by a user logged on as a member of the Administrators group other than
            the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a
            <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If the application on Windows Vista or Windows Server 2008
            lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must
            then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
            </para>
            <para>
            The caller of this function must remove any additional files or service providerspecific configuration information that is
            needed to completely uninstall the service provider.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCEnableNSProvider(System.Guid@,System.Boolean)">
            <summary>
            The <c>WSCEnableNSProvider</c> function changes the state of a given namespace provider. It is intended to give the end-user the
            ability to change the state of the namespace providers.
            </summary>
            <param name="lpProviderId">A pointer to a globally unique identifier (GUID) for the namespace provider.</param>
            <param name="fEnable">
            A Boolean value that, if <c>TRUE</c>, the provider is set to the active state. If <c>FALSE</c>, the provider is disabled and
            will not be available for query operations or service registration.
            </param>
            <returns>
            <para>
            If no error occurs, the <c>WSCEnableNSProvider</c> function returns <c>NO_ERROR</c> (zero). Otherwise, it returns
            <c>SOCKET_ERROR</c> if the function fails, and you must retrieve the appropriate error code using the WSAGetLastError function.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>The lpProviderId parameter points to memory that is not in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>The specified namespace provider identifier is invalid.</term>
            </item>
            <item>
            <term>WSASYSCALLFAILURE</term>
            <term>A system call that should never fail has failed.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>
            Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSCEnableNSProvider</c> function is intended to be used to change the state of the namespace providers. An independent
            software vendor (ISV) should not normally de-activate another ISV namespace provider in order to activate its own. The choice
            should be left to the user.
            </para>
            <para>
            The <c>WSCEnableNSProvider</c> function does not affect applications that are already running. Newly installed namespace
            providers will not be visible to applications nor will the changes in a namespace provider's activation state be visible.
            Applications launched after the call to <c>WSCEnableNSProvider</c> will see the changes.
            </para>
            <para>
            The <c>WSCEnableNSProvider</c> function can only be called by a user logged on as a member of the Administrators group. If
            <c>WSCEnableNSProvider</c> is called by a user that is not a member of the Administrators group, the function call will fail.
            </para>
            <para>
            For computers running Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC).
            If an application that contains this function is executed by a user logged on as a member of the Administrators group other than
            the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a
            <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If the application on Windows Vista or Windows Server 2008
            lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must
            then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCEnableNSProvider32(System.Guid@,System.Boolean)">
            <summary>
            The <c>WSCEnableNSProvider32</c> function enables or disables a specified 32-bit namespace provider. It is intended to give the
            end-user the ability to change the state of the namespace providers.
            </summary>
            <param name="lpProviderId">A pointer to a globally unique identifier (GUID) for the namespace provider.</param>
            <param name="fEnable">
            A Boolean value that, if <c>TRUE</c>, the namespace provider is set to the active state. If <c>FALSE</c>, the namespace provider
            is disabled and will not be available for query operations or service registration.
            </param>
            <returns>
            <para>
            If no error occurs, the <c>WSCEnableNSProvider32</c> function returns <c>NO_ERROR</c> (zero). Otherwise, it returns
            <c>SOCKET_ERROR</c> if the function fails, and you must retrieve the appropriate error code using the WSAGetLastError function.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>The lpProviderId parameter points to memory that is not in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>The specified namespace provider identifier is invalid.</term>
            </item>
            <item>
            <term>WSASYSCALLFAILURE</term>
            <term>A system call that should never fail has failed.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>
            Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSCEnableNSProvider32</c> function is intended to be used to change the state of the namespace providers. An independent
            software vendor (ISV) should not normally de-activate another ISV's namespace provider in order to activate its own. The choice
            should be left to the user.
            </para>
            <para>
            <c>WSCEnableNSProvider32</c> is a strictly 32-bit version of WSCEnableNSProvider. On a 64-bit computer, all calls not
            specifically 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that
            execute on a 64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve
            compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
            </para>
            <para>
            The namespace configuration functions do not affect applications that are already running. Newly installed namespace providers
            will not be visible to applications nor will the changes in a namespace provider's activation state. Applications launched after
            the call to <c>WSCEnableNSProvider32</c> will see the changes.
            </para>
            <para>
            The <c>WSCEnableNSProvider32</c> function can only be called by a user logged on as a member of the Administrators group. If
            <c>WSCEnableNSProvider32</c> is called by a user that is not a member of the Administrators group, the function call will fail.
            </para>
            <para>
            For computers running on Windows Vista or Windows Server 2008, this function can also fail because of user account control
            (UAC). If an application that contains this function is executed by a user logged on as a member of the Administrators group
            other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a
            <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If the application on Windows Vista or Windows Server 2008
            lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must
            then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCEnumNameSpaceProviders32(System.UInt32@,System.IntPtr)">
            <summary>The <c>WSCEnumNameSpaceProviders32</c> function returns information on available 32-bit namespace providers.</summary>
            <param name="lpdwBufferLength">
            On input, the number of bytes contained in the buffer pointed to by lpnspBuffer. On output (if the function fails, and the error
            is WSAEFAULT), the minimum number of bytes to allocate for the lpnspBuffer buffer to allow it to retrieve all the requested
            information. The buffer passed to <c>WSCEnumNameSpaceProviders32</c> must be sufficient to hold all of the namespace information.
            </param>
            <param name="lpnspBuffer">
            A buffer that is filled with WSANAMESPACE_INFOW structures. The returned structures are located consecutively at the head of the
            buffer. Variable sized information referenced by pointers in the structures point to locations within the buffer located between
            the end of the fixed sized structures and the end of the buffer. The number of structures filled in is the return value of <c>WSCEnumNameSpaceProviders32</c>.
            </param>
            <returns>
            <para>
            The <c>WSCEnumNameSpaceProviders32</c> function returns the number of WSANAMESPACE_INFOW structures copied into lpnspBuffer.
            Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The lpnspBuffer parameter was a **NULL** pointer or the buffer length, lpdwBufferLength, was too small to receive all the
            relevant WSANAMESPACE_INFOW structures and associated information. When this error is returned, the buffer length required is
            returned in the lpdwBufferLength parameter.
            </term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>
            The WS2_32.DLL has not been initialized. The application must first call WSAStartup before calling any Windows Sockets functions.
            </term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There was insufficient memory to perform the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>WSCEnumNameSpaceProviders32</c> is a strictly 32-bit version of WSAEnumNameSpaceProviders. On a 64-bit computer, all calls
            not specifically 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes
            that execute on a 64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and
            preserve compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
            </para>
            <para>
            The 32-bit SPI function is equivalent to the native API function (WSAEnumNameSpaceProviders) because there is no concept of a
            "hidden" namespace provider.
            </para>
            <para>The <c>WSCEnumNameSpaceProviders32</c> function is a Unicode only function and returns WSANAMESPACE_INFOEXW structures.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCEnumNameSpaceProvidersEx32(System.UInt32@,System.IntPtr)">
            <summary>The <c>WSCEnumNameSpaceProvidersEx32</c> function retrieves information on available 32-bit namespace providers.</summary>
            <param name="lpdwBufferLength">
            On input, the number of bytes contained in the buffer pointed to by lpnspBuffer. On output (if the function fails, and the error
            is WSAEFAULT), the minimum number of bytes to allocate for the lpnspBuffer buffer to allow it to retrieve all the requested
            information. The buffer passed to <c>WSCEnumNameSpaceProvidersEx32</c> must be sufficient to hold all of the namespace information.
            </param>
            <param name="lpnspBuffer">
            A buffer that is filled with WSANAMESPACE_INFOEXW structures. The returned structures are located consecutively at the head of
            the buffer. Variable sized information referenced by pointers in the structures point to locations within the buffer located
            between the end of the fixed sized structures and the end of the buffer. The number of structures filled in is the return value
            of <c>WSCEnumNameSpaceProvidersEx32</c>.
            </param>
            <returns>
            <para>
            The <c>WSCEnumNameSpaceProvidersEx32</c> function returns the number of WSANAMESPACE_INFOEXW structures copied into lpnspBuffer.
            Otherwise, the value SOCKET_ERROR is returned, and a specific error number can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The buffer length was too small to receive all the relevant WSANAMESPACE_INFOEXW structures and associated information or the
            lpnspBuffer parameter was a **NULL** pointer. When this error is returned, the buffer length required is returned in the
            lpdwBufferLength parameter.
            </term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>
            The WS2_32.DLL has not been initialized. The application must first call WSAStartup before calling any Windows Sockets functions.
            </term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There was insufficient memory to perform the operation.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>WSCEnumNameSpaceProvidersEx32</c> is a strictly 32-bit version of WSAEnumNameSpaceProvidersEx. On a 64-bit computer, all
            calls not specifically 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog.
            Processes that execute on a 64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog
            and preserve compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
            </para>
            <para>
            Currently, the only namespace included with Windows that uses information in the <c>ProviderSpecific</c> member of the
            WSANAMESPACE_INFOEXW structure are namespace providers for the NS_EMAIL namespace. The format of the <c>ProviderSpecific</c>
            member for an NS_EMAIL namespace provider is a NAPI_PROVIDER_INSTALLATION_BLOB structure.
            </para>
            <para>
            The 32-bit SPI function is equivalent to the native API function (WSAEnumNameSpaceProvidersEx) because there is no concept of a
            "hidden" namespace provider.
            </para>
            <para>
            The provider-specific data blob associated with namespace entry passed in the lpProviderInfo parameter to the
            WSCInstallNameSpaceEx32 function can be queried using <c>WSCEnumNameSpaceProvidersEx32</c> function.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCEnumProtocols(System.Int32[],System.IntPtr,System.UInt32@,System.Int32@)">
            <summary>The <c>WSCEnumProtocols</c> function retrieves information about available transport protocols.</summary>
            <param name="lpiProtocols">
            A <c>NULL</c>-terminated array of iProtocol values. This parameter is optional; if lpiProtocols is NULL, information on all
            available protocols is returned. Otherwise, information is retrieved only for those protocols listed in the array.
            </param>
            <param name="lpProtocolBuffer">A pointer to a buffer that is filled with WSAPROTOCOL_INFOW structures.</param>
            <param name="lpdwBufferLength">
            On input, size of the lpProtocolBuffer buffer passed to <c>WSCEnumProtocols</c>, in bytes. On output, the minimum buffer size,
            in bytes, that can be passed to <c>WSCEnumProtocols</c> to retrieve all the requested information.
            </param>
            <param name="lpErrno">A pointer to the error code.</param>
            <returns>
            <para>
            If no error occurs, <c>WSCEnumProtocols</c> returns the number of protocols to be reported on. Otherwise, a value of
            SOCKET_ERROR is returned and a specific error code is available in lpErrno.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>One of more of the arguments is not in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>Indicates that one of the specified parameters was invalid.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>
            Buffer length was too small to receive all the relevant WSAProtocol_Info structures and associated information. Pass in a buffer
            at least as large as the value returned in lpdwBufferLength.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSCEnumProtocols</c> function is used to discover information about the collection of transport protocols installed on
            the local computer. This function differs from its API counterpart (WSAEnumProtocols) in that WSAPROTOCOL_INFOW structures for
            all installed protocols are returned. This includes protocols that the service provider has set the <c>PFL_HIDDEN</c> flag in
            the <c>dwProviderFlags</c> member of the <c>WSAPROTOCOL_INFOW</c> structure to indicate to the Ws2_32.dll that this protocol
            should not be returned in the result buffer generated by <c>WSAEnumProtocols</c> function. In addition, the
            <c>WSCEnumProtocols</c> also returns data for <c>WSAPROTOCOL_INFOW</c> structures that have a chain length of zero ( a dummy LSP
            provider). The <c>WSAEnumProtocols</c> only returns information on base protocols and protocol chains that lack the
            <c>PFL_HIDDEN</c> flag and don't have a protocol chain length of zero.
            </para>
            <para>
            **Note** Layered Service Providers are deprecated. Starting with Windows 8 and Windows Server 2012, use Windows Filtering Platform.
            </para>
            <para>
            The lpiProtocols parameter can be used as a filter to constrain the amount of information provided. Typically, a null pointer is
            supplied so the function will return information on all available transport protocols.
            </para>
            <para>
            A WSAPROTOCOL_INFOW structure is provided in the buffer pointed to by lpProtocolBuffer for each requested protocol. If the
            supplied buffer is not large enough (as indicated by the input value of lpdwBufferLength), the value pointed to by
            lpdwBufferLength will be updated to indicate the required buffer size. The Windows Sockets SPI client should then obtain a large
            enough buffer and call this function again. The <c>WSCEnumProtocols</c> function cannot enumerate over multiple calls; the
            passed-in buffer must be large enough to hold all expected entries in order for the function to succeed. This reduces the
            complexity of the function and should not pose a problem because the number of protocols loaded on a local computer is typically small.
            </para>
            <para>
            The order in which the WSAPROTOCOL_INFOW structures appear in the buffer coincides with the order in which the protocol entries
            were registered by the service provider with the WS2_32.dll, or with any subsequent reordering that may have occurred through
            the Windows Sockets applet supplied for establishing default transport providers.
            </para>
            <para>Examples</para>
            <para>
            The following example demonstrates the use of the <c>WSCEnumProtocols</c> function to retrieve an array of WSAPROTOCOL_INFOW
            structures for protocols installed on the local computer.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCEnumProtocols32(System.Int32[],System.IntPtr,System.UInt32@,System.Int32@)">
            <summary>The <c>WSCEnumProtocols32</c> function retrieves information about available transport protocols.</summary>
            <param name="lpiProtocols">
            Null-terminated array of iProtocol values. This parameter is optional; if lpiProtocols is null, information on all available
            protocols is returned. Otherwise, information is retrieved only for those protocols listed in the array.
            </param>
            <param name="lpProtocolBuffer">Buffer that is filled with WSAPROTOCOL_INFOW structures.</param>
            <param name="lpdwBufferLength">
            On input, size of the lpProtocolBuffer buffer passed to WSCEnumProtocols, in bytes. On output, the minimum buffer size, in
            bytes, that can be passed to <c>WSCEnumProtocols</c> to retrieve all the requested information.
            </param>
            <param name="lpErrno">Pointer to the error code.</param>
            <returns>
            <para>
            If no error occurs, <c>WSCEnumProtocols32</c> returns the number of protocols to be reported on. Otherwise, a value of
            SOCKET_ERROR is returned and a specific error code is available in lpErrno.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>One of more of the arguments is not in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>Indicates that one of the specified parameters was invalid.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>
            Buffer length was too small to receive all the relevant WSAProtocol_Info structures and associated information. Pass in a buffer
            at least as large as the value returned in lpdwBufferLength.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>WSCEnumProtocols32</c> is a strictly 32-bit version of WSCEnumProtocols. On a 64-bit computer, all calls not specifically
            32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that execute on a
            64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve compatibility.
            The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
            </para>
            <para>
            This function is used to discover information about the collection of transport protocols installed on the local computer. This
            function differs from its API counterpart (WSAEnumProtocols) in that WSAPROTOCOL_INFOW structures for all installed protocols
            are returned. This includes protocols that the service provider has set the <c>PFL_HIDDEN</c> flag in the <c>dwProviderFlags</c>
            member of the <c>WSAPROTOCOL_INFOW</c> structure to indicate to the Ws2_32.dll that this protocol should not be returned in the
            result buffer generated by <c>WSAEnumProtocols</c> function. In addition, the <c>WSCEnumProtocols32</c> also returns data for
            <c>WSAPROTOCOL_INFOW</c> structures that have a chain length of zero ( a dummy LSP provider). The <c>WSAEnumProtocols</c> only
            returns information on base protocols and protocol chains that lack the <c>PFL_HIDDEN</c> flag and don't have a protocol chain
            length of zero.
            </para>
            <para>
            **Note** Layered Service Providers are deprecated. Starting with Windows 8 and Windows Server 2012, use Windows Filtering Platform.
            </para>
            <para>
            The lpiProtocols parameter can be used as a filter to constrain the amount of information provided. Typically, a NULL pointer is
            supplied so the function will return information on all available transport protocols.
            </para>
            <para>
            A WSAPROTOCOL_INFOW structure is provided in the buffer pointed to by lpProtocolBuffer for each requested protocol. If the
            supplied buffer is not large enough (as indicated by the input value of lpdwBufferLength), the value pointed to by
            lpdwBufferLength will be updated to indicate the required buffer size. The Windows Sockets SPI client should then obtain a large
            enough buffer and call this function again. The <c>WSCEnumProtocols32</c> function cannot enumerate over multiple calls; the
            passed-in buffer must be large enough to hold all expected entries in order for the function to succeed. This reduces the
            complexity of the function and should not pose a problem because the number of protocols loaded on a computer is typically small.
            </para>
            <para>
            The order in which the WSAPROTOCOL_INFOW structures appear in the buffer coincides with the order in which the protocol entries
            were registered by the service provider with the WS2_32.dll, or with any subsequent reordering that may have occurred through
            the Windows Sockets applet supplied for establishing default transport providers.
            </para>
            <para>Examples</para>
            <para>
            The following example demonstrates the use of the <c>WSCEnumProtocols32</c> function for use on 64-bit platforms to retrieve an
            array of WSAPROTOCOL_INFOW structures for protocols installed on the local computer in the 32-bit catalog.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCGetApplicationCategory(System.String,System.UInt32,System.String,System.UInt32,System.UInt32@,System.Int32@)">
            <summary>
            <para>
            A pointer to a Unicode string that contains the load path to the executable image for the application. This string observes the
            usual rules for path resolution and can contain embedded environment strings (such as %SystemRoot%).
            </para>
            <para>The length, in characters, of the Path parameter. This length does not include the terminating <c>NULL</c>.</para>
            <para>
            A pointer to a Unicode string which represents the command line arguments used when starting the application specified in the
            Path parameter. The Extra parameter is used to distinguish between multiple, distinct instances of an application when launched
            with a consistent command line. This is to support different application categorizations for different instances of Svchost.exe
            or Rundll32.exe. If only the Path parameter is required and no command line arguments are needed to further distinguish between
            instances of an application, then the Extra parameter should be set to <c>NULL</c>.
            </para>
            <para>The length, in characters, of the Extra parameter. This length does not include the terminating <c>NULL</c>.</para>
            <para>
            A pointer to a DWORD value of permitted LSP categories which are permitted for all instances of this application. The
            application is identified by the combination of the values of the Path and Extra parameters.
            </para>
            <para>A pointer to the error code if the function fails.</para>
            </summary>
            <param name="Path">
            A pointer to a Unicode string that contains the load path to the executable image for the application. This string observes the
            usual rules for path resolution and can contain embedded environment strings (such as %SystemRoot%).
            </param>
            <param name="PathLength">The length, in characters, of the Path parameter. This length does not include the terminating <c>NULL</c>.</param>
            <param name="Extra">
            A pointer to a Unicode string which represents the command line arguments used when starting the application specified in the
            Path parameter. The Extra parameter is used to distinguish between multiple, distinct instances of an application when launched
            with a consistent command line. This is to support different application categorizations for different instances of Svchost.exe
            or Rundll32.exe. If only the Path parameter is required and no command line arguments are needed to further distinguish between
            instances of an application, then the Extra parameter should be set to <c>NULL</c>.
            </param>
            <param name="ExtraLength">The length, in characters, of the Extra parameter. This length does not include the terminating <c>NULL</c>.</param>
            <param name="pPermittedLspCategories">
            A pointer to a DWORD value of permitted LSP categories which are permitted for all instances of this application. The
            application is identified by the combination of the values of the Path and Extra parameters.
            </param>
            <param name="lpErrno">A pointer to the error code if the function fails.</param>
            <returns>
            <para>
            If no error occurs, <c>WSCGetApplicationCategory</c> returns <c>ERROR_SUCCESS</c> (zero). Otherwise, it returns
            <c>SOCKET_ERROR</c>, and a specific error code is returned in the lpErrno parameter.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>One or more of the arguments is not in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more of the arguments are invalid.</term>
            </item>
            <item>
            <term>WSASERVICE_NOT_FOUND</term>
            <term>
            The service could not be found based on the Path and Extra parameters. The error can also be returned if the application you are
            querying does not exist in the registry. In this case, the error indicates that the application is not currently categorized.
            </term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the
            administrative privileges required to access the Winsock registry, or a failure occurred when opening a Winsock catalog entry or
            an application ID entry.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>WSCGetApplicationCategory</c> is used to retrieve the LSP category flags associated with an application instance.
            Applications can determine which LSP behaviors are acceptable within the application's context. Therefore, by specifying
            permitted LSP categories, an application can permit only those layered service providers which implement acceptable behaviors to
            be loaded.
            </para>
            <para>
            The Extra parameter is required when the command line is used to distinguish between different instances of an application or
            service hosted within the same executable. Each instance can have different application categorization needs. Svchost.exe and
            Rundll32.exe are two examples where the command line is required to differentiate between different process instances. For
            SvcHost.exe, the <c>-k &lt;svcinstance&gt;</c> switch defines the process instance.
            </para>
            <para>
            For services, using the Service Name is not sufficient, since the Winsock Catalog is global to a given process, and a process
            may host several services.
            </para>
            <para>
            Window sockets determine an application's identity and retrieves the permitted LSP categories during the first call to
            WSAStartup. This will be the set of permitted LSP categories for the duration of the application instance. Subsequent changes to
            the permitted LSP categories for a given application identity will not be picked up until the next instance of the application.
            The permitted LSP categories are not mutable during the lifetime of the application instance.
            </para>
            <para>
            Winsock 2 accommodates layered protocols. A layered protocol is one that implements only higher level communications functions,
            while relying on an underlying transport stack for the actual exchange of data with a remote endpoint. An example of a layered
            protocol or layered service provider would be a security layer that adds protocol to the connection establishment process in
            order to perform authentication and to establish a mutually agreed upon encryption scheme. Such a security protocol would
            generally require the services of an underlying reliable transport protocol such as TCP or SPX. The term base protocol refers to
            a protocol such as TCP or SPX which is capable of performing data communications with a remote endpoint. The term layered
            protocol is used to describe a protocol that cannot stand alone.
            </para>
            <para>
            During LSP initialization, the LSP must provide pointers to a number of Winsock SPI functions. These functions will be called
            during normal processing by the layer directly above the LSP (either another LSP or Ws2_32.DLL).
            </para>
            <para>
            An LSP that implements an installable file system (IFS) can selectively choose to provide pointers to functions which are
            implemented by itself, or pass back the pointers provided by the layer directly below the LSP. Non-IFS LSPs, because they
            provide their own handles, must implement all of the Winsock SPI functions. This is because each SPI will require the LSP to map
            all of the socket handles it created to the socket handle of the lower provider (either another LSP or the base protocol).
            </para>
            <para>However, all LSPs perform their specific work by doing extra processing on only a subset of the Winsock SPI functions.</para>
            <para>
            It is possible to define LSP categories based upon the subset of SPI functions an LSP implements and the nature of the extra
            processing performed for each of those functions.
            </para>
            <para>
            By classifying LSPs, as well as classifying applications which use Winsock sockets, it becomes possible to selectively determine
            if an LSP should be involved in a given process at runtime.
            </para>
            <para>
            On Windows Vista and later, an LSP can be classified based on how it interacts with Windows Sockets calls and data. An LSP
            category is an identifiable group of behaviors on a subset of Winsock SPI functions. For example, an HTTP content filter would
            be categorized as a data inspector (the LSP_INSPECTOR category). The LSP_INSPECTOR category will inspect (but not alter)
            parameters to data transfer SPI functions. An application can query for the category of an LSP and choose to not load the LSP
            based on the LSP category and the application's set of permitted LSP categories.
            </para>
            <para>The following table lists categories that an LSP can be classified into.</para>
            <list type="table">
            <listheader>
            <term>LSP Category</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>**LSP_CRYPTO_COMPRESS**</term>
            <term>The LSP is a cryptography or data compression provider.</term>
            </item>
            <item>
            <term>**LSP_FIREWALL**</term>
            <term>The LSP is a firewall provider.</term>
            </item>
            <item>
            <term>**LSP_LOCAL_CACHE**</term>
            <term>The LSP is a local cache provider.</term>
            </item>
            <item>
            <term>**LSP_INBOUND_MODIFY**</term>
            <term>The LSP modifies inbound data.</term>
            </item>
            <item>
            <term>**LSP_INSPECTOR**</term>
            <term>The LSP inspects or filters data.</term>
            </item>
            <item>
            <term>**LSP_OUTBOUND_MODIFY**</term>
            <term>The LSP modifies outbound data.</term>
            </item>
            <item>
            <term>**LSP_PROXY**</term>
            <term>The LSP acts as a proxy and redirects packets.</term>
            </item>
            <item>
            <term>**LSP_REDIRECTOR**</term>
            <term>The LSP is a network redirector.</term>
            </item>
            <item>
            <term>**LSP_SYSTEM**</term>
            <term>The LSP is acceptable for use in services and system processes.</term>
            </item>
            </list>
            <para>
            An LSP may belong to more than one category. For example, a firewall/security LSP could belong to both the inspector (
            <c>LSP_INSPECTOR</c>) and firewall ( <c>LSP_FIREWALL</c>) categories.
            </para>
            <para>
            If an LSP does not have a category set, it is considered to be in the All Other category. This LSP category will not be loaded
            in services or system processes (for example, lsass, winlogon, and many svchost processes).
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCGetProviderInfo(System.Guid@,Vanara.PInvoke.Ws2_32.WSC_PROVIDER_INFO_TYPE,System.IntPtr,Vanara.PInvoke.SizeT@,System.UInt32,System.Int32@)">
            <summary>
            <para>A pointer to a globally unique identifier (GUID) for the provider.</para>
            <para>The information class that is requested for this LSP protocol entry.</para>
            <para>
            A pointer to a buffer to receive the information class data for the requested LSP protocol entry. If this parameter is
            <c>NULL</c>, then <c>WSCGetProviderInfo</c> returns failure and the size required for this buffer is returned in the InfoSize parameter.
            </para>
            <para>
            The size, in bytes, of the buffer pointed to by the Info parameter. If the Info parameter is <c>NULL</c>, then
            <c>WSCGetProviderInfo</c> returns failure and the InfoSize parameter will receive the size of the required buffer.
            </para>
            <para>The flags used to modify the behavior of the <c>WSCGetProviderInfo</c> function call.</para>
            <para>A pointer to the error code if the function fails.</para>
            </summary>
            <param name="lpProviderId">A pointer to a globally unique identifier (GUID) for the provider.</param>
            <param name="InfoType">The information class that is requested for this LSP protocol entry.</param>
            <param name="Info">
            A pointer to a buffer to receive the information class data for the requested LSP protocol entry. If this parameter is
            <c>NULL</c>, then <c>WSCGetProviderInfo</c> returns failure and the size required for this buffer is returned in the InfoSize parameter.
            </param>
            <param name="InfoSize">
            The size, in bytes, of the buffer pointed to by the Info parameter. If the Info parameter is <c>NULL</c>, then
            <c>WSCGetProviderInfo</c> returns failure and the InfoSize parameter will receive the size of the required buffer.
            </param>
            <param name="Flags">The flags used to modify the behavior of the <c>WSCGetProviderInfo</c> function call.</param>
            <param name="lpErrno">A pointer to the error code if the function fails.</param>
            <returns>
            <para>
            If no error occurs, <c>WSCGetProviderInfo</c> returns <c>ERROR_SUCCESS</c> (zero). Otherwise, it returns <c>SOCKET_ERROR</c>,
            and a specific error code is returned in the lpErrno parameter.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ERROR_CALL_NOT_IMPLEMENTED</term>
            <term>The call is not implemented. This error is returned if **ProviderInfoAudit** is specified in the InfoType parameter.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>One or more of the arguments is not in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more of the arguments are invalid.</term>
            </item>
            <item>
            <term>WSAEINVALIDPROVIDER</term>
            <term>The protocol entry could not be found for the specified lpProviderId.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the
            administrative privileges required to access the Winsock registry, or a failure occurred when opening a Winsock catalog entry.
            </term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>
            Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>WSCGetProviderInfo</c> is used to retrieve information class data for a layered service provider. When the InfoType parameter
            is set to <c>ProviderInfoLspCategories</c>, on success <c>WSCGetProviderInfo</c> returns with the Info parameter set with
            appropriate LSP category flags implemented by the LSP.
            </para>
            <para>
            Winsock 2 accommodates layered protocols. A layered protocol is one that implements only higher level communications functions,
            while relying on an underlying transport stack for the actual exchange of data with a remote endpoint. An example of a layered
            protocol or layered service provider would be a security layer that adds protocol to the connection establishment process in
            order to perform authentication and to establish a mutually agreed upon encryption scheme. Such a security protocol would
            generally require the services of an underlying reliable transport protocol such as TCP or SPX. The term base protocol refers to
            a protocol such as TCP or SPX which is capable of performing data communications with a remote endpoint. The term layered
            protocol is used to describe a protocol that cannot stand alone. A protocol chain would then be defined as one or more layered
            protocols strung together and anchored by a base protocol. A base protocol has the <c>ChainLen</c> member of the
            WSAProtocol_Info structure set to <c>BASE_PROTOCOL</c> which is defined to be 1. A layered protocol has the <c>ChainLen</c>
            member of the <c>WSAPROTOCOL_INFO</c> structure set to <c>LAYERED_PROTOCOL</c> which is defined to be zero. A protocol chain has
            the <c>ChainLen</c> member of the <c>WSAPROTOCOL_INFO</c> structure set to greater than 1.
            </para>
            <para>
            During LSP initialization, the LSP must provide pointers to a number of Winsock SPI functions. These functions will be called
            during normal processing by the layer directly above the LSP (either another LSP or Ws2_32.DLL).
            </para>
            <para>
            An LSP that implements an installable file system (IFS) can selectively choose to provide pointers to functions which are
            implemented by itself, or pass back the pointers provided by the layer directly below the LSP. Non-IFS LSPs, because they
            provide their own handles, must implement all of the Winsock SPI functions. This is because each SPI will require the LSP to map
            all of the socket handles it created to the socket handle of the lower provider (either another LSP or the base protocol).
            </para>
            <para>However, all LSPs perform their specific work by doing extra processing on only a subset of the Winsock SPI functions.</para>
            <para>
            It is possible to define LSP categories based upon the subset of SPI functions an LSP implements and the nature of the extra
            processing performed for each of those functions.
            </para>
            <para>
            By classifying LSPs, as well as classifying applications which use Winsock sockets, it becomes possible to selectively determine
            if an LSP should be involved in a given process at runtime.
            </para>
            <para>
            On Windows Vista and later, an LSP can be classified based on how it interacts with Windows Sockets calls and data. An LSP
            category is an identifiable group of behaviors on a subset of Winsock SPI functions. For example, an HTTP content filter would
            be categorized as a data inspector (the LSP_INSPECTOR category). The LSP_INSPECTOR category will inspect (but not alter)
            parameters to data transfer SPI functions. An application can query for the category of an LSP and choose to not load the LSP
            based on the LSP category and the application's set of permitted LSP categories.
            </para>
            <para>The following table lists categories into which an LSP can be classified.</para>
            <list type="table">
            <listheader>
            <term>LSP Category</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>**LSP_CRYPTO_COMPRESS**</term>
            <term>The LSP is a cryptography or data compression provider.</term>
            </item>
            <item>
            <term>**LSP_FIREWALL**</term>
            <term>The LSP is a firewall provider.</term>
            </item>
            <item>
            <term>**LSP_LOCAL_CACHE**</term>
            <term>The LSP is a local cache provider.</term>
            </item>
            <item>
            <term>**LSP_INBOUND_MODIFY**</term>
            <term>The LSP modifies inbound data.</term>
            </item>
            <item>
            <term>**LSP_INSPECTOR**</term>
            <term>The LSP inspects or filters data.</term>
            </item>
            <item>
            <term>**LSP_OUTBOUND_MODIFY**</term>
            <term>The LSP modifies outbound data.</term>
            </item>
            <item>
            <term>**LSP_PROXY**</term>
            <term>The LSP acts as a proxy and redirects packets.</term>
            </item>
            <item>
            <term>**LSP_REDIRECTOR**</term>
            <term>The LSP is a network redirector.</term>
            </item>
            <item>
            <term>**LSP_SYSTEM**</term>
            <term>The LSP is acceptable for use in services and system processes.</term>
            </item>
            </list>
            <para>
            An LSP may belong to more than one category. For example, a firewall/security LSP could belong to both the inspector (
            <c>LSP_INSPECTOR</c>) and firewall ( <c>LSP_FIREWALL</c>) categories.
            </para>
            <para>
            If an LSP does not have a category set, it is considered to be in the All Other category. This LSP category will not be loaded
            in services or system processes (for example, lsass, winlogon, and many svchost processes).
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCGetProviderInfo32(System.Guid@,Vanara.PInvoke.Ws2_32.WSC_PROVIDER_INFO_TYPE,System.IntPtr,Vanara.PInvoke.SizeT@,System.UInt32,System.Int32@)">
            <summary>
            <para>A pointer to a globally unique identifier (GUID) for the provider.</para>
            <para>The information class that is requested for this LSP protocol entry.</para>
            <para>
            A pointer to a buffer to receive the information class data for the requested LSP protocol entry. If this parameter is
            <c>NULL</c>, then <c>WSCGetProviderInfo32</c> returns failure and the size required for this buffer is returned in the InfoSize parameter.
            </para>
            <para>
            The size, in bytes, of the buffer pointed to by the Info parameter. If the Info parameter is <c>NULL</c>, then
            <c>WSCGetProviderInfo32</c> returns failure and the InfoSize parameter will receive the size of the required buffer.
            </para>
            <para>The flags used to modify the behavior of the <c>WSCGetProviderInfo32</c> function call.</para>
            <para>A pointer to the error code if the function fails.</para>
            </summary>
            <param name="lpProviderId">A pointer to a globally unique identifier (GUID) for the provider.</param>
            <param name="InfoType">The information class that is requested for this LSP protocol entry.</param>
            <param name="Info">
            A pointer to a buffer to receive the information class data for the requested LSP protocol entry. If this parameter is
            <c>NULL</c>, then <c>WSCGetProviderInfo32</c> returns failure and the size required for this buffer is returned in the InfoSize parameter.
            </param>
            <param name="InfoSize">
            The size, in bytes, of the buffer pointed to by the Info parameter. If the Info parameter is <c>NULL</c>, then
            <c>WSCGetProviderInfo32</c> returns failure and the InfoSize parameter will receive the size of the required buffer.
            </param>
            <param name="Flags">The flags used to modify the behavior of the <c>WSCGetProviderInfo32</c> function call.</param>
            <param name="lpErrno">A pointer to the error code if the function fails.</param>
            <returns>
            <para>
            If no error occurs, <c>WSCGetProviderInfo32</c> returns <c>ERROR_SUCCESS</c> (zero). Otherwise, it returns <c>SOCKET_ERROR</c>,
            and a specific error code is returned in the lpErrno parameter.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ERROR_CALL_NOT_IMPLEMENTED</term>
            <term>The call is not implemented. This error is returned if **ProviderInfoAudit** is specified in the InfoType parameter.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>One or more of the arguments is not in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more of the arguments are invalid.</term>
            </item>
            <item>
            <term>WSAEINVALIDPROVIDER</term>
            <term>The protocol entry could not be found for the specified lpProviderId.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the
            administrative privileges required to access the Winsock registry, or a failure occurred when opening a Winsock catalog entry.
            </term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>
            Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>WSCGetProviderInfo32</c> is a strictly 32-bit version of WSCGetProviderInfo. On a 64-bit computer, all calls not specifically
            32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that execute on a
            64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve compatibility.
            The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
            </para>
            <para>
            <c>WSCGetProviderInfo32</c> is used to retrieve information class data for a protocol entry on a 32-bit layered service
            provider. When the InfoType parameter is set to <c>ProviderInfoLspCategories</c>, on success <c>WSCGetProviderInfo32</c> returns
            with the Info parameter set with appropriate LSP category flags implemented by 32-bit LSP.
            </para>
            <para>
            Winsock 2 accommodates layered protocols. A layered protocol is one that implements only higher level communications functions,
            while relying on an underlying transport stack for the actual exchange of data with a remote endpoint. An example of a layered
            protocol or layered service provider would be a security layer that adds protocol to the connection establishment process in
            order to perform authentication and to establish a mutually agreed upon encryption scheme. Such a security protocol would
            generally require the services of an underlying reliable transport protocol such as TCP or SPX. The term base protocol refers to
            a protocol such as TCP or SPX which is capable of performing data communications with a remote endpoint. The term layered
            protocol is used to describe a protocol that cannot stand alone. A protocol chain would then be defined as one or more layered
            protocols strung together and anchored by a base protocol. A base protocol has the <c>ChainLen</c> member of the
            WSAProtocol_Info structure set to <c>BASE_PROTOCOL</c> which is defined to be 1. A layered protocol has the <c>ChainLen</c>
            member of the <c>WSAPROTOCOL_INFO</c> structure set to <c>LAYERED_PROTOCOL</c> which is defined to be zero. A protocol chain has
            the <c>ChainLen</c> member of the <c>WSAPROTOCOL_INFO</c> structure set to greater than 1.
            </para>
            <para>
            During LSP initialization, the LSP must provide pointers to a number of Winsock SPI functions. These functions will be called
            during normal processing by the layer directly above the LSP (either another LSP or Ws2_32.DLL).
            </para>
            <para>
            An LSP that implements an installable file system (IFS) can selectively choose to provide pointers to functions which are
            implemented by itself, or pass back the pointers provided by the layer directly below the LSP. Non-IFS LSPs, because they
            provide their own handles, must implement all of the Winsock SPI functions. This is because each SPI will require the LSP to map
            all of the socket handles it created to the socket handle of the lower provider (either another LSP or the base protocol).
            </para>
            <para>However, all LSPs perform their specific work by doing extra processing on only a subset of the Winsock SPI functions.</para>
            <para>
            It is possible to define LSP categories based upon the subset of SPI functions an LSP implements and the nature of the extra
            processing performed for each of those functions.
            </para>
            <para>
            By classifying LSPs, as well as classifying applications which use Winsock sockets, it becomes possible to selectively determine
            if an LSP should be involved in a given process at runtime.
            </para>
            <para>
            On Windows Vista and later, an LSP can be classified based on how it interacts with Windows Sockets calls and data. An LSP
            category is an identifiable group of behaviors on a subset of Winsock SPI functions. For example, an HTTP content filter would
            be categorized as a data inspector (the <c>LSP_INSPECTOR</c> category). The <c>LSP_INSPECTOR</c> category will inspect, but not
            alter, parameters to data transfer SPI functions. An application can query for the category of an LSP and choose to not load the
            LSP based on the LSP category and the application's set of permitted LSP categories.
            </para>
            <para>The following table lists categories into which an LSP can be classified.</para>
            <list type="table">
            <listheader>
            <term>LSP Category</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>**LSP_CRYPTO_COMPRESS**</term>
            <term>The LSP is a cryptography or data compression provider.</term>
            </item>
            <item>
            <term>**LSP_FIREWALL**</term>
            <term>The LSP is a firewall provider.</term>
            </item>
            <item>
            <term>**LSP_LOCAL_CACHE**</term>
            <term>The LSP is a local cache provider.</term>
            </item>
            <item>
            <term>**LSP_INBOUND_MODIFY**</term>
            <term>The LSP modifies inbound data.</term>
            </item>
            <item>
            <term>**LSP_INSPECTOR**</term>
            <term>The LSP inspects or filters data.</term>
            </item>
            <item>
            <term>**LSP_OUTBOUND_MODIFY**</term>
            <term>The LSP modifies outbound data.</term>
            </item>
            <item>
            <term>**LSP_PROXY**</term>
            <term>The LSP acts as a proxy and redirects packets.</term>
            </item>
            <item>
            <term>**LSP_REDIRECTOR**</term>
            <term>The LSP is a network redirector.</term>
            </item>
            <item>
            <term>**LSP_SYSTEM**</term>
            <term>The LSP is acceptable for use in services and system processes.</term>
            </item>
            </list>
            <para>
            An LSP may belong to more than one category. For example, a firewall/security LSP could belong to both the inspector (
            <c>LSP_INSPECTOR</c>) and firewall ( <c>LSP_FIREWALL</c>) categories.
            </para>
            <para>
            If an LSP does not have a category set, it is considered to be in the All Other category. This LSP category will not be loaded
            in services or system processes (for example, lsass, winlogon, and many svchost processes).
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCGetProviderPath(System.Guid@,System.Text.StringBuilder,System.Int32@,System.Int32@)">
            <summary>The <c>WSCGetProviderPath</c> function retrieves the DLL path for the specified provider.</summary>
            <param name="lpProviderId">
            A pointer to a globally unique identifier (GUID) for the provider. This value is obtained by using WSCEnumProtocols.
            </param>
            <param name="lpszProviderDllPath">
            A pointer to a buffer into which the provider DLL's path string is returned. The path is a null-terminated string and any
            embedded environment strings, such as %SystemRoot%, have not been expanded.
            </param>
            <param name="lpProviderDllPathLen">The size, in characters, of the buffer pointed to by the lpszProviderDllPath parameter.</param>
            <param name="lpErrno">A pointer to the error code if the function fails.</param>
            <returns>
            <para>
            If no error occurs, <c>WSCGetProviderPath</c> returns zero. Otherwise, it returns SOCKET_ERROR. The specific error code is
            available in lpErrno.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEINVAL</term>
            <term>The lpProviderId parameter does not specify a valid provider.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The lpszProviderDllPath or lpErrno parameter is not in a valid part of the user address space, or lpProviderDllPathLen is too small.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            The <c>WSCGetProviderPath</c> function retrieves the DLL path for the specified provider. The DLL path can contain embedded
            environment strings, such as %SystemRoot%, and thus should be expanded prior to being used with the Windows LoadLibrary
            function. For more information, see <c>LoadLibrary</c>.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCGetProviderPath32(System.Guid@,System.Text.StringBuilder,System.Int32@,System.Int32@)">
            <summary>The <c>WSCGetProviderPath32</c> function retrieves the DLL path for the specified 32-bit provider.</summary>
            <param name="lpProviderId">Locally unique identifier of the provider. This value is obtained by using WSCEnumProtocols32.</param>
            <param name="lpszProviderDllPath">
            Pointer to a buffer into which the provider DLL's path string is returned. The path is a null-terminated string and any embedded
            environment strings, such as %SystemRoot%, have not been expanded.
            </param>
            <param name="lpProviderDllPathLen">Size of the buffer pointed to by the lpszProviderDllPath parameter, in characters.</param>
            <param name="lpErrno">Pointer to the error code.</param>
            <returns>
            <para>
            If no error occurs, <c>WSCGetProviderPath32</c> returns zero. Otherwise, it returns SOCKET_ERROR. The specific error code is
            available in lpErrno.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEINVAL</term>
            <term>The lpProviderId parameter does not specify a valid provider.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>
            The lpszProviderDllPath or lpErrno parameter is not in a valid part of the user address space, or lpProviderDllPathLen is too small.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>WSCGetProviderPath32</c> is a strictly 32-bit version of WSCGetProviderPath. On a 64-bit computer, all calls not specifically
            32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that execute on a
            64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve compatibility.
            The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
            </para>
            <para>
            The <c>WSCGetProviderPath32</c> function retrieves the DLL path for the specified provider. The DLL path can contain embedded
            environment strings, such as %SystemRoot%, and thus should be expanded prior to being used with the Windows LoadLibrary
            function. For more information, see <c>LoadLibrary</c>.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCInstallNameSpace(System.String,System.String,System.UInt32,System.UInt32,System.Guid@)">
            <summary>
            The <c>WSCInstallNameSpace</c> function installs a namespace provider. For providers that are able to support multiple
            namespaces, this function must be called for each namespace supported, and a unique provider identifier must be supplied each time.
            </summary>
            <param name="lpszIdentifier">
            A pointer to a string that identifies the provider associated with the globally unique identifier (GUID) passed in the
            lpProviderId parameter.
            </param>
            <param name="lpszPathName">
            A pointer to a Unicode string that contains the load path to the provider DLL. This string observes the usual rules for path
            resolution and can contain embedded environment strings (such as %SystemRoot%). Such environment strings are expanded when the
            Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are
            expanded, the Ws2_32.dll passes the resulting string to the LoadLibrary function which loads the provider into memory. For more
            information, see <c>LoadLibrary</c>.
            </param>
            <param name="dwNameSpace">The namespace supported by this provider.</param>
            <param name="dwVersion">The version number of the provider.</param>
            <param name="lpProviderId">A pointer to a GUID for the provider. This GUID should be generated by Uuidgen.exe.</param>
            <returns>
            <para>
            If no error occurs, the <c>WSCInstallNameSpace</c> function returns <c>NO_ERROR</c> (zero). Otherwise, it returns
            <c>SOCKET_ERROR</c> if the function fails, and you must retrieve the appropriate error code using the WSAGetLastError function.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEACCES</term>
            <term>The calling routine does not have sufficient privileges to install a namespace.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more of the arguments are invalid.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred. This error is returned under several conditions including the following: the provider is
            already installed, the user lacks the administrative privileges required to write to the Winsock registry, or a failure occurred
            when creating or installing a catalog entry.
            </term>
            </item>
            <item>
            <term>WSASYSCALLFAILURE</term>
            <term>A system call that should never fail has failed.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>
            Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The namespaceconfiguration functions do not affect applications that are already running. Newly installed namespace providers
            will not be visible to applications nor will the changes in a namespace provider's activation state. Applications launched after
            the call to <c>WSCInstallNameSpace</c> will see the changes.
            </para>
            <para>
            The <c>WSCInstallNameSpace</c> function can only be called by a user logged on as a member of the Administrators group. If
            <c>WSCInstallNameSpace</c> is called by a user that is not a member of the Administrators group, the function call will fail.
            For computers running on Windows Vista or Windows Server 2008, this function can also fail because of user account control
            (UAC). If an application that contains this function is executed by a user logged on as a member of the Administrators group
            other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a
            <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If the application on Windows Vista or Windows Server 2008
            lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must
            then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCInstallNameSpace32(System.String,System.String,System.UInt32,System.UInt32,System.Guid@)">
            <summary>
            The <c>WSCInstallNameSpace32</c> function installs a specified 32-bit namespace provider. For providers that are able to support
            multiple namespaces, this function must be called for each namespace supported, and a unique provider identifier must be
            supplied each time.
            </summary>
            <param name="lpszIdentifier">
            A pointer to a string that identifies the provider associated with the globally unique identifier (GUID) passed in the
            lpProviderId parameter.
            </param>
            <param name="lpszPathName">
            A pointer to a string that contains the path to the provider's DLL image. The string observes the usual rules for path
            resolution: this path can contain embedded environment strings (such as %SystemRoot%). Such environment strings are expanded
            whenever the WS2_32.DLL must subsequently load the provider DLL on behalf of an application. After any embedded environment
            strings are expanded, the Ws2_32.dll passes the resulting string into the LoadLibrary function to load the provider into memory.
            For more information, see <c>LoadLibrary</c>.
            </param>
            <param name="dwNameSpace">A descriptor that specifies the namespace supported by this provider.</param>
            <param name="dwVersion">A descriptor that specifies the version number of the provider.</param>
            <param name="lpProviderId">A unique identifier for this provider. This GUID should be generated by Uuidgen.exe.</param>
            <returns>
            <para>
            If no error occurs, the <c>WSCInstallNameSpace32</c> function returns NO_ERROR (zero). Otherwise, it returns SOCKET_ERROR if the
            function fails, and you must retrieve the appropriate error code using the WSAGetLastError function.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEACCES</term>
            <term>The calling routine does not have sufficient privileges to install a namespace.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more of the arguments are invalid.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred. This error is returned under several conditions including the following: the provider is
            already installed, the user lacks the administrative privileges required to write to the Winsock registry, or a failure occurred
            when creating or installing a catalog entry.
            </term>
            </item>
            <item>
            <term>WSASYSCALLFAILURE</term>
            <term>A system call that should never fail has failed.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>
            Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>WSCInstallNameSpace32</c> is a strictly 32-bit version of WSCInstallNameSpace. On a 64-bit computer, all calls not
            specifically 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that
            execute on a 64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve
            compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
            </para>
            <para>
            The namespace configuration functions do not affect applications that are already running. Newly installed namespace providers
            will not be visible to applications nor will the changes in a namespace provider's activation state. Applications launched after
            the call to <c>WSCInstallNameSpace32</c> will recognize the changes.
            </para>
            <para>
            The <c>WSCInstallNameSpace32</c> function can only be called by a user logged on as a member of the Administrators group. If
            <c>WSCInstallNameSpace32</c> is called by a user that is not a member of the Administrators group, the function call will fail.
            For computers running Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC).
            If an application that contains this function is executed by a user logged on as a member of the Administrators group other than
            the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a
            <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If the application on Windows Vista or Windows Server 2008
            lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must
            then be executing the application in an enhanced shell as the built-in Administrator ( <c>RunAs administrator</c>) for this
            function to succeed.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCInstallNameSpaceEx(System.String,System.String,System.UInt32,System.UInt32,System.Guid@,Vanara.PInvoke.Ws2_32.BLOB@)">
            <summary>
            The <c>WSCInstallNameSpaceEx</c> function installs a namespace provider. For providers that are able to support multiple
            namespaces, this function must be called for each namespace supported, and a unique provider identifier must be supplied each time.
            </summary>
            <param name="lpszIdentifier">
            A pointer to a string that identifies the provider associated with the globally unique identifier (GUID) passed in the
            lpProviderId parameter.
            </param>
            <param name="lpszPathName">
            A pointer to a Unicode string that contains the load path to the provider DLL. This string observes the usual rules for path
            resolution and can contain embedded environment strings (such as %SystemRoot%). Such environment strings are expanded when the
            Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are
            expanded, the Ws2_32.dll passes the resulting string to the LoadLibrary function which loads the provider into memory. For more
            information, see <c>LoadLibrary</c>.
            </param>
            <param name="dwNameSpace">The namespace supported by this provider.</param>
            <param name="dwVersion">The version number of the provider.</param>
            <param name="lpProviderId">A pointer to a GUID for the provider. This GUID should be generated by Uuidgen.exe.</param>
            <param name="lpProviderSpecific">A provider-specific data blob associated with namespace entry.</param>
            <returns>
            <para>
            If no error occurs, the <c>WSCInstallNameSpaceEx</c> function returns <c>NO_ERROR</c> (zero). Otherwise, it returns
            <c>SOCKET_ERROR</c> if the function fails, and you must retrieve the appropriate error code using the WSAGetLastError function.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEACCES</term>
            <term>The calling routine does not have sufficient privileges to install a namespace.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more of the arguments are invalid.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred. This error is returned under several conditions including the following: the provider is
            already installed, the user lacks the administrative privileges required to write to the Winsock registry, or a failure occurred
            when creating or installing a catalog entry.
            </term>
            </item>
            <item>
            <term>WSASYSCALLFAILURE</term>
            <term>A system call that should never fail has failed.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>
            Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The namespaceconfiguration functions do not affect applications that are already running. Newly installed name-space providers
            will not be visible to applications nor will the changes in a name-space provider's activation state. Applications launched
            after the call to <c>WSCInstallNameSpaceEx</c> will see the changes.
            </para>
            <para>
            The provider-specific data blob associated with namespace entry passed in the lpProviderInfo parameter can be queried using the
            WSAEnumNameSpaceProvidersEx function.
            </para>
            <para>
            Currently, the only namespace provider included with Windows that uses the lpProviderInfo parameter is the NS_EMAIL provider.
            The format of the buffer pointed to by the lpProviderInfo parameter for an NS_EMAIL namespace provider is a
            NAPI_PROVIDER_INSTALLATION_BLOB structure.
            </para>
            <para>
            The <c>WSCInstallNameSpaceEx</c> function can only be called by a user logged on as a member of the Administrators group. If
            <c>WSCInstallNameSpaceEx</c> is called by a user that is not a member of the Administrators group, the function call will fail.
            For computers running on Windows Vista or Windows Server 2008, this function can also fail because of user account control
            (UAC). If an application that contains this function is executed by a user logged on as a member of the Administrators group
            other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a
            <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If the application on Windows Vista or Windows Server 2008
            lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must
            then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCInstallNameSpaceEx32(System.String,System.String,System.UInt32,System.UInt32,System.Guid@,Vanara.PInvoke.Ws2_32.BLOB@)">
            <summary>
            <para>
            The <c>WSCInstallNameSpaceEx32</c> function installs a specified 32-bit namespace provider. For providers that are able to
            support multiple names spaces, this function must be called for each namespace supported, and a unique provider identifier must
            be supplied each time.
            </para>
            <para>
            **Note** This call is a strictly 32-bit version of WSCInstallNameSpaceEx32 for use on 64-bit platforms. It is provided to allow
            64-bit processes to access the 32-bit catalogs.
            </para>
            </summary>
            <param name="lpszIdentifier">
            A pointer to a string that identifies the provider associated with the globally unique identifier (GUID) passed in the
            lpProviderId parameter.
            </param>
            <param name="lpszPathName">
            A pointer to a Unicode string that contains the load path to the provider DLL. This string observes the usual rules for path
            resolution and can contain embedded environment strings (such as %SystemRoot%). Such environment strings are expanded when the
            Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are
            expanded, the Ws2_32.dll passes the resulting string to the LoadLibrary function which loads the provider into memory. For more
            information, see <c>LoadLibrary</c>.
            </param>
            <param name="dwNameSpace">The namespace supported by this provider.</param>
            <param name="dwVersion">The version number of the provider.</param>
            <param name="lpProviderId">A pointer to a GUID for the provider. This GUID should be generated by Uuidgen.exe.</param>
            <param name="lpProviderSpecific">A provider-specific data blob associated with namespace entry.</param>
            <returns>
            <para>
            If no error occurs, the <c>WSCInstallNameSpaceEx32</c> function returns <c>NO_ERROR</c> (zero). Otherwise, it returns
            <c>SOCKET_ERROR</c> if the function fails, and you must retrieve the appropriate error code using the WSAGetLastError function.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEACCES</term>
            <term>The calling routine does not have sufficient privileges to install a namespace.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more of the arguments are invalid.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred. This error is returned under several conditions including the following: the provider is
            already installed, the user lacks the administrative privileges required to write to the Winsock registry, or a failure occurred
            when creating or installing a catalog entry.
            </term>
            </item>
            <item>
            <term>WSASYSCALLFAILURE</term>
            <term>A system call that should never fail has failed.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>
            Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>WSCInstallNameSpaceEx32</c> is a strictly 32-bit version of WSCInstallNameSpaceEx. On a 64-bit computer, all calls not
            specifically 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that
            execute on a 64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve
            compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
            </para>
            <para>
            The namespaceconfiguration functions do not affect applications that are already running. Newly installed name-space providers
            will not be visible to applications nor will the changes in a name-space provider's activation state. Applications launched
            after the call to <c>WSCInstallNameSpaceEx32</c> will see the changes.
            </para>
            <para>
            The provider-specific data blob associated with namespace entry passed in the lpProviderInfo parameter can be queried using
            WSCEnumNameSpaceProvidersEx32 function.
            </para>
            <para>
            Currently, the only namespace provider included with Windows that uses the lpProviderInfo parameter is the NS_EMAIL provider.
            The format of the buffer pointed to by the lpProviderInfo parameter for an NS_EMAIL namespace provider is a
            NAPI_PROVIDER_INSTALLATION_BLOB structure.
            </para>
            <para>
            The <c>WSCInstallNameSpaceEx32</c> function can only be called by a user logged on as a member of the Administrators group. If
            <c>WSCInstallNameSpaceEx32</c> is called by a user that is not a member of the Administrators group, the function call will
            fail. For computers running on Windows Vista or Windows Server 2008, this function can also fail because of user account control
            (UAC). If an application that contains this function is executed by a user logged on as a member of the Administrators group
            other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a
            <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If the application on Windows Vista or Windows Server 2008
            lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must
            then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCInstallProvider(System.Guid@,System.String,Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW[],System.UInt32,System.Int32@)">
            <summary>
            <para>A pointer to a globally unique identifier (GUID) for the provider.</para>
            <para>
            A pointer to a Unicode string that contains the load path to the provider DLL. This string observes the usual rules for path
            resolution and can contain embedded environment strings (such as %SystemRoot%). Such environment strings are expanded when the
            Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are
            expanded, the Ws2_32.dll passes the resulting string to the LoadLibrary function which loads the provider into memory. For more
            information, see <c>LoadLibrary</c>.
            </para>
            <para>
            A pointer to an array of WSAProtocol_Info structures. Each structure defines a protocol, address family, and socket type
            supported by the provider.
            </para>
            <para>The number of entries in the lpProtocolInfoList array.</para>
            <para>A pointer to the error code if the function fails.</para>
            </summary>
            <param name="lpProviderId">A pointer to a globally unique identifier (GUID) for the provider.</param>
            <param name="lpszProviderDllPath">
            A pointer to a Unicode string that contains the load path to the provider DLL. This string observes the usual rules for path
            resolution and can contain embedded environment strings (such as %SystemRoot%). Such environment strings are expanded when the
            Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are
            expanded, the Ws2_32.dll passes the resulting string to the LoadLibrary function which loads the provider into memory. For more
            information, see <c>LoadLibrary</c>.
            </param>
            <param name="lpProtocolInfoList">
            A pointer to an array of WSAProtocol_Info structures. Each structure defines a protocol, address family, and socket type
            supported by the provider.
            </param>
            <param name="dwNumberOfEntries">The number of entries in the lpProtocolInfoList array.</param>
            <param name="lpErrno">A pointer to the error code if the function fails.</param>
            <returns>
            <para>
            If <c>WSCInstallProvider</c> succeeds, it returns zero. Otherwise, it returns <c>SOCKET_ERROR</c>, and a specific error code is
            returned in the lpErrno parameter.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>One or more of the arguments is not in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more of the arguments are invalid.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>Memory cannot be allocated for buffers.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred. This error is returned under several conditions including the following: the provider is
            already installed, the user lacks the administrative privileges required to write to the Winsock registry, or a failure occurred
            when creating or installing a catalog entry.
            </term>
            </item>
            <item>
            <term>WSASYSCALLFAILURE</term>
            <term>A system call that should never fail has failed.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>
            Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>WSCInstallProvider</c> is used to install a single transport service provider. This routine creates the necessary common
            Windows Sockets 2 configuration information for the specified provider. It is applicable to base protocols, layered protocols,
            and protocol chains. If a layered service provider is being installed, then WSCInstallProviderAndChains should be used.
            <c>WSCInstallProviderAndChains</c> can install a layered protocol and one or more protocol chains with a single function call.
            To accomplish the same work using <c>WSCInstallProvider</c> would require multiple function calls.
            </para>
            <para>
            Winsock 2 accommodates layered protocols. A layered protocol is one that implements only higher level communications functions
            while relying on an underlying transport stack for the actual exchange of data with a remote endpoint. An example of a layered
            protocol would be a security layer that adds a protocol to the connection establishment process in order to perform
            authentication and to establish a mutually agreed upon encryption scheme. Such a security protocol would generally require the
            services of an underlying reliable transport protocol such as TCP or SPX. The term base protocol refers to a protocol such as
            TCP or SPX which is capable of performing data communications with a remote endpoint. The term layered protocol is used to
            describe a protocol that cannot stand alone. A protocol chain would then be defined as one or more layered protocols strung
            together and anchored by a base protocol. A base protocol has the <c>ChainLen</c> member of the WSAProtocol_Info structure set
            to <c>BASE_PROTOCOL</c> which is defined to be 1. A layered protocol has the <c>ChainLen</c> member of the
            <c>WSAPROTOCOL_INFO</c> structure set to <c>LAYERED_PROTOCOL</c> which is defined to be zero. A protocol chain has the
            <c>ChainLen</c> member of the <c>WSAPROTOCOL_INFO</c> structure set to greater than 1.
            </para>
            <para>
            The lpProtocolInfoList parameter contains a list of protocol entries to install. Callers of <c>WSCInstallProvider</c> are
            responsible for setting up the proper protocol entries. The lpProtocolInfoList parameter must not be <c>NULL</c>.
            </para>
            <para>
            Upon successful completion of this call, any subsequent calls to WSAEnumProtocols or WSCEnumProtocols will return the
            newly-created protocol entries. Be aware that in Windows environments, only instances of Ws_32.dll created by calling WSAStartup
            after the successful completion of <c>WSCInstallProvider</c> will include the new entries when <c>WSAEnumProtocols</c> and
            <c>WSCEnumProtocols</c> returns.
            </para>
            <para>
            On success, <c>WSCInstallProvider</c> will attempt to alert all interested applications that have registered for notification of
            the change by calling WSAProviderConfigChange.
            </para>
            <para>
            The <c>WSCInstallProvider</c> function can only be called by a user logged on as a member of the Administrators group. If
            <c>WSCInstallProvider</c> is called by a user that is not a member of the Administrators group, the function call will fail and
            WSANO_RECOVERY is returned in the lpErrno parameter. For computers running Windows Vista or Windows Server 2008, this function
            can also fail because of user account control (UAC). If an application that contains this function is executed by a user logged
            on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the application has
            been marked in the manifest file with a <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If the application on
            Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the Administrators group other
            than the built-in Administrator must then be executing the application in an enhanced shell as the built-in Administrator (
            <c>RunAs administrator</c>) for this function to succeed.
            </para>
            <para>Any file installation or service provider-specific configuration must be performed by the caller.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCInstallProvider64_32(System.Guid@,System.String,Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW[],System.UInt32,System.Int32@)">
            <summary>
            <para>[**WSCInstallProvider64_32** is no longer available for use as of Windows Vista. Instead, use WSCInstallProvider or WSCInstallProviderAndChains.]</para>
            <para>
            The <c>WSCInstallProvider64_32</c> function installs the specified transport service provider into the 32-bit and 64-bit system
            configuration databases on a 64-bit computer.
            </para>
            </summary>
            <param name="lpProviderId">A pointer to a globally unique identifier (GUID) for the provider.</param>
            <param name="lpszProviderDllPath">
            A pointer to a Unicode string that contains the load path to the provider 64-bit DLL. This string observes the usual rules for
            path resolution and can contain embedded environment strings (such as %SystemRoot%). Such environment strings are expanded when
            the Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are
            expanded, the Ws2_32.dll passes the resulting string to the LoadLibrary function which loads the provider into memory. For more
            information, see <c>LoadLibrary</c>.
            </param>
            <param name="lpProtocolInfoList">
            A pointer to an array of WSAProtocol_Info structures. Each structure defines a protocol, address family, and socket type
            supported by the provider.
            </param>
            <param name="dwNumberOfEntries">The number of entries in the lpProtocolInfoList array.</param>
            <param name="lpErrno">A pointer to the error code if the function fails.</param>
            <returns>
            <para>
            If <c>WSCInstallProvider64_32</c> succeeds, it returns zero. Otherwise, it returns <c>SOCKET_ERROR</c>, and a specific error
            code is returned in the lpErrno parameter.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>One or more of the arguments is not in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more of the arguments are invalid.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>Memory could not be allocated for buffers.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred. This error is returned under several conditions including the following: the provider is
            already installed, the user lacks the administrative privileges required to write to the Winsock registry, or a failure occurred
            when creating or installing a catalog entry.
            </term>
            </item>
            <item>
            <term>WSASYSCALLFAILURE</term>
            <term>A system call that should never fail has failed.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>
            Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>WSCInstallProvider64_32</c> is a basic version of the WSCInstallProviderAndChains64_32 function that only installs a single
            transport service provider. <c>WSCInstallProvider64_32</c> can be used to install a base protocol, a layered protocol, or a
            protocol chain. If a layered service provider is being installed, then <c>WSCInstallProviderAndChains64_32</c> should be used
            because this function allows a layered protocol and one or more protocol chains to be installed with a single function call. To
            accomplish the same work using <c>WSCInstallProvider64_32</c> would require multiple function calls to install each service
            provider component.
            </para>
            <para>
            Windows Sockets (Winsock) 2 accommodates the notion of a layered protocol. A layered protocol is one that implements only higher
            level communications functions while relying on an underlying transport stack for the actual exchange of data with a remote
            endpoint. An example of a layered protocol would be a security layer that adds a protocol to the connection establishment
            process to perform authentication and to establish a mutually agreed upon encryption scheme. Such a security protocol would
            generally require the services of an underlying reliable transport protocol such as TCP or SPX. The term base protocol refers to
            a protocol such as TCP or SPX which is fully capable of performing data communications with a remote endpoint. The term layered
            protocol is used to describe a protocol that cannot stand alone. A protocol chain would then be defined as one or more layered
            protocols strung together and anchored by a base protocol. A base protocol has the <c>ChainLen</c> member of the
            WSAProtocol_Info structure set to <c>BASE_PROTOCOL</c> which is defined to be 1. A layered protocol has the <c>ChainLen</c>
            member of the <c>WSAPROTOCOL_INFO</c> structure set to <c>LAYERED_PROTOCOL</c> which is defined to be zero. A protocol chain has
            the <c>ChainLen</c> member of the <c>WSAPROTOCOL_INFO</c> structure set to greater than 1.
            </para>
            <para>
            <c>WSCInstallProvider64_32</c> is the 64-bit version of WSCInstallProvider that installs the provider into both the 32-bit and
            64-bit catalogs on 64-bit platforms. That is, on 64-bit platforms, two Winsock catalogs are maintained, and both 32-bit and
            64-bit processes are able to load the transport provider installed with this function. On 64-bit platforms,
            <c>WSCInstallProvider</c> installs only to the 64-bit Winsock catalog.
            </para>
            <para>
            On a 64-bit computer, all calls not specifically designed for 32-bit (for example, all functions that do not end in "32")
            operate on the native 64-bit catalog. Processes that execute on a 64-bit computer must use <c>WSCInstallProvider64_32</c> to
            operate on both the 32-bit catalog as well as the 64-bit catalog, preserving compatibility. The definitions and semantics of the
            specific 32-bit calls are the same as their native counterparts.
            </para>
            <para>
            This routine creates the necessary common Winsock 2 configuration information for the specified provider. It is applicable to
            base protocols, layered protocols, and protocol chains.
            </para>
            <para>
            The lpProtocolInfoList parameter contains a list of protocol entries to install. Callers of <c>WSCInstallProvider64_32</c> are
            responsible for setting up the proper protocol entries. The lpProtocolInfoList parameter must not be <c>NULL</c>.
            </para>
            <para>
            After this routine completes successfully, the protocol information provided in lpProtocolInfoList will be returned by
            WSAEnumProtocols, WSCEnumProtocols, or WSCEnumProtocols32. Be aware that in Windows, only instances of the Ws2_32.dll created by
            calling WSAStartup after a successful completion of this function will include the new entries in <c>WSAEnumProtocols</c>,
            <c>WSCEnumProtocols</c>, and <c>WSCEnumProtocols32</c>.
            </para>
            <para>
            On success, <c>WSCInstallProvider64_32</c> will attempt to alert all interested applications that have registered for
            notification of the change by calling WSAProviderConfigChange.
            </para>
            <para>
            The <c>WSCInstallProvider64_32</c> function can only be called by a user logged on as a member of the Administrators group. If
            <c>WSCInstallProvider64_32</c> is called by a user that is not a member of the Administrators group, the function call will fail
            and WSANO_RECOVERY is returned in the lpErrno parameter. For computers running Windows Vista or Windows Server 2008, this
            function can also fail because of user account control (UAC). If an application that contains this function is executed by a
            user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the
            application has been marked in the manifest file with a <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If
            the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the
            Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the
            built-in Administrator ( <c>RunAs administrator</c>) for this function to succeed.
            </para>
            <para>Any file installation or service provider-specific configuration must be performed by the calling application.</para>
            <para>
            If the WSCInstallProvider or WSCInstallProviderAndChains function is used, the function must be called once to install the
            provider in the 32-bit catalog and once to install the provider in the 64-bit catalog on a 64-bit platform.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCInstallProviderAndChains64_32(System.Guid@,System.String,System.String,Vanara.PInvoke.Ws2_32.XP1,Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW[],System.UInt32,System.UInt32@,System.Int32@)">
            <summary>
            <para>A pointer to a provider-specific, globally unique identifier (GUID).</para>
            <para>
            A pointer to a Unicode string containing the load path to the provider's DLL. This string observes the usual rules for path
            resolution and can contain embedded environment strings (%SystemRoot%, for example). Such environment strings are expanded
            whenever Ws2_32.dll subsequently loads the provider DLL on behalf of an application. After any embedded environment strings are
            expanded, Ws2_32.dll passes the resulting string into the LoadLibrary function to load the provider into memory. For more
            information, see <c>LoadLibrary</c>.
            </para>
            <para>A pointer to a Unicode string that contains the name of the socket provider.</para>
            <para>The service flags for the type of "dummy" catalog entry to be created.</para>
            <para>
            A dummy entry is a WSAProtocol_Info structure with the <c>ChainLen</c> member set to 0. The actual LSP catalog entry will
            reference the ID of this dummy entry in its <c>ProtocolChain</c> member.
            </para>
            <para>The possible flags that can be set for this parameter are as follows:</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>XP1_IFS_HANDLES</term>
            <term>
            The catalog entry is for an Installable File System (IFS) LSP, which returns IFS-specific socket handles. These handles are
            returned directly to the calling application. An IFS LSP cannot intercept the completion of Winsock calls, and does not have to
            have all Winsock functions implemented or available on it.
            </term>
            </item>
            </list>
            <para>
            A pointer to an array of WSAProtocol_Info structures. Each structure defines a protocol, address family, and socket type
            supported by the provider. The members of the <c>WSAPROTOCOL_INFO</c> structure that are examined are <c>iProtocol</c>,
            <c>iAddressFamily</c>, and <c>iSocketType</c>.
            </para>
            <para>The number of entries in the lpProtocolInfoList array.</para>
            <para>
            Receives a pointer to the newly-installed "dummy" entry for the transport provider in the Winsock 2 system configuration
            database. This ID is used to install the catalog entries for the LSP.
            </para>
            <para>A pointer that receives an error code generated by the call if the function fails.</para>
            </summary>
            <param name="lpProviderId">A pointer to a provider-specific, globally unique identifier (GUID).</param>
            <param name="lpszProviderDllPath">
            A pointer to a Unicode string containing the load path to the provider's DLL. This string observes the usual rules for path
            resolution and can contain embedded environment strings (%SystemRoot%, for example). Such environment strings are expanded
            whenever Ws2_32.dll subsequently loads the provider DLL on behalf of an application. After any embedded environment strings are
            expanded, Ws2_32.dll passes the resulting string into the LoadLibrary function to load the provider into memory. For more
            information, see <c>LoadLibrary</c>.
            </param>
            <param name="lpszLspName">A pointer to a Unicode string that contains the name of the socket provider.</param>
            <param name="dwServiceFlags">
            <para>The service flags for the type of "dummy" catalog entry to be created.</para>
            <para>
            A dummy entry is a WSAProtocol_Info structure with the <c>ChainLen</c> member set to 0. The actual LSP catalog entry will
            reference the ID of this dummy entry in its <c>ProtocolChain</c> member.
            </para>
            <para>The possible flags that can be set for this parameter are as follows:</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>XP1_IFS_HANDLES</term>
            <term>
            The catalog entry is for an Installable File System (IFS) LSP, which returns IFS-specific socket handles. These handles are
            returned directly to the calling application. An IFS LSP cannot intercept the completion of Winsock calls, and does not have to
            have all Winsock functions implemented or available on it.
            </term>
            </item>
            </list>
            </param>
            <param name="lpProtocolInfoList">
            A pointer to an array of WSAProtocol_Info structures. Each structure defines a protocol, address family, and socket type
            supported by the provider. The members of the <c>WSAPROTOCOL_INFO</c> structure that are examined are <c>iProtocol</c>,
            <c>iAddressFamily</c>, and <c>iSocketType</c>.
            </param>
            <param name="dwNumberOfEntries">The number of entries in the lpProtocolInfoList array.</param>
            <param name="lpdwCatalogEntryId">
            Receives a pointer to the newly-installed "dummy" entry for the transport provider in the Winsock 2 system configuration
            database. This ID is used to install the catalog entries for the LSP.
            </param>
            <param name="lpErrno">A pointer that receives an error code generated by the call if the function fails.</param>
            <returns>
            <para>
            If <c>WSCInstallProviderAndChains</c> succeeds, it returns zero. Otherwise, it returns <c>SOCKET_ERROR</c>, and a specific error
            code is returned in the lpErrno parameter.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>One or more of the arguments is not in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            One or more of the arguments are invalid. This error is returned for the following conditions: the lpProviderId parameter is
            **NULL**, the lpszProviderDllPath parameter is invalid or the path length is too large (**MAX_PATH** was exceeded), the
            lpszLspName parameter is invalid or the name length is too large (**WSAPROTOCOL_LEN** is exceeded), the lpProtocolInfoList is
            set to a non-**NULL** and the dwNumberOfEntries parameter is zero, a duplicate provider ID or the layered service provider name
            already exist in the catalog, or a match cannot be found for the specified protocol, address family, and socket type.
            </term>
            </item>
            <item>
            <term>WSAEINPROGRESS</term>
            <term>A provider installation is already in progress.</term>
            </item>
            <item>
            <term>WSAEINVALIDPROCTABLE</term>
            <term>The provider is missing required functionality.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>Memory cannot be allocated for buffers.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred. This error is returned under several conditions including the following: the provider is
            already installed, the lpProtocolInfoList parameter was **NULL** and there was no base provider found, the maximum protocol
            chain length (**MAX_PROTOCOL_CHAIN**) was reached, the user lacks the administrative privileges required to write to the Winsock
            registry, or a failure occurred when creating or installing a catalog entry.
            </term>
            </item>
            <item>
            <term>WSASYSCALLFAILURE</term>
            <term>A system call that should never fail has failed.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>WSCInstallProviderAndChains</c> is an enhanced version of the basic WSCInstallProvider function used to install a single
            transport service provider. If a layered service provider is being installed, then <c>WSCInstallProviderAndChains</c> should be
            used. <c>WSCInstallProviderAndChains</c> can install a layered protocol and one or more protocol chains with a single function
            call. To accomplish the same work using <c>WSCInstallProvider</c> would require multiple function calls.
            </para>
            <para>
            Winsock 2 accommodates layered protocols. A layered protocol is one that implements only higher level communications functions
            while relying on an underlying transport stack for the actual exchange of data with a remote endpoint. An example of a layered
            protocol would be a security layer that adds a protocol to the connection establishment process in order to perform
            authentication and to establish a mutually agreed upon encryption scheme. Such a security protocol would generally require the
            services of an underlying reliable transport protocol such as TCP or SPX. The term base protocol refers to a protocol such as
            TCP or SPX which is capable of performing data communications with a remote endpoint. The term layered protocol is used to
            describe a protocol that cannot stand alone. A protocol chain would then be defined as one or more layered protocols strung
            together and anchored by a base protocol. A base protocol has the <c>ChainLen</c> member of the WSAProtocol_Info structure set
            to <c>BASE_PROTOCOL</c> which is defined to be 1. A layered protocol has the <c>ChainLen</c> member of the
            <c>WSAPROTOCOL_INFO</c> structure set to <c>LAYERED_PROTOCOL</c> which is defined to be zero. A protocol chain has the
            <c>ChainLen</c> member of the <c>WSAPROTOCOL_INFO</c> structure set to greater than 1.
            </para>
            <para>
            If lpProtocolInfoList is set to <c>NULL</c>, this function creates protocol chains where the provider is layered over the base
            protocol for each unique protocol type as defined by the address family, socket type, and protocol. This eliminates the creation
            of any inaccessible duplicate provider entries.
            </para>
            <para>
            If lpProtocolInfoList is set to a non- <c>NULL</c> value, this function creates protocol chains by obtaining the top-most entry
            in the configuration information that matches the address family, socket type, and protocol from each element in the provided
            array. Again, only the address family, socket type, and protocol are considered; all other members and duplicates are ignored.
            </para>
            <para>
            Upon successful completion of this call, any subsequent calls to WSAEnumProtocols or WSCEnumProtocols will return the
            newly-created protocol chain entries. Be aware that in Windows environments, only instances of Ws_32.dll created by calling
            WSAStartup after the successful completion of <c>WSCInstallProviderAndChains</c> will include the new entries when
            <c>WSAEnumProtocols</c> and <c>WSCEnumProtocols</c> returns.
            </para>
            <para>
            On success, <c>WSCInstallProviderAndChains</c> will attempt to alert all interested applications that have registered for
            notification of the change by calling WSAProviderConfigChange.
            </para>
            <para>
            The <c>WSCInstallProviderAndChains</c> function can only be called by a user logged on as a member of the Administrators group.
            If <c>WSCInstallProviderAndChains</c> is called by a user that is not a member of the Administrators group, the function call
            will fail and WSANO_RECOVERY is returned in the lpErrno parameter. For computers running Windows Vista or Windows Server 2008,
            this function can also fail because of user account control (UAC). If an application that contains this function is executed by
            a user logged on as a member of the Administrators group other than the built-in Administrator, this call will fail unless the
            application has been marked in the manifest file with a <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If
            the application on Windows Vista or Windows Server 2008 lacks this manifest file, a user logged on as a member of the
            Administrators group other than the built-in Administrator must then be executing the application in an enhanced shell as the
            built-in Administrator ( <c>RunAs administrator</c>) for this function to succeed.
            </para>
            <para>Any file installation or provider-specific configuration must be performed by the calling application.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCSetApplicationCategory(System.String,System.UInt32,System.String,System.UInt32,System.UInt32,System.UInt32@,System.Int32@)">
            <summary>
            <para>
            A pointer to a Unicode string that contains the load path to the executable image for the application. This string observes the
            usual rules for path resolution and can contain embedded environment strings (such as %SystemRoot%).
            </para>
            <para>The length, in characters, of the Path parameter. This length does not include the terminating <c>NULL</c>.</para>
            <para>
            A pointer to a Unicode string which represents the command line arguments used when starting the application specified in the
            Path parameter. The Extra parameter is used to distinguish between multiple, distinct instances of an application when launched
            with a consistent command line. This is to support different application categorizations for different instances of Svchost.exe
            or Rundll32.exe. If only the Path parameter is required and no command line arguments are needed to further distinguish between
            instances of an application, then the Extra parameter should be set to <c>NULL</c>.
            </para>
            <para>The length, in characters, of the Extra parameter. This length does not include the terminating <c>NULL</c>.</para>
            <para>
            A DWORD value of the LSP categories which are permitted for all instances of this application. The application is identified by
            the combination of the values of the Path and Extra parameters.
            </para>
            <para>
            A pointer to receive the previous set of permitted LSP categories which were permitted for all instances of this application.
            This parameter is optional can be <c>NULL</c>.
            </para>
            <para>A pointer to the error code if the function fails.</para>
            </summary>
            <param name="Path">
            A pointer to a Unicode string that contains the load path to the executable image for the application. This string observes the
            usual rules for path resolution and can contain embedded environment strings (such as %SystemRoot%).
            </param>
            <param name="PathLength">The length, in characters, of the Path parameter. This length does not include the terminating <c>NULL</c>.</param>
            <param name="Extra">
            A pointer to a Unicode string which represents the command line arguments used when starting the application specified in the
            Path parameter. The Extra parameter is used to distinguish between multiple, distinct instances of an application when launched
            with a consistent command line. This is to support different application categorizations for different instances of Svchost.exe
            or Rundll32.exe. If only the Path parameter is required and no command line arguments are needed to further distinguish between
            instances of an application, then the Extra parameter should be set to <c>NULL</c>.
            </param>
            <param name="ExtraLength">The length, in characters, of the Extra parameter. This length does not include the terminating <c>NULL</c>.</param>
            <param name="PermittedLspCategories">
            A DWORD value of the LSP categories which are permitted for all instances of this application. The application is identified by
            the combination of the values of the Path and Extra parameters.
            </param>
            <param name="pPrevPermLspCat">
            A pointer to receive the previous set of permitted LSP categories which were permitted for all instances of this application.
            This parameter is optional can be <c>NULL</c>.
            </param>
            <param name="lpErrno">A pointer to the error code if the function fails.</param>
            <returns>
            <para>
            If no error occurs, <c>WSCSetApplicationCategory</c> returns <c>ERROR_SUCCESS</c> (zero). Otherwise, it returns
            <c>SOCKET_ERROR</c>, and a specific error code is returned in the lpErrno parameter.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>One or more of the arguments is not in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more of the arguments are invalid.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the
            administrative privileges required to access the Winsock registry, or a failure occurred when opening a Winsock catalog entry or
            an application ID entry.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>WSCSetApplicationCategory</c> is used to set the LSP category flags associated with an application instance. Applications can
            determine which LSP behaviors are acceptable within the application's context. Therefore, through specifying permitted LSP
            categories, an application can permit only those layered service providers which implement acceptable behaviors to be loaded.
            </para>
            <para>
            The Extra parameter is required when the command line is used to distinguish between different instances of an application or
            service hosted within the same executable. Each instance can have different application categorization needs. Svchost.exe and
            Rundll32.exe are two examples where the command line is required to differentiate between different process instances. For
            SvcHost.exe, the <c>-k &lt;svcinstance&gt;</c> switch defines the process instance.
            </para>
            <para>
            For services, using the Service Name is not sufficient, because the Winsock Catalog is global to a given process, and a process
            may host several services.
            </para>
            <para>
            If the <c>WSCSetApplicationCategory</c> function is called on the same application (the same fullpath, EXE name, and parameters)
            multiple times, then the categories are ORed together. For example if you categorized "c:\foo.exe -param" with LSP_SYSTEM and
            then called the <c>WSCSetApplicationCategory</c> function again with LSP_REDIRECTOR, the resulting entry for htis application
            contains LSP_SYSTEM | LSP_REDIRECTOR. This behavior is designed to support a single executable file that hosts multiple
            applications in a single EXE (the Windows system services svchost.exe, for example).
            </para>
            <para>
            Window sockets determine an application's identity and retrieves the permitted LSP categories during the first call to
            WSAStartup. This will be the set of permitted LSP categories for the duration of the application instance. Subsequent changes to
            the permitted LSP categories for a given application identity will not be picked up until the next instance of the application.
            The permitted LSP categories is not mutable during the lifetime of the application instance.
            </para>
            <para>
            Winsock 2 accommodates layered protocols. A layered protocol is one that implements only higher level communications functions,
            while relying on an underlying transport stack for the actual exchange of data with a remote endpoint. An example of a layered
            protocol or layered service provider would be a security layer that adds protocol to the connection establishment process in
            order to perform authentication and to establish a mutually agreed upon encryption scheme. Such a security protocol would
            generally require the services of an underlying reliable transport protocol such as TCP or SPX. The term base protocol refers to
            a protocol such as TCP or SPX which is capable of performing data communications with a remote endpoint. The term layered
            protocol is used to describe a protocol that cannot stand alone.
            </para>
            <para>
            During LSP initialization, the LSP must provide pointers to a number of Winsock SPI functions. These functions will be called
            during normal processing by the layer directly above the LSP (either another LSP or Ws2_32.dll).
            </para>
            <para>
            An LSP that implements an installable file system (IFS) can selectively choose to provide pointers to functions which are
            implemented by itself, or pass back the pointers provided by the layer directly below the LSP. Non-IFS LSPs, because they
            provide their own handles, must implement all of the Winsock SPI functions. This is because each SPI will require the LSP to map
            all of the socket handles it created to the socket handle of the lower provider (either another LSP or the base protocol).
            </para>
            <para>However, all LSPs perform their specific work by doing extra processing on only a subset of the Winsock SPI functions.</para>
            <para>
            It is possible to define LSP categories based upon the subset of SPI functions an LSP implements and the nature of the extra
            processing performed for each of those functions.
            </para>
            <para>
            By classifying LSPs, as well as classifying applications which use Winsock sockets, it becomes possible to selectively determine
            if an LSP should be involved in a given process at runtime.
            </para>
            <para>
            On Windows Vista and later, an LSP can be classified based on how it interacts with Windows Sockets calls and data. An LSP
            category is an identifiable group of behaviors on a subset of Winsock SPI functions. For example, an HTTP content filter would
            be categorized as a data inspector (the <c>LSP_INSPECTOR</c> category). The <c>LSP_INSPECTOR</c> category will inspect (but not
            alter) parameters to data transfer SPI functions. An application can query for the category of an LSP and choose to not load the
            LSP based on the LSP category and the application's set of permitted LSP categories.
            </para>
            <para>The following table lists categories into which an LSP can be classified.</para>
            <list type="table">
            <listheader>
            <term>LSP Category</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>**LSP_CRYPTO_COMPRESS**</term>
            <term>The LSP is a cryptography or data compression provider.</term>
            </item>
            <item>
            <term>**LSP_FIREWALL**</term>
            <term>The LSP is a firewall provider.</term>
            </item>
            <item>
            <term>**LSP_LOCAL_CACHE**</term>
            <term>The LSP is a local cache provider.</term>
            </item>
            <item>
            <term>**LSP_INBOUND_MODIFY**</term>
            <term>The LSP modifies inbound data.</term>
            </item>
            <item>
            <term>**LSP_INSPECTOR**</term>
            <term>The LSP inspects or filters data.</term>
            </item>
            <item>
            <term>**LSP_OUTBOUND_MODIFY**</term>
            <term>The LSP modifies outbound data.</term>
            </item>
            <item>
            <term>**LSP_PROXY**</term>
            <term>The LSP acts as a proxy and redirects packets.</term>
            </item>
            <item>
            <term>**LSP_REDIRECTOR**</term>
            <term>The LSP is a network redirector.</term>
            </item>
            <item>
            <term>**LSP_SYSTEM**</term>
            <term>The LSP is acceptable for use in services and system processes.</term>
            </item>
            </list>
            <para>
            An LSP may belong to more than one category. For example, a firewall/security LSP could belong to both the inspector (
            <c>LSP_INSPECTOR</c>) and firewall ( <c>LSP_FIREWALL</c>) categories.
            </para>
            <para>
            If an LSP does not have a category set, it is considered to be in the All Other category. This LSP category will not be loaded
            in services or system processes (for example, lsass, winlogon, and many svchost processes).
            </para>
            <para>
            The <c>WSCSetApplicationCategory</c> function can only be called by a user logged on as a member of the Administrators group. If
            <c>WSCSetApplicationCategory</c> is called by a user that is not a member of the Administrators group, the function call will
            fail and <c>WSANO_RECOVERY</c> is returned in the lpErrno parameter. This function can also fail because of user account control
            (UAC). If an application that contains this function is executed by a user logged on as a member of the Administrators group
            other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a
            <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If the application on Windows Vista or Windows Server 2008
            lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must
            then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
            </para>
            <para>Any file installation or service provider-specific configuration must be performed by the caller.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCSetProviderInfo(System.Guid@,Vanara.PInvoke.Ws2_32.WSC_PROVIDER_INFO_TYPE,System.IntPtr,Vanara.PInvoke.SizeT,System.UInt32,System.Int32@)">
            <summary>
            <para>A pointer to a globally unique identifier (GUID) for the provider.</para>
            <para>The information class to be set for this LSP protocol entry.</para>
            <para>A pointer to a buffer that contains the information class data to set for the LSP protocol entry.</para>
            <para>The size, in bytes, of the buffer pointed to by the Info parameter.</para>
            <para>The flags used to modify the behavior of the <c>WSCSetProviderInfo</c> function call.</para>
            <para>A pointer to the error code if the function fails.</para>
            </summary>
            <param name="lpProviderId">A pointer to a globally unique identifier (GUID) for the provider.</param>
            <param name="InfoType">The information class to be set for this LSP protocol entry.</param>
            <param name="Info">A pointer to a buffer that contains the information class data to set for the LSP protocol entry.</param>
            <param name="InfoSize">The size, in bytes, of the buffer pointed to by the Info parameter.</param>
            <param name="Flags">The flags used to modify the behavior of the <c>WSCSetProviderInfo</c> function call.</param>
            <param name="lpErrno">A pointer to the error code if the function fails.</param>
            <returns>
            <para>
            If no error occurs, <c>WSCSetProviderInfo</c> returns <c>ERROR_SUCCESS</c> (zero). Otherwise, it returns <c>SOCKET_ERROR</c>,
            and a specific error code is returned in the lpErrno parameter.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ERROR_CALL_NOT_IMPLEMENTED</term>
            <term>The call is not implemented. This error is returned if **ProviderInfoAudit** is specified in the InfoType parameter.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>One or more of the arguments is not in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more of the arguments are invalid.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the
            administrative privileges required to write to the Winsock registry, or a failure occurred when opening a Winsock catalog entry.
            </term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>
            Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>WSCSetProviderInfo</c> is used to set the information class data for a layered service provider. When the InfoType parameter
            is set to <c>ProviderInfoLspCategories</c>, on success <c>WSCSetProviderInfo</c> sets appropriate LSP category flags implemented
            by the provider based on the value passed in the Info parameter.
            </para>
            <para>
            Winsock 2 accommodates layered protocols. A layered protocol is one that implements only higher level communications functions,
            while relying on an underlying transport stack for the actual exchange of data with a remote endpoint. An example of a layered
            protocol or layered service provider would be a security layer that adds protocol to the connection establishment process in
            order to perform authentication and to establish a mutually agreed upon encryption scheme. Such a security protocol would
            generally require the services of an underlying reliable transport protocol such as TCP or SPX. The term base protocol refers to
            a protocol such as TCP or SPX which is capable of performing data communications with a remote endpoint. The term layered
            protocol is used to describe a protocol that cannot stand alone. A protocol chain would then be defined as one or more layered
            protocols strung together and anchored by a base protocol. A base protocol has the <c>ChainLen</c> member of the
            WSAPROTOCOL_INFO structure set to <c>BASE_PROTOCOL</c> which is defined to be 1. A layered protocol has the <c>ChainLen</c>
            member of the <c>WSAPROTOCOL_INFO</c> structure set to <c>LAYERED_PROTOCOL</c> which is defined to be zero. A protocol chain has
            the <c>ChainLen</c> member of the <c>WSAPROTOCOL_INFO</c> structure set to greater than 1.
            </para>
            <para>
            During LSP initialization, the LSP must provide pointers to a number of Winsock SPI functions. These functions will be called
            during normal processing by the layer directly above the LSP (either another LSP or Ws2_32.dll).
            </para>
            <para>
            An LSP that implements an installable file system (IFS) can selectively choose to provide pointers to functions which are
            implemented by itself, or pass back the pointers provided by the layer directly below the LSP. Non-IFS LSPs, because they
            provide their own handles, must implement all of the Winsock SPI functions. This is because each SPI will require the LSP to map
            all of the socket handles it created to the socket handle of the lower provider (either another LSP or the base protocol).
            </para>
            <para>However, all LSPs perform their specific work by doing extra processing on only a subset of the Winsock SPI functions.</para>
            <para>
            It is possible to define LSP categories based upon the subset of SPI functions an LSP implements and the nature of the extra
            processing performed for each of those functions.
            </para>
            <para>
            By classifying LSPs, as well as classifying applications which use Winsock sockets, it becomes possible to selectively determine
            if an LSP should be involved in a given process at runtime.
            </para>
            <para>
            On Windows Vista and later, an LSP can be classified based on how it interacts with Windows Sockets calls and data. An LSP
            category is an identifiable group of behaviors on a subset of Winsock SPI functions. For example, an HTTP content filter would
            be categorized as a data inspector (the <c>LSP_INSPECTOR</c> category). The <c>LSP_INSPECTOR</c> category will inspect, but not
            alter, parameters to data transfer SPI functions. An application can query for the category of an LSP and choose to not load the
            LSP based on the LSP category and the application's set of permitted LSP categories.
            </para>
            <para>The following table lists categories into which an LSP can be classified.</para>
            <list type="table">
            <listheader>
            <term>LSP Category</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>**LSP_CRYPTO_COMPRESS**</term>
            <term>The LSP is a cryptography or data compression provider.</term>
            </item>
            <item>
            <term>**LSP_FIREWALL**</term>
            <term>The LSP is a firewall provider.</term>
            </item>
            <item>
            <term>**LSP_LOCAL_CACHE**</term>
            <term>The LSP is a local cache provider.</term>
            </item>
            <item>
            <term>**LSP_INBOUND_MODIFY**</term>
            <term>The LSP modifies inbound data.</term>
            </item>
            <item>
            <term>**LSP_INSPECTOR**</term>
            <term>The LSP inspects or filters data.</term>
            </item>
            <item>
            <term>**LSP_OUTBOUND_MODIFY**</term>
            <term>The LSP modifies outbound data.</term>
            </item>
            <item>
            <term>**LSP_PROXY**</term>
            <term>The LSP acts as a proxy and redirects packets.</term>
            </item>
            <item>
            <term>**LSP_REDIRECTOR**</term>
            <term>The LSP is a network redirector.</term>
            </item>
            <item>
            <term>**LSP_SYSTEM**</term>
            <term>The LSP is acceptable for use in services and system processes.</term>
            </item>
            </list>
            <para>
            An LSP may belong to more than one category. For example, firewall/security LSP could belong to both the inspector
            (**LSP_INSPECTOR**) and firewall (**LSP_FIREWALL**) categories.
            </para>
            <para>
            If an LSP does not have category set, it is considered to be in the All Other category. This LSP category will not be loaded in
            services or system processes (for example, lsass, winlogon, and many svchost processes).
            </para>
            <para>
            The <c>WSCSetProviderInfo</c> function can only be called by a user logged on as a member of the Administrators group. If
            <c>WSCSetProviderInfo</c> is called by a user that is not a member of the Administrators group, the function call will fail and
            <c>WSANO_RECOVERY</c> is returned in the lpErrno parameter. This function can also fail because of user account control (UAC).
            If an application that contains this function is executed by a user logged on as a member of the Administrators group other than
            the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a
            <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If the application on Windows Vista or Windows Server 2008
            lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must
            then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
            </para>
            <para>
            **Note** The TDI feature is deprecated and will be removed in future versions of Microsoft Windows. Depending on how you use
            TDI, use either the Winsock Kernel (WSK) or Windows Filtering Platform (WFP). For more information about WFP and WSK, see
            Windows Filtering Platform and Winsock Kernel. For a Windows Core Networking blog entry about WSK and TDI, see Introduction to
            Winsock Kernel (WSK).
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCSetProviderInfo32(System.Guid@,Vanara.PInvoke.Ws2_32.WSC_PROVIDER_INFO_TYPE,System.IntPtr,Vanara.PInvoke.SizeT,System.UInt32,System.Int32@)">
            <summary>
            <para>A pointer to a globally unique identifier (GUID) for the provider.</para>
            <para>The information class to be set for this LSP protocol entry.</para>
            <para>A pointer to a buffer that contains the information class data to set for the LSP protocol entry.</para>
            <para>The size, in bytes, of the buffer pointed to by the Info parameter.</para>
            <para>The flags used to modify the behavior of the <c>WSCSetProviderInfo32</c> function call.</para>
            <para>A pointer to the error code if the function fails.</para>
            </summary>
            <param name="lpProviderId">A pointer to a globally unique identifier (GUID) for the provider.</param>
            <param name="InfoType">The information class to be set for this LSP protocol entry.</param>
            <param name="Info">A pointer to a buffer that contains the information class data to set for the LSP protocol entry.</param>
            <param name="InfoSize">The size, in bytes, of the buffer pointed to by the Info parameter.</param>
            <param name="Flags">The flags used to modify the behavior of the <c>WSCSetProviderInfo32</c> function call.</param>
            <param name="lpErrno">A pointer to the error code if the function fails.</param>
            <returns>
            <para>
            If no error occurs, <c>WSCSetProviderInfo32</c> returns <c>ERROR_SUCCESS</c> (zero). Otherwise, it returns <c>SOCKET_ERROR</c>,
            and a specific error code is returned in the lpErrno parameter.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>ERROR_CALL_NOT_IMPLEMENTED</term>
            <term>The call is not implemented. This error is returned if **ProviderInfoAudit** is specified in the InfoType parameter.</term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>One or more of the arguments is not in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more of the arguments are invalid.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the
            administrative privileges required to write to the Winsock registry, or a failure occurred when opening a Winsock catalog entry.
            </term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>
            Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>WSCSetProviderInfo32</c> is a strictly 32-bit version of WSCSetProviderInfo. On a 64-bit computer, all calls not specifically
            32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that execute on a
            64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve compatibility.
            The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
            </para>
            <para>
            <c>WSCSetProviderInfo32</c> is used to set the information class data for a 32-bit layered service provider. When the InfoType
            parameter is set to <c>ProviderInfoLspCategories</c>, on success <c>WSCSetProviderInfo32</c> sets appropriate LSP category flags
            implemented by the provider based on the value passed in the Info parameter.
            </para>
            <para>
            Winsock 2 accommodates layered protocols. A layered protocol is one that implements only higher level communications functions,
            while relying on an underlying transport stack for the actual exchange of data with a remote endpoint. An example of a layered
            protocol or layered service provider would be a security layer that adds protocol to the connection establishment process in
            order to perform authentication and to establish a mutually agreed upon encryption scheme. Such a security protocol would
            generally require the services of an underlying reliable transport protocol such as TCP or SPX. The term base protocol refers to
            a protocol such as TCP or SPX which is capable of performing data communications with a remote endpoint. The term layered
            protocol is used to describe a protocol that cannot stand alone. A protocol chain would then be defined as one or more layered
            protocols strung together and anchored by a base protocol. A base protocol has the <c>ChainLen</c> member of the
            WSAProtocol_Info structure set to <c>BASE_PROTOCOL</c> which is defined to be 1. A layered protocol has the <c>ChainLen</c>
            member of the <c>WSAPROTOCOL_INFO</c> structure set to <c>LAYERED_PROTOCOL</c> which is defined to be zero. A protocol chain has
            the <c>ChainLen</c> member of the <c>WSAPROTOCOL_INFO</c> structure set to greater than 1.
            </para>
            <para>
            During LSP initialization, the LSP must provide pointers to a number of Winsock SPI functions. These functions will be called
            during normal processing by the layer directly above the LSP (either another LSP or Ws2_32.dll).
            </para>
            <para>
            An LSP that implements an installable file system (IFS) can selectively choose to provide pointers to functions which are
            implemented by itself, or pass back the pointers provided by the layer directly below the LSP. Non-IFS LSPs, because they
            provide their own handles, must implement all of the Winsock SPI functions. This is because each SPI will require the LSP to map
            all of the socket handles it created to the socket handle of the lower provider (either another LSP or the base protocol).
            </para>
            <para>However, all LSPs perform their specific work by doing extra processing on only a subset of the Winsock SPI functions.</para>
            <para>
            It is possible to define LSP categories based upon the subset of SPI functions an LSP implements and the nature of the extra
            processing performed for each of those functions.
            </para>
            <para>
            By classifying LSPs, as well as classifying applications which use Winsock sockets, it becomes possible to selectively determine
            if an LSP should be involved in a given process at runtime.
            </para>
            <para>
            On Windows Vista and later, an LSP can be classified based on how it interacts with Windows Sockets calls and data. An LSP
            category is an identifiable group of behaviors on a subset of Winsock SPI functions. For example, an HTTP content filter would
            be categorized as a data inspector (the <c>LSP_INSPECTOR</c> category). The <c>LSP_INSPECTOR</c> category will inspect, but not
            alter, parameters to data transfer SPI functions. An application can query for the category of an LSP and choose to not load the
            LSP based on the LSP category and the application's set of permitted LSP categories.
            </para>
            <para>The following table lists categories into which an LSP can be classified.</para>
            <list type="table">
            <listheader>
            <term>LSP Category</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>**LSP_CRYPTO_COMPRESS**</term>
            <term>The LSP is a cryptography or data compression provider.</term>
            </item>
            <item>
            <term>**LSP_FIREWALL**</term>
            <term>The LSP is a firewall provider.</term>
            </item>
            <item>
            <term>**LSP_LOCAL_CACHE**</term>
            <term>The LSP is a local cache provider.</term>
            </item>
            <item>
            <term>**LSP_INBOUND_MODIFY**</term>
            <term>The LSP modifies inbound data.</term>
            </item>
            <item>
            <term>**LSP_INSPECTOR**</term>
            <term>The LSP inspects or filters data.</term>
            </item>
            <item>
            <term>**LSP_OUTBOUND_MODIFY**</term>
            <term>The LSP modifies outbound data.</term>
            </item>
            <item>
            <term>**LSP_PROXY**</term>
            <term>The LSP acts as a proxy and redirects packets.</term>
            </item>
            <item>
            <term>**LSP_REDIRECTOR**</term>
            <term>The LSP is a network redirector.</term>
            </item>
            <item>
            <term>**LSP_SYSTEM**</term>
            <term>The LSP is acceptable for use in services and system processes.</term>
            </item>
            </list>
            <para>
            An LSP may belong to more than one category. For example, firewall/security LSP could belong to both the inspector (
            <c>LSP_INSPECTOR</c>) and firewall ( <c>LSP_FIREWALL</c>) categories.
            </para>
            <para>
            If an LSP does not have category set, it is considered to be in the All Other category. This LSP category will not be loaded in
            services or system processes (for example, lsass, winlogon, and many svchost processes).
            </para>
            <para>
            The <c>WSCSetProviderInfo32</c> function can only be called by a user logged on as a member of the Administrators group. If
            <c>WSCSetProviderInfo32</c> is called by a user that is not a member of the Administrators group, the function call will fail
            and <c>WSANO_RECOVERY</c> is returned in the lpErrno parameter. This function can also fail because of user account control
            (UAC). If an application that contains this function is executed by a user logged on as a member of the Administrators group
            other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a
            <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If the application on Windows Vista or Windows Server 2008
            lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must
            then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCUnInstallNameSpace(System.Guid@)">
            <summary>The <c>WSCUnInstallNameSpace</c> function uninstalls the indicated name-space provider.</summary>
            <param name="lpProviderId">A pointer to a globally unique identifier (GUID) for the name-space provider to be uninstalled.</param>
            <returns>
            <para>
            If no error occurs, <c>WSCUnInstallNameSpace</c> returns <c>NO_ERROR</c> (zero). Otherwise, it returns <c>SOCKET_ERROR</c> if
            the function fails, and you must retrieve the appropriate error code using the WSAGetLastError function.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>The lpProviderId parameter points to memory that is not in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>The specified namespaceprovider identifier is invalid.</term>
            </item>
            <item>
            <term>WSASYSCALLFAILURE</term>
            <term>A system call that should never fail has failed.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>
            Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The namespace configuration functions do not affect applications that are already running. Newly installed name-space providers
            will not be visible to applications nor will the changes in a name-space provider's activation state. Applications launched
            after the call to <c>WSCUnInstallNameSpace</c> will see the changes.
            </para>
            <para>
            On success, <c>WSCUnInstallNameSpace</c> will attempt to alert all interested applications that have registered for notification
            of the change by calling WSAProviderConfigChange.
            </para>
            <para>
            The <c>WSCUnInstallNameSpace</c> function can only be called by a user logged on as a member of the Administrators group. If
            <c>WSCUnInstallNameSpace</c> is called by a user that is not a member of the Administrators group, the function call will fail
            and <c>WSANO_RECOVERY</c> is returned in the lpErrno parameter.
            </para>
            <para>
            For computers running on Windows Vista or Windows Server 2008, this function can also fail because of user account control
            (UAC). If an application that contains this function is executed by a user logged on as a member of the Administrators group
            other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a
            <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If the application on Windows Vista or Windows Server 2008
            lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must
            then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
            </para>
            <para>
            The caller of this function must remove any additional files or service providerspecific configuration information that is
            required to completely uninstall the service provider.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCUnInstallNameSpace32(System.Guid@)">
            <summary>The <c>WSCUnInstallNameSpace32</c> function uninstalls a specific 32-bit namespace provider.</summary>
            <param name="lpProviderId">A pointer to a globally unique identifier (GUID) for the name-space provider to be uninstalled.</param>
            <returns>
            <para>
            If no error occurs, <c>WSCUnInstallNameSpace32</c> returns <c>NO_ERROR</c> (zero). Otherwise, it returns <c>SOCKET_ERROR</c> if
            the function fails, and you must retrieve the appropriate error code using the WSAGetLastError function.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>The lpProviderId parameter points to memory that is not in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>The specified namespaceprovider identifier is invalid.</term>
            </item>
            <item>
            <term>WSASYSCALLFAILURE</term>
            <term>A system call that should never fail has failed.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>
            Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>WSCUnInstallNameSpace32</c> is a strictly 32-bit version of WSCUnInstallNameSpace. On a 64-bit computer, all calls not
            specifically 32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that
            execute on a 64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve
            compatibility. The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
            </para>
            <para>
            The namespace configuration functions do not affect applications that are already running. Newly installed name-space providers
            will not be visible to applications nor will the changes in a name-space provider's activation state. Applications launched
            after the call to <c>WSCUnInstallNameSpace32</c> will recognize the changes.
            </para>
            <para>
            On success, <c>WSCUnInstallNameSpace32</c> will attempt to alert all interested applications that have registered for
            notification of the change by calling WSAProviderConfigChange.
            </para>
            <para>
            The <c>WSCUnInstallNameSpace32</c> function can only be called by a user logged on as a member of the Administrators group. If
            <c>WSCUnInstallNameSpace32</c> is called by a user that is not a member of the Administrators group, the function call will fail
            and <c>WSANO_RECOVERY</c> is returned in the lpErrno parameter.
            </para>
            <para>
            For computers running on Windows Vista or Windows Server 2008, this function can also fail because of user account control
            (UAC). If an application that contains this function is executed by a user logged on as a member of the Administrators group
            other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a
            <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If the application on Windows Vista or Windows Server 2008
            lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must
            then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
            </para>
            <para>
            The caller of this function must remove any additional files or service providerspecific configuration information that is
            required to completely uninstall the service provider.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCUpdateProvider(System.Guid@,System.String,Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW[],System.UInt32,System.Int32@)">
            <summary>The <c>WSCUpdateProvider</c> function modifies the specified transport provider in the system configuration database.</summary>
            <param name="lpProviderId">A pointer to a globally unique identifier (GUID) for the provider.</param>
            <param name="lpszProviderDllPath">
            A pointer to a Unicode string that contains the load path to the provider 64-bit DLL. This string observes the usual rules for
            path resolution and can contain embedded environment strings (such as %SystemRoot%). Such environment strings are expanded when
            the Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are
            expanded, the Ws2_32.dll passes the resulting string to the LoadLibrary function which loads the provider into memory. For more
            information, see <c>LoadLibrary</c>.
            </param>
            <param name="lpProtocolInfoList">
            A pointer to an array of WSAProtocol_Info structures. Each structure specifies or modifies a protocol, address family, and
            socket type supported by the provider.
            </param>
            <param name="dwNumberOfEntries">The number of entries in the lpProtocolInfoList array.</param>
            <param name="lpErrno">A pointer to the error code if the function fails.</param>
            <returns>
            <para>
            If no error occurs, <c>WSCUpdateProvider</c> returns zero. Otherwise, it returns <c>SOCKET_ERROR</c>, and a specific error code
            is returned in the lpErrno parameter.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>One or more of the arguments are not in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more of the arguments are invalid.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the
            administrative privileges required to write to the Winsock registry, or a failure occurred when opening or writing a catalog entry.
            </term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>
            Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>WSCUpdateProvider</c> function modifies Windows Sockets 2 configuration information for the specified provider. It is
            applicable to base protocols, layered protocols, and protocol chains.
            </para>
            <para>
            Winsock 2 accommodates layered protocols. A layered protocol is one that implements only higher level communications functions,
            while relying on an underlying transport stack for the actual exchange of data with a remote endpoint. An example of a layered
            protocol would be a security layer that adds protocol to the connection establishment process in order to perform authentication
            and to establish a mutually agreed upon encryption scheme. Such a security protocol would generally require the services of an
            underlying reliable transport protocol such as TCP or SPX. The term base protocol refers to a protocol such as TCP or SPX which
            is capable of performing data communications with a remote endpoint. The term layered protocol is used to describe a protocol
            that cannot stand alone. A protocol chain would then be defined as one or more layered protocols strung together and anchored by
            a base protocol. A base protocol has the <c>ChainLen</c> member of the WSAProtocol_Info structure set to <c>BASE_PROTOCOL</c>
            which is defined to be 1. A layered protocol has the <c>ChainLen</c> member of the <c>WSAPROTOCOL_INFO</c> structure set to
            <c>LAYERED_PROTOCOL</c> which is defined to be zero. A protocol chain has the <c>ChainLen</c> member of the
            <c>WSAPROTOCOL_INFO</c> structure set to greater than 1.
            </para>
            <para>
            On success, <c>WSCUpdateProvider</c> will attempt to alert all interested applications that have registered for notification of
            the change by calling WSAProviderConfigChange.
            </para>
            <para>
            The <c>WSCUpdateProvider</c> function can only be called by a user logged on as a member of the Administrators group. If
            <c>WSCUpdateProvider</c> is called by a user that is not a member of the Administrators group, the function call will fail.
            </para>
            <para>
            For computers running on Windows Vista or Windows Server 2008, this function can also fail because of user account control
            (UAC). If an application that contains this function is executed by a user logged on as a member of the Administrators group
            other than the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a
            <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If the application on Windows Vista or Windows Server 2008
            lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must
            then be executing the application in an enhanced shell as the built-in Administrator (RunAs administrator) for this function to succeed.
            </para>
            <para>Any file installation or service provider-specific configuration must be performed by the caller.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSCUpdateProvider32(System.Guid@,System.String,Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW[],System.UInt32,System.Int32@)">
            <summary>
            The <c>WSCUpdateProvider32</c> function modifies the specified 32-bit transport provider in the system configuration database.
            </summary>
            <param name="lpProviderId">A pointer to a globally unique identifier (GUID) for the provider.</param>
            <param name="lpszProviderDllPath">
            A pointer to a Unicode string that contains the load path to the provider 64-bit DLL. This string observes the usual rules for
            path resolution and can contain embedded environment strings (such as %SystemRoot%). Such environment strings are expanded when
            the Ws2_32.dll must subsequently load the provider DLL on behalf of an application. After any embedded environment strings are
            expanded, the Ws2_32.dll passes the resulting string to the LoadLibrary function which loads the provider into memory. For more
            information, see <c>LoadLibrary</c>.
            </param>
            <param name="lpProtocolInfoList">
            A pointer to an array of WSAProtocol_Info structures. Each structure specifies or modifies a protocol, address family, and
            socket type supported by the provider.
            </param>
            <param name="dwNumberOfEntries">The number of entries in the lpProtocolInfoList array.</param>
            <param name="lpErrno">A pointer to the error code if the function fails.</param>
            <returns>
            <para>
            If no error occurs, <c>WSCUpdateProvider32</c> returns zero. Otherwise, it returns SOCKET_ERROR, and a specific error code is
            available in lpErrno.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>One or more of the arguments is not in a valid part of the user address space.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>One or more of the arguments are invalid.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred. This error is returned under several conditions including the following: the user lacks the
            administrative privileges required to write to the Winsock registry, or a failure occurred when opening or writing a catalog entry.
            </term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>
            Insufficient memory was available. This error is returned when there is insufficient memory to allocate a new catalog entry.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            <c>WSCUpdateProvider32</c> is a strictly 32-bit version of WSCUpdateProvider. On a 64-bit computer, all calls not specifically
            32-bit (for example, all functions that do not end in "32") operate on the native 64-bit catalog. Processes that execute on a
            64-bit computer must use the specific 32-bit function calls to operate on a strictly 32-bit catalog and preserve compatibility.
            The definitions and semantics of the specific 32-bit calls are the same as their native counterparts.
            </para>
            <para>
            This function modifies Windows Sockets 2 configuration information for the specified 32-bit provider. It is applicable to base
            protocols, layered protocols, and protocol chains.
            </para>
            <para>
            Winsock 2 accommodates layered protocols. A layered protocol is one that implements only higher level communications functions,
            while relying on an underlying transport stack for the actual exchange of data with a remote endpoint. An example of a layered
            protocol would be a security layer that adds protocol to the connection establishment process in order to perform authentication
            and to establish a mutually agreed upon encryption scheme. Such a security protocol would generally require the services of an
            underlying reliable transport protocol such as TCP or SPX. The term base protocol refers to a protocol such as TCP or SPX which
            is capable of performing data communications with a remote endpoint. The term layered protocol is used to describe a protocol
            that cannot stand alone. A protocol chain would then be defined as one or more layered protocols strung together and anchored by
            a base protocol. A base protocol has the <c>ChainLen</c> member of the WSAProtocol_Info structure set to <c>BASE_PROTOCOL</c>
            which is defined to be 1. A layered protocol has the <c>ChainLen</c> member of the <c>WSAPROTOCOL_INFO</c> structure set to
            <c>LAYERED_PROTOCOL</c> which is defined to be zero. A protocol chain has the <c>ChainLen</c> member of the
            <c>WSAPROTOCOL_INFO</c> structure set to greater than 1.
            </para>
            <para>
            On success, <c>WSCUpdateProvider32</c> will attempt to alert all interested applications that have registered for notification
            of the change by calling WSAProviderConfigChange.
            </para>
            <para>
            The <c>WSCUpdateProvider32</c> function can only be called by a user logged on as a member of the Administrators group. If
            <c>WSCUpdateProvider32</c> is called by a user that is not a member of the Administrators group, the function call will fail.
            </para>
            <para>
            For computers running Windows Vista or Windows Server 2008, this function can also fail because of user account control (UAC).
            If an application that contains this function is executed by a user logged on as a member of the Administrators group other than
            the built-in Administrator, this call will fail unless the application has been marked in the manifest file with a
            <c>requestedExecutionLevel</c> set to <c>requireAdministrator</c>. If the application on Windows Vista or Windows Server 2008
            lacks this manifest file, a user logged on as a member of the Administrators group other than the built-in Administrator must
            then be executing the application in an enhanced shell as the built-in Administrator ( <c>RunAs administrator</c>) for this
            function to succeed.
            </para>
            <para>Any file installation or service provider-specific configuration must be performed by the caller.</para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.AFPROTOCOLS">
            <summary>
            The <c>AFPROTOCOLS</c> structure supplies a list of protocols to which application programmers can constrain queries. The
            <c>AFPROTOCOLS</c> structure is used for query purposes only.
            </summary>
            <remarks>
            The members of the <c>AFPROTOCOLS</c> structure are a functional pair, and only have meaning when used together, as protocol
            values have meaning only within the context of an address family.
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.AFPROTOCOLS.iAddressFamily">
            <summary>Address family to which the query is to be constrained.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.AFPROTOCOLS.iProtocol">
            <summary>Protocol to which the query is to be constrained.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.BLOB">
            <summary>The <c>BLOB</c> structure, derived from Binary Large Object, contains information about a block of data.</summary>
            <remarks>
            <para>The structure name <c>BLOB</c> comes from the acronym BLOB, which stands for Binary Large Object.</para>
            <para>This structure does not describe the nature of the data pointed to by <c>pBlobData</c>.</para>
            <para>
            <c>Note</c> Windows Sockets defines a similar <c>BLOB</c> structure in Wtypes.h. Using both header files in the same source code
            file creates redefinitioncompile time errors.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.BLOB.cbSize">
            <summary>Size of the block of data pointed to by <c>pBlobData</c>, in bytes.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.BLOB.pBlobData">
            <summary>Pointer to a block of data.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.NSPV2_ROUTINE">
            <summary>
            The <c>NSPV2_ROUTINE</c> structure contains information on the functions implemented by a namespace service provider version-2
            (NSPv2) provider.
            </summary>
            <remarks>
            <para>
            The <c>NSPV2_ROUTINE</c> structure is used as part of the namespace service provider version-2 (NSPv2) architecture available on
            Windows Vista and later.
            </para>
            <para>
            On Windows Vista and Windows Server 2008, the <c>NSPV2_ROUTINE</c> structure can only be used for operations on NS_EMAIL
            namespace providers.
            </para>
            <para>
            The WSAAdvertiseProvider function advertises an instance of a NSPv2 provider for clients to find. The
            <c>WSAAdvertiseProvider</c> caller passes a pointer to an <c>NSPV2_ROUTINE</c> structure in the pNSPv2Routine parameter with the
            NSPv2 entry points supported by the provider.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NSPV2_ROUTINE.cbSize">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The size, in bytes, of the structure.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NSPV2_ROUTINE.dwMajorVersion">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The major version of the service provider specification supported by this provider.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NSPV2_ROUTINE.dwMinorVersion">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The minor version of the service provider specification supported by this provider.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NSPV2_ROUTINE.NSPv2Startup">
            <summary>
            <para>Type: ** LPNSPV2STARTUP**</para>
            <para>A pointer to the NSPv2Startup function for this NSPv2 provider.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NSPV2_ROUTINE.NSPv2Cleanup">
            <summary>
            <para>Type: <c>LPNSPV2CLEANUP</c></para>
            <para>A pointer to the NSPv2Cleanup function for this NSPv2 provider.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NSPV2_ROUTINE.NSPv2LookupServiceBegin">
            <summary>
            <para>Type: <c>LPNSPV2LOOKUPSERVICEBEGIN</c></para>
            <para>A pointer to the NSPv2LookupServiceBegin function for this NSPv2 provider.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NSPV2_ROUTINE.NSPv2LookupServiceNextEx">
            <summary>
            <para>Type: <c>LPNSPV2LOOKUPSERVICENEXTEX</c></para>
            <para>A pointer to the NSPv2LookupServiceNextEx function for this NSPv2 provider.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NSPV2_ROUTINE.NSPv2LookupServiceEnd">
            <summary>
            <para>Type: <c>LPNSPV2LOOKUPSERVICEEND</c></para>
            <para>A pointer to the NSPv2LookupServiceEnd function for this NSPv2 provider.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NSPV2_ROUTINE.NSPv2SetServiceEx">
            <summary>
            <para>Type: <c>LPNSPV2SETSERVICEEX</c></para>
            <para>A pointer to the NSPv2SetServiceEx function for this NSPv2 provider.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.NSPV2_ROUTINE.NSPv2ClientSessionRundown">
            <summary>
            <para>Type: <c>LPNSPV2CLIENTSESSIONRUNDOWN</c></para>
            <para>A pointer to the NSPv2ClientSessionRundown function for this NSPv2 provider.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WSAEVENT">
            <summary>Provides a handle to a WSA event.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAEVENT.#ctor(System.IntPtr)">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.WSAEVENT"/> struct.</summary>
            <param name="preexistingHandle">An <see cref="T:System.IntPtr"/> object that represents the pre-existing handle to use.</param>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.WSAEVENT.NULL">
            <summary>Returns an invalid handle by instantiating a <see cref="T:Vanara.PInvoke.Ws2_32.WSAEVENT"/> object with <see cref="F:System.IntPtr.Zero"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.WSAEVENT.IsNull">
            <summary>Gets a value indicating whether this instance is a null handle.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAEVENT.op_Explicit(Vanara.PInvoke.Ws2_32.WSAEVENT)~System.IntPtr">
            <summary>Performs an explicit conversion from <see cref="T:Vanara.PInvoke.Ws2_32.WSAEVENT"/> to <see cref="T:System.IntPtr"/>.</summary>
            <param name="h">The handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAEVENT.op_Implicit(System.IntPtr)~Vanara.PInvoke.Ws2_32.WSAEVENT">
            <summary>Performs an implicit conversion from <see cref="T:System.IntPtr"/> to <see cref="T:Vanara.PInvoke.Ws2_32.WSAEVENT"/>.</summary>
            <param name="h">The pointer to a handle.</param>
            <returns>The result of the conversion.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAEVENT.op_Inequality(Vanara.PInvoke.Ws2_32.WSAEVENT,Vanara.PInvoke.Ws2_32.WSAEVENT)">
            <summary>Implements the operator !=.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAEVENT.op_Equality(Vanara.PInvoke.Ws2_32.WSAEVENT,Vanara.PInvoke.Ws2_32.WSAEVENT)">
            <summary>Implements the operator ==.</summary>
            <param name="h1">The first handle.</param>
            <param name="h2">The second handle.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAEVENT.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAEVENT.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.WSAEVENT.DangerousGetHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WSANAMESPACE_INFOEXW">
            <summary>The <c>WSANAMESPACE_INFOEX</c> structure contains all registration information for a namespace provider.</summary>
            <remarks>
            <para>
            The <c>WSANAMESPACE_INFOEX</c> structure is an enhanced version of the WSANAMESPACE_INFO structure that is used by the
            WSAEnumNameSpaceProvidersEx and the WSCEnumNameSpaceProvidersEx32 functions to return information on available namespace
            providers. The <c>WSANAMESPACE_INFOEX</c> structure contains the provider-specific data blob associated with the namespace entry
            passed in the lpProviderInfo parameter to the WSCInstallNameSpaceEx and WSCInstallNameSpaceEx32 functions.
            </para>
            <para>
            Currently, the only namespace included with Windows that uses information in the <c>ProviderSpecific</c> member of the
            <c>WSANAMESPACE_INFOEX</c> structure are namespace providers for the NS_EMAIL namespace. The format of the
            <c>ProviderSpecific</c> member for an NS_EMAIL namespace provider is a NAPI_PROVIDER_INSTALLATION_BLOB structure.
            </para>
            <para>
            When UNICODE or _UNICODE is defined, <c>WSANAMESPACE_INFOEX</c> is defined to <c>WSANAMESPACE_INFOEXW</c>, the Unicode version
            of this structure and the <c>lpszIdentifier</c> string member is defined to the <c>LPWSTR</c> data type.
            </para>
            <para>
            When UNICODE or _UNICODE is not defined, <c>WSANAMESPACE_INFOEX</c> is defined to <c>WSANAMESPACE_INFOEXA</c>, the ANSI version
            of this structure and the <c>lpszIdentifier</c> string member is defined to the <c>LPSTR</c> data type.
            </para>
            <para>The WSCEnumNameSpaceProvidersEx32 function is a Unicode only function and returns <c>WSANAMESPACE_INFOEXW</c> structures.</para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSANAMESPACE_INFOEXW.NSProviderId">
            <summary>
            <para>Type: <c>GUID</c></para>
            <para>A unique GUID for this namespace provider.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSANAMESPACE_INFOEXW.dwNameSpace">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The namespace supported by this provider.</para>
            <para>
            Possible values for the <c>dwNameSpace</c> member are listed in the Winsock2.h include file. Several namespace providers are
            included with Windows Vista and later. Other namespace providers can be installed, so the following possible values are only
            those commonly available. Many other values are possible.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>NS_BTH</term>
            <term>The Bluetooth namespace. This namespace identifier is supported on Windows Vista and later.</term>
            </item>
            <item>
            <term>NS_DNS</term>
            <term>The domain name system (DNS) namespace.</term>
            </item>
            <item>
            <term>NS_EMAIL</term>
            <term>The email namespace. This namespace identifier is supported on Windows Vista and later.</term>
            </item>
            <item>
            <term>NS_NLA</term>
            <term>The network location awareness (NLA) namespace. This namespace identifier is supported on Windows XP and later.</term>
            </item>
            <item>
            <term>NS_NTDS</term>
            <term>The Windows NT directory service (NTDS) namespace.</term>
            </item>
            <item>
            <term>NS_PNRPNAME</term>
            <term>
            The peer-to-peer name space for a specific peer name. This namespace identifier is supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>NS_PNRPCLOUD</term>
            <term>
            The peer-to-peer name space for a collection of peer names. This namespace identifier is supported on Windows Vista and later.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSANAMESPACE_INFOEXW.fActive">
            <summary>
            <para>Type: <c>BOOL</c></para>
            <para>
            If <c>TRUE</c>, indicates that this namespace provider is active. If <c>FALSE</c>, the namespace provider is inactive and is
            not accessible for queries, even if the query specifically references this namespace provider.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSANAMESPACE_INFOEXW.dwVersion">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The version number of the namespace provider.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSANAMESPACE_INFOEXW.lpszIdentifier">
            <summary>
            <para>Type: <c>LPTSTR</c></para>
            <para>A display string that identifies the namespace provider.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSANAMESPACE_INFOEXW.ProviderSpecific">
            <summary>
            <para>Type: <c>BLOB</c></para>
            <para>A provider-specific data blob associated with namespace entry.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WSANAMESPACE_INFOW">
            <summary>The <c>WSANAMESPACE_INFO</c> structure contains all registration information for a namespace provider.</summary>
            <remarks>
            <para>
            The <c>WSANAMESPACE_INFO</c> structure is used by the WSAEnumNameSpaceProvidersand WSCEnumNameSpaceProviders32 functions to
            return information on available namespace providers. The <c>WSANAMESPACE_INFO</c> structure contains the provider-specific
            information on the namespace entry passed to the WSCInstallNameSpace and WSCInstallNameSpace32 functions when the namespace
            provider was installed.
            </para>
            <para>
            When UNICODE or _UNICODE is defined, <c>WSANAMESPACE_INFO</c> is defined to <c>WSANAMESPACE_INFOW</c>, the Unicode version of
            this data structure and the <c>lpszIdentifier</c> string member is defined to the <c>LPWSTR</c> data type.
            </para>
            <para>
            When UNICODE or _UNICODE is not defined, <c>WSANAMESPACE_INFO</c> is defined to <c>WSANAMESPACE_INFOA</c>, the ANSI version of
            this data structure and the <c>lpszIdentifier</c> string member is defined to the <c>LPSTR</c> data type.
            </para>
            <para>
            On Windows Vista and later, WSANAMESPACE_INFOEX, an enhanced version of the <c>WSANAMESPACE_INFO</c> structure, is returned by
            calls to the WSAEnumNameSpaceProvidersEx and WSCEnumNameSpaceProvidersEx32 functions
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSANAMESPACE_INFOW.NSProviderId">
            <summary>
            <para>Type: <c>GUID</c></para>
            <para>A unique GUID for this namespace provider.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSANAMESPACE_INFOW.dwNameSpace">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The namespace supported by this provider.</para>
            <para>
            Possible values for the <c>dwNameSpace</c> member are listed in the Winsock2.h include file. Several namespace providers are
            included with Windows Vista and later. Other namespace providers can be installed, so the following possible values are only
            those commonly available. Many other values are possible.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>NS_BTH</term>
            <term>The Bluetooth namespace. This namespace identifier is supported on Windows Vista and later.</term>
            </item>
            <item>
            <term>NS_DNS</term>
            <term>The domain name system (DNS) namespace.</term>
            </item>
            <item>
            <term>NS_EMAIL</term>
            <term>The email namespace. This namespace identifier is supported on Windows Vista and later.</term>
            </item>
            <item>
            <term>NS_NLA</term>
            <term>The network location awareness (NLA) namespace. This namespace identifier is supported on Windows XP and later.</term>
            </item>
            <item>
            <term>NS_NTDS</term>
            <term>The Windows NT directory service (NTDS) namespace.</term>
            </item>
            <item>
            <term>NS_PNRPNAME</term>
            <term>
            The peer-to-peer name space for a specific peer name. This namespace identifier is supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>NS_PNRPCLOUD</term>
            <term>
            The peer-to-peer name space for a collection of peer names. This namespace identifier is supported on Windows Vista and later.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSANAMESPACE_INFOW.fActive">
            <summary>
            <para>Type: <c>BOOL</c></para>
            <para>
            If <c>TRUE</c>, indicates that this namespace provider is active. If <c>FALSE</c>, the namespace provider is inactive and is
            not accessible for queries, even if the query specifically references this namespace provider.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSANAMESPACE_INFOW.dwVersion">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The version number of the namespace provider.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSANAMESPACE_INFOW.lpszIdentifier">
            <summary>
            <para>Type: <c>LPTSTR</c></para>
            <para>A display string that identifies the namespace provider.</para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WSAOVERLAPPED">
            <summary>
            The <c>WSAOVERLAPPED</c> structure provides a communication medium between the initiation of an overlapped I/O operation and its
            subsequent completion. The <c>WSAOVERLAPPED</c> structure is compatible with the Windows OVERLAPPED structure.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAOVERLAPPED.Internal">
            <summary>
            <para>Type: <c>ULONG_PTR</c></para>
            <para>
            Reserved for internal use. The Internal member is used internally by the entity that implements overlapped I/O. For service
            providers that create sockets as installable file system (IFS) handles, this parameter is used by the underlying operating
            system. Other service providers (non-IFS providers) are free to use this parameter as necessary.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAOVERLAPPED.InternalHigh">
            <summary>
            <para>Type: <c>ULONG_PTR</c></para>
            <para>
            Reserved. Used internally by the entity that implements overlapped I/O. For service providers that create sockets as IFS
            handles, this parameter is used by the underlying operating system. NonIFS providers are free to use this parameter as necessary.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAOVERLAPPED.Offset">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>Reserved for use by service providers.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAOVERLAPPED.OffsetHigh">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>Reserved for use by service providers.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAOVERLAPPED.hEvent">
            <summary>
            <para>Type: <c>HANDLE</c></para>
            <para>
            If an overlapped I/O operation is issued without an I/O completion routine (the operation's lpCompletionRoutine parameter is
            set to null), then this parameter should either contain a valid handle to a WSAEVENT object or be null. If the
            lpCompletionRoutine parameter of the call is non-null then applications are free to use this parameter as necessary.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW">
            <summary>
            The <c>WSAPROTOCOL_INFOW</c> structure is used to store or retrieve complete information for a given protocol. The protocol name
            is represented as an array of Unicode characters.
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW.dwServiceFlags1">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            A bitmask that describes the services provided by the protocol. The possible values for this member are defined in the
            Winsock2.h header file.
            </para>
            <para>The following values are possible.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>XP1_CONNECTIONLESS 0x00000001</term>
            <term>Provides connectionless (datagram) service. If not set, the protocol supports connection-oriented data transfer.</term>
            </item>
            <item>
            <term>XP1_GUARANTEED_DELIVERY 0x00000002</term>
            <term>Guarantees that all data sent will reach the intended destination.</term>
            </item>
            <item>
            <term>XP1_GUARANTEED_ORDER 0x00000004</term>
            <term>
            Guarantees that data only arrives in the order in which it was sent and that it is not duplicated. This characteristic does
            not necessarily mean that the data is always delivered, but that any data that is delivered is delivered in the order in
            which it was sent.
            </term>
            </item>
            <item>
            <term>XP1_MESSAGE_ORIENTED 0x00000008</term>
            <term>Honors message boundariesas opposed to a stream-oriented protocol where there is no concept of message boundaries.</term>
            </item>
            <item>
            <term>XP1_PSEUDO_STREAM 0x00000010</term>
            <term>
            A message-oriented protocol, but message boundaries are ignored for all receipts. This is convenient when an application
            does not desire message framing to be done by the protocol.
            </term>
            </item>
            <item>
            <term>XP1_GRACEFUL_CLOSE 0x00000020</term>
            <term>Supports two-phase (graceful) close. If not set, only abortive closes are performed.</term>
            </item>
            <item>
            <term>XP1_EXPEDITED_DATA 0x00000040</term>
            <term>Supports expedited (urgent) data.</term>
            </item>
            <item>
            <term>XP1_CONNECT_DATA 0x00000080</term>
            <term>Supports connect data.</term>
            </item>
            <item>
            <term>XP1_DISCONNECT_DATA 0x00000100</term>
            <term>Supports disconnect data.</term>
            </item>
            <item>
            <term>XP1_SUPPORT_BROADCAST 0x00000200</term>
            <term>Supports a broadcast mechanism.</term>
            </item>
            <item>
            <term>XP1_SUPPORT_MULTIPOINT 0x00000400</term>
            <term>Supports a multipoint or multicast mechanism. Control and data plane attributes are indicated below.</term>
            </item>
            <item>
            <term>XP1_MULTIPOINT_CONTROL_PLANE 0x00000800</term>
            <term>Indicates whether the control plane is rooted (value = 1) or nonrooted (value = 0).</term>
            </item>
            <item>
            <term>XP1_MULTIPOINT_DATA_PLANE 0x00001000</term>
            <term>Indicates whether the data plane is rooted (value = 1) or nonrooted (value = 0).</term>
            </item>
            <item>
            <term>XP1_QOS_SUPPORTED 0x00002000</term>
            <term>Supports quality of service requests.</term>
            </item>
            <item>
            <term>XP1_INTERRUPT</term>
            <term>Bit is reserved.</term>
            </item>
            <item>
            <term>XP1_UNI_SEND 0x00008000</term>
            <term>Protocol is unidirectional in the send direction.</term>
            </item>
            <item>
            <term>XP1_UNI_RECV 0x00010000</term>
            <term>Protocol is unidirectional in the recv direction.</term>
            </item>
            <item>
            <term>XP1_IFS_HANDLES 0x00020000</term>
            <term>Socket descriptors returned by the provider are operating system Installable File System (IFS) handles.</term>
            </item>
            <item>
            <term>XP1_PARTIAL_MESSAGE 0x00040000</term>
            <term>The MSG_PARTIAL flag is supported in WSASend and WSASendTo.</term>
            </item>
            <item>
            <term>XP1_SAN_SUPPORT_SDP 0x00080000</term>
            <term>The protocol provides support for SAN. This value is supported on Windows 7 and Windows Server 2008 R2.</term>
            </item>
            </list>
            <para>
            <c>Note</c> Only one of XP1_UNI_SEND or XP1_UNI_RECV values may be set. If a protocol can be unidirectional in either
            direction, two <c>WSAPROTOCOL_INFOW</c> structures should be used. When neither bit is set, the protocol is considered to be bidirectional.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW.dwServiceFlags2">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>Reserved for additional protocol-attribute definitions.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW.dwServiceFlags3">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>Reserved for additional protocol-attribute definitions.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW.dwServiceFlags4">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>Reserved for additional protocol-attribute definitions.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW.dwProviderFlags">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            A set of flags that provides information on how this protocol is represented in the Winsock catalog. The possible values for
            this member are defined in the Winsock2.h header file.
            </para>
            <para>The following values are possible.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>PFL_MULTIPLE_PROTO_ENTRIES 0x00000001</term>
            <term>
            Indicates that this is one of two or more entries for a single protocol (from a given provider) which is capable of
            implementing multiple behaviors. An example of this is SPX which, on the receiving side, can behave either as a
            message-oriented or a stream-oriented protocol.
            </term>
            </item>
            <item>
            <term>PFL_RECOMMENDED_PROTO_ENTRY 0x00000002</term>
            <term>
            Indicates that this is the recommended or most frequently used entry for a protocol that is capable of implementing multiple behaviors.
            </term>
            </item>
            <item>
            <term>PFL_HIDDEN 0x00000004</term>
            <term>
            Set by a provider to indicate to the Ws2_32.dll that this protocol should not be returned in the result buffer generated by
            WSAEnumProtocols. Obviously, a Windows Sockets 2 application should never see an entry with this bit set.
            </term>
            </item>
            <item>
            <term>PFL_MATCHES_PROTOCOL_ZERO 0x00000008</term>
            <term>Indicates that a value of zero in the protocol parameter of socket or WSASocket matches this protocol entry.</term>
            </item>
            <item>
            <term>PFL_NETWORKDIRECT_PROVIDER 0x00000010</term>
            <term>
            Set by a provider to indicate support for network direct access. This value is supported on Windows 7 and Windows Server
            2008 R2.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW.ProviderId">
            <summary>
            <para>Type: <c>GUID</c></para>
            <para>
            A globally unique identifier (GUID) assigned to the provider by the service provider vendor. This value is useful for
            instances where more than one service provider is able to implement a particular protocol. An application can use the
            <c>ProviderId</c> member to distinguish between providers that might otherwise be indistinguishable.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW.dwCatalogEntryId">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>A unique identifier assigned by the WS2_32.DLL for each WSAPROTOCOL_INFO structure.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW.ProtocolChain">
            <summary>
            <para>Type: <c>WSAPROTOCOLCHAIN</c></para>
            <para>
            The WSAPROTOCOLCHAIN structure associated with the protocol. If the length of the chain is 0, this WSAPROTOCOL_INFO entry
            represents a layered protocol which has Windows Sockets 2 SPI as both its top and bottom edges. If the length of the chain
            equals 1, this entry represents a base protocol whose Catalog Entry identifier is in the <c>dwCatalogEntryId</c> member of
            the <c>WSAPROTOCOL_INFO</c> structure. If the length of the chain is larger than 1, this entry represents a protocol chain
            which consists of one or more layered protocols on top of a base protocol. The corresponding Catalog Entry identifiers are
            in the ProtocolChain.ChainEntries array starting with the layered protocol at the top (the zero element in the
            ProtocolChain.ChainEntries array) and ending with the base protocol. Refer to the Windows Sockets 2 Service Provider
            Interface specification for more information on protocol chains.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW.iVersion">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The protocol version identifier.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW.iAddressFamily">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            A value to pass as the address family parameter to the socket or WSASocket function in order to open a socket for this
            protocol. This value also uniquely defines the structure of a protocol address for a sockaddr used by the protocol.
            </para>
            <para>
            On the Windows SDK released for Windows Vista and later, the possible values for the address family are defined in the
            Ws2def.h header file. Note that the Ws2def.h header file is automatically included in Winsock2.h, and should never be used directly.
            </para>
            <para>
            On versions of the Platform SDK for Windows Server 2003 and older, the possible values for the address family are defined in
            the Winsock2.h header file.
            </para>
            <para>
            The values currently supported are AF_INET or AF_INET6, which are the Internet address family formats for IPv4 and IPv6.
            Other options for address family (AF_NETBIOS for use with NetBIOS, for example) are supported if a Windows Sockets service
            provider for the address family is installed. Note that the values for the AF_ address family and PF_ protocol family
            constants are identical (for example, <c>AF_INET</c> and <c>PF_INET</c>), so either constant can be used.
            </para>
            <para>The table below lists common values for address family although many other values are possible.</para>
            <list type="table">
            <listheader>
            <term>iAddressFamily</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AF_INET 2</term>
            <term>The Internet Protocol version 4 (IPv4) address family.</term>
            </item>
            <item>
            <term>AF_IPX 6</term>
            <term>
            The IPX/SPX address family. This address family is only supported if the NWLink IPX/SPX NetBIOS Compatible Transport
            protocol is installed. This address family is not supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AF_APPLETALK 16</term>
            <term>
            The AppleTalk address family. This address family is only supported if the AppleTalk protocol is installed. This address
            family is not supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AF_NETBIOS 17</term>
            <term>
            The NetBIOS address family. This address family is only supported if the Windows Sockets provider for NetBIOS is installed.
            The Windows Sockets provider for NetBIOS is supported on 32-bit versions of Windows. This provider is installed by default
            on 32-bit versions of Windows. The Windows Sockets provider for NetBIOS is not supported on 64-bit versions of windows
            including Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003, or Windows XP. The Windows Sockets provider
            for NetBIOS only supports sockets where the type parameter is set to SOCK_DGRAM. The Windows Sockets provider for NetBIOS is
            not directly related to the NetBIOS programming interface. The NetBIOS programming interface is not supported on Windows
            Vista, Windows Server 2008, and later.
            </term>
            </item>
            <item>
            <term>AF_INET6 23</term>
            <term>The Internet Protocol version 6 (IPv6) address family.</term>
            </item>
            <item>
            <term>AF_IRDA 26</term>
            <term>
            The Infrared Data Association (IrDA) address family. This address family is only supported if the computer has an infrared
            port and driver installed.
            </term>
            </item>
            <item>
            <term>AF_BTH 32</term>
            <term>
            The Bluetooth address family. This address family is supported on Windows XP with SP2 or later if the computer has a
            Bluetooth adapter and driver installed.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW.iMaxSockAddr">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The maximum address length, in bytes.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW.iMinSockAddr">
            <summary>
            <para>Type: <c>int</c></para>
            <para>The minimum address length, in bytes.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW.iSocketType">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            A value to pass as the socket type parameter to the socket or WSASocket function in order to open a socket for this
            protocol. Possible values for the socket type are defined in the Winsock2.h header file.
            </para>
            <para>The following table lists the possible values for the <c>iSocketType</c> member supported for Windows Sockets 2:</para>
            <list type="table">
            <listheader>
            <term>iSocketType</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>SOCK_STREAM 1</term>
            <term>
            A socket type that provides sequenced, reliable, two-way, connection-based byte streams with an OOB data transmission
            mechanism. This socket type uses the Transmission Control Protocol (TCP) for the Internet address family (AF_INET or AF_INET6).
            </term>
            </item>
            <item>
            <term>SOCK_DGRAM 2</term>
            <term>
            A socket type that supports datagrams, which are connectionless, unreliable buffers of a fixed (typically small) maximum
            length. This socket type uses the User Datagram Protocol (UDP) for the Internet address family (AF_INET or AF_INET6).
            </term>
            </item>
            <item>
            <term>SOCK_RAW 3</term>
            <term>
            A socket type that provides a raw socket that allows an application to manipulate the next upper-layer protocol header. To
            manipulate the IPv4 header, the IP_HDRINCL socket option must be set on the socket. To manipulate the IPv6 header, the
            IPV6_HDRINCL socket option must be set on the socket.
            </term>
            </item>
            <item>
            <term>SOCK_RDM 4</term>
            <term>
            A socket type that provides a reliable message datagram. An example of this type is the Pragmatic General Multicast (PGM)
            multicast protocol implementation in Windows, often referred to as reliable multicast programming. This value is only
            supported if the Reliable Multicast Protocol is installed.
            </term>
            </item>
            <item>
            <term>SOCK_SEQPACKET 5</term>
            <term>A socket type that provides a pseudo-stream packet based on datagrams.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW.iProtocol">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            A value to pass as the protocol parameter to the socket or WSASocket function in order to open a socket for this protocol.
            The possible options for the <c>iProtocol</c> member are specific to the address family and socket type specified.
            </para>
            <para>
            On the Windows SDK released for Windows Vista and later, this member can be one of the values from the <c>IPPROTO</c>
            enumeration type defined in the Ws2def.h header file. Note that the Ws2def.h header file is automatically included in
            Winsock2.h, and should never be used directly.
            </para>
            <para>
            On versions of the Platform SDK for Windows Server 2003 and earlier, the possible values for the <c>iProtocol</c> member are
            defined in the Winsock2.h and Wsrm.h header files.
            </para>
            <para>The table below lists common values for the <c>iProtocol</c> although many other values are possible.</para>
            <list type="table">
            <listheader>
            <term>iProtocol</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>IPPROTO_ICMP 1</term>
            <term>The Internet Control Message Protocol (ICMP). This value is supported on Windows XP and later.</term>
            </item>
            <item>
            <term>IPPROTO_IGMP 2</term>
            <term>The Internet Group Management Protocol (IGMP). This value is supported on Windows XP and later.</term>
            </item>
            <item>
            <term>BTHPROTO_RFCOMM 3</term>
            <term>
            The Bluetooth Radio Frequency Communications (Bluetooth RFCOMM) protocol. This value is supported on Windows XP with SP2 or later.
            </term>
            </item>
            <item>
            <term>IPPROTO_TCP 6</term>
            <term>The Transmission Control Protocol (TCP).</term>
            </item>
            <item>
            <term>IPPROTO_UDP 17</term>
            <term>The User Datagram Protocol (UDP).</term>
            </item>
            <item>
            <term>IPPROTO_ICMPV6 58</term>
            <term>The Internet Control Message Protocol Version 6 (ICMPv6). This value is supported on Windows XP and later.</term>
            </item>
            <item>
            <term>IPPROTO_RM 113</term>
            <term>
            The PGM protocol for reliable multicast. On the Windows SDK released for Windows Vista and later, this protocol is also
            called IPPROTO_PGM. This value is only supported if the Reliable Multicast Protocol is installed.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW.iProtocolMaxOffset">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            The maximum value that may be added to <c>iProtocol</c> member when supplying a value for the protocol parameter to socket
            and WSASocket. Not all protocols allow a range of values. When this is the case <c>iProtocolMaxOffset</c> is zero.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW.iNetworkByteOrder">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            Currently these values are manifest constants (BIGENDIAN and LITTLEENDIAN) that indicate either big-endian or little-endian
            with the values 0 and 1 respectively.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW.iSecurityScheme">
            <summary>
            <para>Type: <c>int</c></para>
            <para>
            The type of security scheme employed (if any). A value of SECURITY_PROTOCOL_NONE (0) is used for protocols that do not
            incorporate security provisions.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW.dwMessageSize">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            The maximum message size, in bytes, supported by the protocol. This is the maximum size that can be sent from any of the
            host's local interfaces. For protocols that do not support message framing, the actual maximum that can be sent to a given
            address may be less. There is no standard provision to determine the maximum inbound message size. The following special
            values are defined.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>0</term>
            <term>The protocol is stream-oriented and hence the concept of message size is not relevant.</term>
            </item>
            <item>
            <term>0x1</term>
            <term>
            The maximum outbound (send) message size is dependent on the underlying network MTU (maximum sized transmission unit) and
            hence cannot be known until after a socket is bound. Applications should use getsockopt to retrieve the value of
            SO_MAX_MSG_SIZE after the socket has been bound to a local address.
            </term>
            </item>
            <item>
            <term>0xFFFFFFFF</term>
            <term>The protocol is message-oriented, but there is no maximum limit to the size of messages that may be transmitted.</term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW.dwProviderReserved">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>Reserved for use by service providers.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAPROTOCOL_INFOW.szProtocol">
            <summary>
            <para>Type: <c>WCHAR[WSAPROTOCOL_LEN+1]</c></para>
            <para>
            An array of Unicode characters that contains a human-readable name identifying the protocol, for example "MSAFD Tcpip
            [UDP/IP]". The maximum number of characters allowed is WSAPROTOCOL_LEN, which is defined to be 255.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WSAQUERYSET2W">
            <summary>
            The <c>WSAQUERYSET2</c> structure provides relevant information about a given service, including service class ID, service name
            , applicable namespace identifier and protocol information, as well as a set of transport addresses at which the service listens.
            </summary>
            <remarks>
            <para>
            The <c>WSAQUERYSET2</c> structure is used as part of the namespace service provider version-2 (NSPv2) architecture available on
            Windows Vista and later.
            </para>
            <para>
            On Windows Vista and Windows Server 2008, the <c>WSAQUERYSET2</c> structure can only be used for operations on NS_EMAIL
            namespace providers.
            </para>
            </remarks>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET2W.dwSize">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            The size, in bytes, of the <c>WSAQUERYSET2</c> structure. This member is used as a versioning mechanism since the size of
            the <c>WSAQUERYSET2</c> structure may change on later versions of Windows.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET2W.lpszServiceInstanceName">
            <summary>
            <para>Type: <c>LPTSTR</c></para>
            <para>
            A pointer to an optional <c>NULL</c>-terminated string that contains service name. The semantics for using wildcards within
            the string are not defined, but can be supported by certain namespace providers.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET2W.lpVersion">
            <summary>
            <para>Type: <c>LPWSAVERSION</c></para>
            <para>
            A pointer to an optional desired version number of the namespace provider. This member provides version comparison semantics
            (that is, the version requested must match exactly, or version must be not less than the value supplied).
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET2W.lpszComment">
            <summary>
            <para>Type: <c>LPTSTR</c></para>
            <para>This member is ignored for queries.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET2W.dwNameSpace">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>
            A namespace identifier that determines which namespace providers are queried. Passing a specific namespace identifier will
            result in only namespace providers that support the specified namespace being queried. Specifying <c>NS_ALL</c> will result
            in all installed and active namespace providers being queried.
            </para>
            <para>
            Options for the <c>dwNameSpace</c> member are listed in the Winsock2.h include file. Several new namespace providers are
            included with Windows Vista and later. Other namespace providers can be installed, so the following possible values are only
            those commonly available. Many other values are possible.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>NS_ALL</term>
            <term>All installed and active namespaces.</term>
            </item>
            <item>
            <term>NS_BTH</term>
            <term>The Bluetooth namespace. This namespace identifier is supported on Windows Vista and later.</term>
            </item>
            <item>
            <term>NS_DNS</term>
            <term>The domain name system (DNS) namespace.</term>
            </item>
            <item>
            <term>NS_EMAIL</term>
            <term>The email namespace. This namespace identifier is supported on Windows Vista and later.</term>
            </item>
            <item>
            <term>NS_NLA</term>
            <term>The network location awareness (NLA) namespace. This namespace identifier is supported on Windows XP and later.</term>
            </item>
            <item>
            <term>NS_PNRPNAME</term>
            <term>
            The peer-to-peer name space for a specific peer name. This namespace identifier is supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>NS_PNRPCLOUD</term>
            <term>
            The peer-to-peer name space for a collection of peer names. This namespace identifier is supported on Windows Vista and later.
            </term>
            </item>
            </list>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET2W.lpNSProviderId">
            <summary>
            <para>Type: <c>LPGUID</c></para>
            <para>
            A pointer to an optional GUID of a specific namespace provider to query in the case where multiple namespace providers are
            registered under a single namespace such as <c>NS_DNS</c>. Passing the GUID for a specific namespace provider will result in
            only the specified namespace provider being queried. The WSAEnumNameSpaceProviders and WSAEnumNameSpaceProvidersEx functions
            can be called to retrieve the GUID for a namespace provider.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET2W.lpszContext">
            <summary>
            <para>Type: <c>LPTSTR</c></para>
            <para>A pointer to an optional starting point of the query in a hierarchical namespace.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET2W.dwNumberOfProtocols">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>The size, in bytes, of the protocol constraint array. This member can be zero.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET2W.lpafpProtocols">
            <summary>
            <para>Type: <c>LPAFPROTOCOLS</c></para>
            <para>A pointer to an optional array of AFPROTOCOLS structures. Only services that utilize these protocols will be returned.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET2W.lpszQueryString">
            <summary>
            <para>Type: <c>LPTSTR</c></para>
            <para>
            A pointer to an optional <c>NULL</c>-terminated query string. Some namespaces, such as Whois++, support enriched SQL-like
            queries that are contained in a simple text string. This parameter is used to specify that string.
            </para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET2W.dwNumberOfCsAddrs">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>This member is ignored for queries.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET2W.lpcsaBuffer">
            <summary>
            <para>Type: <c>LPCSADDR_INFO</c></para>
            <para>This member is ignored for queries.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET2W.dwOutputFlags">
            <summary>
            <para>Type: <c>DWORD</c></para>
            <para>This member is ignored for queries.</para>
            </summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAQUERYSET2W.lpBlob">
            <summary>
            <para>Type: <c>LPBLOB</c></para>
            <para>
            An optional pointer to data that is used to query or set provider-specific namespace information. The format of this
            information is specific to the namespace provider.
            </para>
            </summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.WSAVERSION">
            <summary>The <c>WSAVERSION</c> structure provides version comparison in Windows Sockets.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAVERSION.dwVersion">
            <summary>Version of Windows Sockets.</summary>
        </member>
        <member name="F:Vanara.PInvoke.Ws2_32.WSAVERSION.ecHow">
            <summary>WSAECOMPARATOR enumeration, used in the comparison.</summary>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.LPLOOKUPSERVICE_COMPLETION_ROUTINE">
            <summary>An optional pointer to a function to be invoked upon successful completion for asynchronous operations.</summary>
            <param name="dwError">Set to a Winsock error code.</param>
            <param name="dwBytes">Reserved for future use and must be ignored.</param>
            <param name="lpOverlapped">
            the value of lpOverlapped parameter passed to GetAddrInfoEx. The Pointer member of the OVERLAPPED structure will be set to the
            value of the ppResult parameter of the original call. If the Pointer member points to a non-NULL pointer to the addrinfoex
            structure, it is the callers responsibility to call FreeAddrInfoEx to free the addrinfoex structure.
            </param>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.FreeAddrInfoExW(System.IntPtr)">
            <summary>
            The <c>FreeAddrInfoEx</c> function frees address information that the GetAddrInfoEx function dynamically allocates in addrinfoex structures.
            </summary>
            <param name="pAddrInfoEx">
            A pointer to the addrinfoex structure or linked list of <c>addrinfoex</c> structures to be freed. All dynamic storage pointed to
            within the <c>addrinfoex</c> structure or structures is also freed.
            </param>
            <returns>This function does not return a value.</returns>
            <remarks>
            <para>
            The <c>FreeAddrInfoEx</c> function frees addrinfoex structures dynamically allocated by the GetAddrInfoEx function. The
            <c>FreeAddrInfoEx</c> function frees the initial <c>addrinfoex</c> structure pointed to in the pAddrInfo parameter, including
            any buffers to which structure members point, then continues freeing any <c>addrinfoex</c> structures linked by the
            <c>ai_next</c> member of the <c>addrinfoex</c> structure. The <c>FreeAddrInfoEx</c> function continues freeing linked structures
            until a <c>NULL</c><c>ai_next</c> member is encountered.
            </para>
            <para>
            When UNICODE or _UNICODE is defined, <c>FreeAddrInfoEx</c> is defined to <c>FreeAddrInfoExW</c>, the Unicode version of the
            function, and <c>ADDRINFOEX</c> is defined to the addrinfoexW structure. When UNICODE or _UNICODE is not defined,
            <c>FreeAddrInfoEx</c> is defined to <c>FreeAddrInfoExA</c>, the ANSI version of the function, and <c>ADDRINFOEX</c> is defined
            to the <c>addrinfoexA</c> structure.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>FreeAddrInfoExW</c> function is supported for Windows Store apps on
            Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.FreeAddrInfoW(System.IntPtr)">
            <summary>
            The <c>FreeAddrInfoW</c> function frees address information that the GetAddrInfoW function dynamically allocates in addrinfoW structures.
            </summary>
            <param name="pAddrInfo">
            A pointer to the addrinfoW structure or linked list of <c>addrinfoW</c> structures to be freed. All dynamic storage pointed to
            within the <c>addrinfoW</c> structure or structures is also freed.
            </param>
            <remarks>
            <para>
            The <c>FreeAddrInfoW</c> function frees addrinfoW structures dynamically allocated by the Unicode GetAddrInfoW function. The
            <c>FreeAddrInfoW</c> function frees the initial <c>addrinfoW</c> structure pointed to in the pAddrInfo parameter, including any
            buffers to which structure members point, then continues freeing any <c>addrinfoW</c> structures linked by the <c>ai_next</c>
            member of the <c>addrinfoW</c> structure. The <c>FreeAddrInfoW</c> function continues freeing linked structures until a
            <c>NULL</c><c>ai_next</c> member is encountered.
            </para>
            <para>
            Macros in the Winsock header file define a mixed-case function name of <c>FreeAddrInfo</c> and an <c>ADDRINFOT</c> structure.
            This <c>FreeAddrInfo</c> function should be called with the pAddrInfo parameter of a pointer of type <c>ADDRINFOT</c>. When
            UNICODE or _UNICODE is defined, <c>FreeAddrInfo</c> is defined to <c>FreeAddrInfoW</c>, the Unicode version of the function, and
            <c>ADDRINFOT</c> is defined to the addrinfoW structure. When UNICODE or _UNICODE is not defined, <c>FreeAddrInfo</c> is defined
            to freeaddrinfo, the ANSI version of the function, and <c>ADDRINFOT</c> is defined to the addrinfo structure.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.gai_strerror(System.Int32)">
            <summary>
            The <c>gai_strerror</c> function assists in printing error messages based on the EAI_* errors returned by the getaddrinfo
            function. Note that the <c>gai_strerror</c> function is not thread safe, and therefore, use of traditional Windows Sockets
            functions such as the WSAGetLastError function is recommended.
            </summary>
            <param name="ecode">
            Error code from the list of available getaddrinfo error codes. For a complete listing of error codes, see the <c>getaddrinfo</c> function.
            </param>
            <returns>None</returns>
            <remarks>
            If the ecode parameter is not an error code value that getaddrinfo returns, the <c>gai_strerror</c> function returns a pointer
            to a string that indicates an unknown error.
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.GetAddrInfoExCancel(Vanara.PInvoke.HANDLE@)">
            <summary>The <c>GetAddrInfoExCancel</c> function cancels an asynchronous operation by the GetAddrInfoEx function.</summary>
            <param name="lpHandle">
            The handle of the asynchronous operation to cancel. This is the handle returned in the lpNameHandle parameter by the
            GetAddrInfoEx function.
            </param>
            <returns>
            On success, <c>GetAddrInfoExCancel</c> returns <c>NO_ERROR</c> (0). Failure returns a nonzero Windows Sockets error code, as
            found in the Windows Sockets Error Codes.
            </returns>
            <remarks>
            <para>
            The <c>GetAddrInfoExCancel</c> function cancels an asynchronous GetAddrInfoEx operation. The result is that the user's
            completion mechanism, either a callback or an event, is immediately invoked. No results are returned, and the error code
            returned for the <c>GetAddrInfoEx</c> asynchronous operation is set to <c>WSA_E_CANCELLED</c>. If the <c>GetAddrInfoEx</c>
            request has already completed or timed out, or the handle is invalid, and <c>WSA_INVALID_HANDLE</c> will be returned by
            <c>GetAddrInfoExCancel</c> function.
            </para>
            <para>
            Since many of the underlying operations (legacy name service providers, for example) are synchronous, these operations will not
            actually be cancelled. These operations will continue running and consuming resources. Once the last outstanding name service
            provider request has completed, the resources will be released.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.GetAddrInfoExOverlappedResult(System.IntPtr)">
            <summary>
            The <c>GetAddrInfoExOverlappedResult</c> function gets the return code for an <c>OVERLAPPED</c> structure used by an
            asynchronous operation for the GetAddrInfoEx function.
            </summary>
            <param name="lpOverlapped">A pointer to an <c>OVERLAPPED</c> structure for the asynchronous operation.</param>
            <returns>
            On success, the <c>GetAddrInfoExOverlappedResult</c> function returns <c>NO_ERROR</c> (0). When the underlying operation hasn't
            yet completed, the <c>GetAddrInfoExOverlappedResult</c> function returns <c>WSAEINPROGRESS</c>. On failure, the
            <c>GetAddrInfoExOverlappedResult</c> function returns <c>WSAEINVAL</c>.
            </returns>
            <remarks>
            <para>The <c>GetAddrInfoExOverlappedResult</c> function is used with the GetAddrInfoEx function for asynchronous operations.</para>
            <para>
            If the <c>GetAddrInfoExOverlappedResult</c> function returns <c>WSAEINVAL</c>, the only way to distinguish whether
            <c>GetAddrInfoExOverlappedResult</c> function or the asynchronous operation returned the error is to check that the lpOverlapped
            parameter was not NULL. If the lpOverlapped parameter was NULL, then the <c>GetAddrInfoExOverlappedResult</c> function was
            passed a NULL pointer and failed.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.GetAddrInfoExOverlappedResult(System.Threading.NativeOverlapped*)">
            <summary>
            The <c>GetAddrInfoExOverlappedResult</c> function gets the return code for an <c>OVERLAPPED</c> structure used by an
            asynchronous operation for the GetAddrInfoEx function.
            </summary>
            <param name="lpOverlapped">A pointer to an <c>OVERLAPPED</c> structure for the asynchronous operation.</param>
            <returns>
            On success, the <c>GetAddrInfoExOverlappedResult</c> function returns <c>NO_ERROR</c> (0). When the underlying operation hasn't
            yet completed, the <c>GetAddrInfoExOverlappedResult</c> function returns <c>WSAEINPROGRESS</c>. On failure, the
            <c>GetAddrInfoExOverlappedResult</c> function returns <c>WSAEINVAL</c>.
            </returns>
            <remarks>
            <para>The <c>GetAddrInfoExOverlappedResult</c> function is used with the GetAddrInfoEx function for asynchronous operations.</para>
            <para>
            If the <c>GetAddrInfoExOverlappedResult</c> function returns <c>WSAEINVAL</c>, the only way to distinguish whether
            <c>GetAddrInfoExOverlappedResult</c> function or the asynchronous operation returned the error is to check that the lpOverlapped
            parameter was not NULL. If the lpOverlapped parameter was NULL, then the <c>GetAddrInfoExOverlappedResult</c> function was
            passed a NULL pointer and failed.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.GetAddrInfoExW(System.String,System.String,Vanara.PInvoke.Ws2_32.NS,System.Guid*,Vanara.PInvoke.Ws2_32.ADDRINFOEXW*,Vanara.PInvoke.Ws2_32.SafeADDRINFOEXWArray@,Vanara.PInvoke.Ws2_32.TIMEVAL*,System.Threading.NativeOverlapped*,Vanara.PInvoke.Ws2_32.LPLOOKUPSERVICE_COMPLETION_ROUTINE,Vanara.PInvoke.HANDLE*)">
            <summary>
            The <c>GetAddrInfoEx</c> function provides protocol-independent name resolution with additional parameters to qualify which
            namespace providers should handle the request.
            </summary>
            <param name="pName">
            A pointer to a <c>NULL</c>-terminated string containing a host (node) name or a numeric host address string. For the Internet
            protocol, the numeric host address string is a dotted-decimal IPv4 address or an IPv6 hex address.
            </param>
            <param name="pServiceName">
            <para>
            A pointer to an optional <c>NULL</c>-terminated string that contains either a service name or port number represented as a string.
            </para>
            <para>
            A service name is a string alias for a port number. For example, http is an alias for port 80 defined by the Internet
            Engineering Task Force (IETF) as the default port used by web servers for the HTTP protocol. Possible values for the
            pServiceName parameter when a port number is not specified are listed in the following file:
            </para>
            <para><c>%WINDIR%\system32\drivers\etc\services</c></para>
            </param>
            <param name="dwNameSpace">
            <para>
            An optional namespace identifier that determines which namespace providers are queried. Passing a specific namespace identifier
            will result in only namespace providers that support the specified namespace being queried. Specifying <c>NS_ALL</c> will result
            in all installed and active namespace providers being queried.
            </para>
            <para>
            Options for the dwNameSpace parameter are listed in the Winsock2.h include file. Several namespace providers are added on
            Windows Vista and later. Other namespace providers can be installed, so the following possible values are only those commonly
            available. Many other values are possible.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>NS_ALL 0</term>
            <term>All installed and active namespaces.</term>
            </item>
            <item>
            <term>NS_DNS 12</term>
            <term>The domain name system (DNS) namespace.</term>
            </item>
            <item>
            <term>NS_NETBT 13</term>
            <term>The NetBIOS over TCP/IP (NETBT) namespace.</term>
            </item>
            <item>
            <term>NS_WINS 14</term>
            <term>The Windows Internet Naming Service (NS_WINS) namespace.</term>
            </item>
            <item>
            <term>NS_NLA 15</term>
            <term>The network location awareness (NLA) namespace. This namespace identifier is supported on Windows XP and later.</term>
            </item>
            <item>
            <term>NS_BTH 16</term>
            <term>The Bluetooth namespace. This namespace identifier is supported on Windows Vista and later.</term>
            </item>
            <item>
            <term>NS_NTDS 32</term>
            <term>The Windows NT Directory Services (NS_NTDS) namespace.</term>
            </item>
            <item>
            <term>NS_EMAIL 37</term>
            <term>The email namespace. This namespace identifier is supported on Windows Vista and later.</term>
            </item>
            <item>
            <term>NS_PNRPNAME 38</term>
            <term>The peer-to-peer namespace for a specific peer name. This namespace identifier is supported on Windows Vista and later.</term>
            </item>
            <item>
            <term>NS_PNRPCLOUD 39</term>
            <term>
            The peer-to-peer namespace for a collection of peer names. This namespace identifier is supported on Windows Vista and later.
            </term>
            </item>
            </list>
            </param>
            <param name="lpNspId">
            A pointer to an optional GUID of a specific namespace provider to query in the case where multiple namespace providers are
            registered under a single namespace such as <c>NS_DNS</c>. Passing the GUID for specific namespace provider will result in only
            the specified namespace provider being queried. The WSAEnumNameSpaceProviders function can be called to retrieve the GUID for a
            namespace provider.
            </param>
            <param name="hints">
            <para>A pointer to an addrinfoex structure that provides hints about the type of socket the caller supports.</para>
            <para>
            The <c>ai_addrlen</c>, <c>ai_canonname</c>, <c>ai_addr</c>, and <c>ai_next</c> members of the addrinfoex structure pointed to by
            the pHints parameter must be zero or <c>NULL</c>. Otherwise the <c>GetAddrInfoEx</c> function will fail with WSANO_RECOVERY.
            </para>
            <para>See the Remarks for more details.</para>
            </param>
            <param name="ppResult">
            A pointer to a linked list of one or more addrinfoex structures that contains response information about the host.
            </param>
            <param name="timeout">
            <para>
            An optional parameter indicating the time, in milliseconds, to wait for a response from the namespace provider before aborting
            the call.
            </para>
            <para>
            This parameter is only supported when the <c>UNICODE</c> or <c>_UNICODE</c> macro has been defined in the sources before calling
            the <c>GetAddrInfoEx</c> function. Otherwise, this parameter is currently reserved and must be set to <c>NULL</c> since a
            timeout option is not supported.
            </para>
            </param>
            <param name="lpOverlapped">
            <para>An optional pointer to an overlapped structure used for asynchronous operation.</para>
            <para>
            This parameter is only supported when the <c>UNICODE</c> or <c>_UNICODE</c> macro has been defined in the sources before calling
            the <c>GetAddrInfoEx</c> function.
            </para>
            <para>
            On Windows 8 and Windows Server 2012, if no lpCompletionRoutine parameter is specified, the <c>hEvent</c> member of the
            <c>OVERLAPPED</c> structure must be set to a manual-reset event to be called upon completion of an asynchronous call. If a
            completion routine has been specified, the <c>hEvent</c> member must be NULL. When the event specified by <c>hEvent</c> has been
            set, the result of the operation can be retrieved by calling GetAddrInfoExOverlappedResult function.
            </para>
            <para>
            On Windows 8 and Windows Server 2012 whenever the <c>UNICODE</c> or <c>_UNICODE</c> macro is not defined, this parameter is
            currently reserved and must be set to <c>NULL</c>.
            </para>
            <para>
            On Windows 7 and Windows Server 2008 R2 or earlier, this parameter is currently reserved and must be set to <c>NULL</c> since
            asynchronous operations are not supported.
            </para>
            </param>
            <param name="lpCompletionRoutine">
            <para>An optional pointer to a function to be invoked upon successful completion for asynchronous operations.</para>
            <para>
            This parameter is only supported when the <c>UNICODE</c> or <c>_UNICODE</c> macro has been defined in the sources before calling
            the <c>GetAddrInfoEx</c> function.
            </para>
            <para>
            On Windows 8 and Windows Server 2012, if this parameter is specified, it must be a pointer to a function with the following signature:
            </para>
            <para>
            When the asynchronous operation has completed, the completion routine will be invoked with lpOverlapped parameter set to the
            value of lpOverlapped parameter passed to <c>GetAddrInfoEx</c>. The <c>Pointer</c> member of the OVERLAPPED structure will be
            set to the value of the ppResult parameter of the original call. If the <c>Pointer</c> member points to a non-NULL pointer to
            the addrinfoex structure, it is the callers responsibility to call FreeAddrInfoEx to free the <c>addrinfoex</c> structure. The
            dwError parameter passed to the completion routine will be set to a Winsock error code. The dwBytes parameter is reserved for
            future use and must be ignored.
            </para>
            <para>
            On Windows 8 and Windows Server 2012 whenever the <c>UNICODE</c> or <c>_UNICODE</c> macro is not defined, this parameter is
            currently reserved and must be set to <c>NULL</c>.
            </para>
            <para>
            On Windows 7 and Windows Server 2008 R2 or earlier, this parameter is currently reserved and must be set to <c>NULL</c> since
            asynchronous operations are not supported.
            </para>
            </param>
            <param name="lpNameHandle">
            <para>An optional pointer used only for asynchronous operations.</para>
            <para>
            This parameter is only supported when the <c>UNICODE</c> or <c>_UNICODE</c> macro has been defined in the sources before calling
            the <c>GetAddrInfoEx</c> function.
            </para>
            <para>
            On Windows 8 and Windows Server 2012, if the <c>GetAddrInfoEx</c> function will complete asynchronously, the pointer returned in
            this field may be used with the <c>GetAddrInfoExCancel</c> function. The handle returned is valid when <c>GetAddrInfoEx</c>
            returns until the completion routine is called, the event is triggered, or GetAddrInfoExCancel function is called with this handle.
            </para>
            <para>
            On Windows 8 and Windows Server 2012 whenever the <c>UNICODE</c> or <c>_UNICODE</c> macro is not defined, this parameter is
            currently reserved and must be set to <c>NULL</c>.
            </para>
            <para>
            On Windows 7 and Windows Server 2008 R2 or earlier, this parameter is currently reserved and must be set to <c>NULL</c> since
            asynchronous operations are not supported.
            </para>
            </param>
            <returns>
            <para>
            On success, <c>GetAddrInfoEx</c> returns <c>NO_ERROR</c> (0). Failure returns a nonzero Windows Sockets error code, as found in
            the Windows Sockets Error Codes.
            </para>
            <para>
            Most nonzero error codes returned by the <c>GetAddrInfoEx</c> function map to the set of errors outlined by Internet Engineering
            Task Force (IETF) recommendations. The following table shows these error codes and their WSA equivalents. It is recommended that
            the WSA error codes be used, as they offer familiar and comprehensive error information for Winsock programmers.
            </para>
            <list type="table">
            <listheader>
            <term>Error value</term>
            <term>WSA equivalent</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>EAI_AGAIN</term>
            <term>WSATRY_AGAIN</term>
            <term>A temporary failure in name resolution occurred.</term>
            </item>
            <item>
            <term>EAI_BADFLAGS</term>
            <term>WSAEINVAL</term>
            <term>
            An invalid parameter was provided. This error is returned if any of the reserved parameters are not NULL. This error is also
            returned if an invalid value was provided for the ai_flags member of the pHints parameter.
            </term>
            </item>
            <item>
            <term>EAI_FAIL</term>
            <term>WSANO_RECOVERY</term>
            <term>A nonrecoverable failure in name resolution occurred.</term>
            </item>
            <item>
            <term>EAI_FAMILY</term>
            <term>WSAEAFNOSUPPORT</term>
            <term>The ai_family member of the pHints parameter is not supported.</term>
            </item>
            <item>
            <term>EAI_MEMORY</term>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>A memory allocation failure occurred.</term>
            </item>
            <item>
            <term>EAI_NONAME</term>
            <term>WSAHOST_NOT_FOUND</term>
            <term>The name does not resolve for the supplied parameters or the pName and pServiceName parameters were not provided.</term>
            </item>
            <item>
            <term>EAI_SERVICE</term>
            <term>WSATYPE_NOT_FOUND</term>
            <term>The pServiceName parameter is not supported for the specified ai_socktype member of the pHints parameter.</term>
            </item>
            <item>
            <term>EAI_SOCKTYPE</term>
            <term>WSAESOCKTNOSUPPORT</term>
            <term>The ai_socktype member of the pHints parameter is not supported.</term>
            </item>
            </list>
            <para>
            Use the gai_strerror function to print error messages based on the EAI codes returned by the <c>GetAddrInfoEx</c> function. The
            <c>gai_strerror</c> function is provided for compliance with IETF recommendations, but it is not thread safe. Therefore, use of
            traditional Windows Sockets functions such as WSAGetLastError is recommended.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There was insufficient memory to perform the operation.</term>
            </item>
            <item>
            <term>WSAEAFNOSUPPORT</term>
            <term>
            An address incompatible with the requested protocol was used. This error is returned if the ai_family member of the
            addrinfoexstructure pointed to by the pHints parameter is not supported.
            </term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            An invalid argument was supplied. This error is returned if an invalid value was provided for the ai_flags member of the
            addrinfoex structure pointed to by the pHints parameter. This error is also returned when the dwNameSpace parameter is
            NS_PNRPNAME or NS_PNRPCLOUD and the peer-to-peer name service is not operating.
            </term>
            </item>
            <item>
            <term>WSAESOCKTNOSUPPORT</term>
            <term>
            The support for the specified socket type does not exist in this address family. This error is returned if the ai_socktype
            member of the addrinfoex structure pointed to by the pHints parameter is not supported.
            </term>
            </item>
            <item>
            <term>WSAHOST_NOT_FOUND</term>
            <term>
            No such host is known. This error is returned if the name does not resolve for the supplied parameters or the pName and
            pServiceName parameters were not provided.
            </term>
            </item>
            <item>
            <term>WSANO_DATA</term>
            <term>The requested name is valid, but no data of the requested type was found.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred during a database lookup. This error is returned if nonrecoverable error in name resolution occurred.
            </term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSASERVICE_NOT_FOUND</term>
            <term>
            No such service is known. The service cannot be found in the specified name space. This error is returned if the pName or
            pServiceName parameter is not found for the namespace specified in the dwNameSpace parameter or the namespace specified in the
            dwNameSpace parameter is not installed.
            </term>
            </item>
            <item>
            <term>WSATRY_AGAIN</term>
            <term>
            This is usually a temporary error during hostname resolution and means that the local server did not receive a response from an
            authoritative server. This error is returned when a temporary failure in name resolution occurred.
            </term>
            </item>
            <item>
            <term>WSATYPE_NOT_FOUND</term>
            <term>
            The specified class was not found. The pServiceName parameter is not supported for the specified ai_socktype member of the
            addrinfoexstructure pointed to by the pHints parameter.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>GetAddrInfoEx</c> function provides protocol-independent translation from host name to address and from service name to
            port number. The <c>GetAddrInfoEx</c> function is an enhanced version of the getaddrinfo and GetAddrInfoW functions. The
            <c>GetAddrInfoEx</c> function allows specifying the namespace provider to resolve the query.
            </para>
            <para>
            The <c>GetAddrInfoEx</c> function aggregates and returns results from multiple namespace providers, unless a specific namespace
            provider is specified. For use with the IPv6 and IPv4 protocol, name resolution can be by the Domain Name System (DNS), a local
            hosts file, an email provider (the <c>NS_EMAIL</c> namespace), or by other naming mechanisms.
            </para>
            <para>
            When UNICODE or _UNICODE is defined, <c>GetAddrInfoEx</c> is defined to <c>GetAddrInfoExW</c>, the Unicode version of this
            function. The string parameters are defined to the <c>PWSTR</c> data type and the <c>ADDRINFOEXW</c> structure is used. On
            Windows 8 and Windows Server 2012, the timeout, lpOverlapped, lpCompletionRoutine, and lpNameHandle parameters may be used to
            call the <c>GetAddrInfoEx</c> function so that it can complete asynchronously.
            </para>
            <para>
            When UNICODE or _UNICODE is not defined, <c>GetAddrInfoEx</c> is defined to <c>GetAddrInfoExA</c>, the ANSI version of this
            function. The string parameters are of the <c>PCSTR</c> data type and the <c>ADDRINFOEXA</c> structure is used. The timeout,
            lpOverlapped, lpCompletionRoutine, and lpNameHandle parameters must be set to <c>NULL</c>.
            </para>
            <para>
            One or both of the pName or pServiceName parameters must point to a <c>NULL</c>-terminated string. Generally both are provided.
            </para>
            <para>
            Upon success, a linked list of addrinfoex structures is returned in the ppResult parameter. The list can be processed by
            following the pointer provided in the <c>ai_next</c> member of each returned <c>addrinfoex</c> structure until a <c>NULL</c>
            pointer is encountered. In each returned <c>addrinfoex</c> structure, the <c>ai_family</c>, <c>ai_socktype</c>, and
            <c>ai_protocol</c> members correspond to respective arguments in a socket or WSASocket function call. Also, the <c>ai_addr</c>
            member in each returned <c>addrinfoex</c> structure points to a filled-in socket address structure, the length of which is
            specified in its <c>ai_addrlen</c> member.
            </para>
            <para>
            If the pName parameter points to a computer name, all permanent addresses for the computer that can be used as a source address
            are returned. On Windows Vista and later, these addresses would include all unicast IP addresses returned by the
            GetUnicastIpAddressTable or GetUnicastIpAddressEntry functions in which the <c>SkipAsSource</c> member is set to false in the
            MIB_UNICASTIPADDRESS_ROW structure.
            </para>
            <para>If the pName parameter points to a string equal to "localhost", all loopback addresses on the local computer are returned.</para>
            <para>If the pName parameter contains an empty string, all registered addresses on the local computer are returned.</para>
            <para>
            On Windows Server 2003 and later if the pName parameter points to a string equal to "..localmachine", all registered addresses
            on the local computer are returned.
            </para>
            <para>
            If the pName parameter refers to a cluster virtual server name, only virtual server addresses are returned. On Windows Vista and
            later, these addresses would include all unicast IP addresses returned by the GetUnicastIpAddressTable or
            GetUnicastIpAddressEntry functions in which the <c>SkipAsSource</c> member is set to true in the MIB_UNICASTIPADDRESS_ROW
            structure. See Windows Clustering for more information about clustering.
            </para>
            <para>
            Windows 7 with Service Pack 1 (SP1) and Windows Server 2008 R2 with Service Pack 1 (SP1) add support to Netsh.exe for setting
            the SkipAsSource attribute on an IP address. This also changes the behavior such that if the <c>SkipAsSource</c> member in the
            MIB_UNICASTIPADDRESS_ROW structure is set to false, the IP address will be registered in DNS. If the <c>SkipAsSource</c> member
            is set to true, the IP address is not registered in DNS.
            </para>
            <para>
            A hotfix is available for Windows 7 and Windows Server 2008 R2 that adds support to Netsh.exe for setting the SkipAsSource
            attribute on an IP address. This hotfix also changes behavior such that if the <c>SkipAsSource</c> member in the
            MIB_UNICASTIPADDRESS_ROW structure is set to false, the IP address will be registered in DNS. If the <c>SkipAsSource</c> member
            is set to true, the IP address is not registered in DNS. For more information, see Knowledge Base (KB) 2386184.
            </para>
            <para>
            A similar hotfix is also available for Windows Vista with Service Pack 2 (SP2) and Windows Server 2008 with Service Pack 2 (SP2)
            that adds support to Netsh.exe for setting the SkipAsSource attribute on an IP address. This hotfix also changes behavior such
            that if the <c>SkipAsSource</c> member in the MIB_UNICASTIPADDRESS_ROW structure is set to false, the IP address will be
            registered in DNS. If the <c>SkipAsSource</c> member is set to true, the IP address is not registered in DNS. For more
            information, see Knowledge Base (KB) 975808.
            </para>
            <para>
            Callers of the <c>GetAddrInfoEx</c> function can provide hints about the type of socket supported through an addrinfoex
            structure pointed to by the pHints parameter. When the pHints parameter is used, the following rules apply to its associated
            <c>addrinfoex</c> structure:
            </para>
            <list type="bullet">
            <item>
            <term>
            A value of <c>AF_UNSPEC</c> for <c>ai_family</c> indicates the caller will accept only the <c>AF_INET</c> and <c>AF_INET6</c>
            address families. Note that <c>AF_UNSPEC</c> and <c>PF_UNSPEC</c> are the same.
            </term>
            </item>
            <item>
            <term>A value of zero for <c>ai_socktype</c> indicates the caller will accept any socket type.</term>
            </item>
            <item>
            <term>A value of zero for <c>ai_protocol</c> indicates the caller will accept any protocol.</term>
            </item>
            <item>
            <term>The <c>ai_addrlen</c> member must be set to zero.</term>
            </item>
            <item>
            <term>The <c>ai_canonname</c> member must be set to <c>NULL</c>.</term>
            </item>
            <item>
            <term>The <c>ai_addr</c> member must be set to <c>NULL</c>.</term>
            </item>
            <item>
            <term>The <c>ai_next</c> member must be set to <c>NULL</c>.</term>
            </item>
            </list>
            <para>
            Other values in the addrinfoex structure provided in the pHints parameter indicate specific requirements. For example, if the
            caller handles only IPv4 and does not handle IPv6, the <c>ai_family</c> member should be set to <c>AF_INET</c>. For another
            example, if the caller handles only TCP and does not handle UDP, the <c>ai_socktype</c> member should be set to <c>SOCK_STREAM</c>.
            </para>
            <para>
            If the pHints parameter is a <c>NULL</c> pointer, the <c>GetAddrInfoEx</c> function treats it as if the addrinfoex structure in
            pHints were initialized with its <c>ai_family</c> member set to <c>AF_UNSPEC</c> and all other members set to <c>NULL</c> or zero.
            </para>
            <para>
            When <c>GetAddrInfoEx</c> is called from a service, if the operation is the result of a user process calling the service, the
            service should impersonate the user. This is to allow security to be properly enforced.
            </para>
            <para>
            The <c>GetAddrInfoEx</c> function can be used to convert a text string representation of an IP address to an addrinfoexstructure
            that contains a sockaddr structure for the IP address and other information. To be used in this way, the string pointed to by
            the pName parameter must contain a text representation of an IP address and the <c>addrinfoex</c> structure pointed to by the
            pHints parameter must have the AI_NUMERICHOST flag set in the <c>ai_flags</c> member. The string pointed to by the pName
            parameter may contain a text representation of either an IPv4 or an IPv6 address. The text IP address is converted to an
            <c>addrinfoex</c> structure pointed to by the ppResult parameter. The returned <c>addrinfoex</c> structure contains a
            <c>sockaddr</c> structure for the IP address along with additional information about the IP address.
            </para>
            <para>
            Multiple namespace providers may be installed on a local computer for the same namespace. For example, the base Windows TCP/IP
            networking software registers for the NS_DNS namespace. The Microsoft Forefront Threat Management Gateway (TMG) and the older
            Microsoft Internet Security and Acceleration (ISA) Server include Firewall Client software that also registers for the NS_DNS
            namespace. When the dwNameSpace parameter is set to a value (NS_DNS, for example) and the lpNspId parameter is <c>NULL</c>, the
            results returned by the <c>GetAddrInfoEx</c> function are the merged results from all namespace providers that register for the
            specified namespace with duplicate results eliminated. The lpNspId parameter should be set to the GUID of the specific namespace
            provider if only a single namespace provider is to be queried.
            </para>
            <para>
            If the pNameSpace parameter is set to NS_ALL, then the results from querying all namespace providers is merged and returned. In
            this case, duplicate responses may be returned in the results pointed to by the ppResult parameter if multiple namespace
            providers return the same information.
            </para>
            <para>
            On Windows 8 and Windows Server 2012, if the <c>GetAddrInfoEx</c> function will complete asynchronously, the pointer returned in
            the lpNameHandle parameter may be used with the <c>GetAddrInfoExCancel</c> function. The handle returned is valid when
            <c>GetAddrInfoEx</c> returns until the completion routine is called, the event is triggered, or GetAddrInfoExCancel function is
            called with this handle.
            </para>
            <para>Freeing Address Information from Dynamic Allocation</para>
            <para>
            All information returned by the <c>GetAddrInfoEx</c> function pointed to by the ppResult parameter is dynamically allocated,
            including all addrinfoex structures, socket address structures, and canonical host name strings pointed to by <c>addrinfoex</c>
            structures. Memory allocated by a successful call to this function must be released with a subsequent call to FreeAddrInfoEx.
            </para>
            <para>Example Code</para>
            <para>The following example demonstrates the use of the <c>GetAddrInfoEx</c> function.</para>
            <para>
            The following example demonstrates how to use the <c>GetAddrInfoEx</c> function asynchronous to resolve a name to an IP address..
            </para>
            <para>
            <c>Note</c> Ensure that the development environment targets the newest version of Ws2tcpip.h which includes structure and
            function definitions for addrinfoex and <c>GetAddrInfoEx</c>, respectively.
            </para>
            <para>Internationalized Domain Names</para>
            <para>Internet host names typically consist of a very restricted set of characters:</para>
            <list type="bullet">
            <item>
            <term>Upper and lower case ASCII letters from the English alphabet.</term>
            </item>
            <item>
            <term>Digits from 0 to 9.</term>
            </item>
            <item>
            <term>ASCII hyphen characters.</term>
            </item>
            </list>
            <para>
            With the growth of the Internet, there is a growing need to identify Internet host names for other languages not represented by
            the ASCII character set. Identifiers which facilitate this need and allow non-ASCII characters (Unicode) to be represented as
            special ASCII character strings are known as Internationalized Domain Names (IDNs). A mechanism called Internationalizing Domain
            Names in Applications (IDNA) is used to handle IDNs in a standard fashion. The specifications for IDNs and IDNA are documented
            in RFC 3490, RTF 5890, and RFC 6365 published by the Internet Engineering Task Force (IETF).
            </para>
            <para>
            On Windows 8 and Windows Server 2012, the <c>GetAddrInfoEx</c> function provides support for Internationalized Domain Name (IDN)
            parsing applied to the name passed in the pName parameter. Winsock performs Punycode/IDN encoding and conversion. This behavior
            can be disabled using the <c>AI_DISABLE_IDN_ENCODING</c> flag discussed below.
            </para>
            <para>
            On Windows 7 and Windows Server 2008 R2 or earlier, the <c>GetAddrInfoEx</c> function does not currently provide support for IDN
            parsing applied to the name passed in the pName parameter. The wide character version of the <c>GetAddrInfoEx</c> function does
            not use Punycode to convert an IDN Punycode format as per RFC 3490. The wide character version of the <c>GetAddrInfoEx</c>
            function when querying DNS encodes the Unicode name in UTF-8 format, the format used by Microsoft DNS servers in an enterprise environment.
            </para>
            <para>
            Several functions on Windows Vista and later support conversion between Unicode labels in an IDN to their ASCII equivalents. The
            resulting representation of each Unicode label contains only ASCII characters and starts with the xn-- prefix if the Unicode
            label contained any non-ASCII characters. The reason for this is to support existing DNS servers on the Internet, since some DNS
            tools and servers only support ASCII characters (see RFC 3490).
            </para>
            <para>
            The IdnToAscii function uses Punycode to convert an IDN to the ASCII representation of the original Unicode string using the
            standard algorithm defined in RFC 3490. The IdnToUnicode function converts the ASCII form of an IDN to the normal Unicode UTF-16
            encoding syntax. For more information and links to related draft standards, see Handling Internationalized Domain Names (IDNs).
            </para>
            <para>
            The IdnToAscii function can be used to convert an IDN name to an ASCII form that then can be passed in the pName parameter to
            the <c>GetAddrInfoEx</c> function when the ASCII version of this function is used (when UNICODE and _UNICODE are not defined).
            To pass this IDN name to the <c>GetAddrInfoEx</c> function when the wide character version of this function is used (when
            UNICODE or _UNICODE is defined), you can use the MultiByteToWideChar function to convert the <c>CHAR</c> string into a
            <c>WCHAR</c> string.
            </para>
            <para>Use of ai_flags in the hints parameter</para>
            <para>
            Flags in the <c>ai_flags</c> member of the optional addrinfoex structure provided in the hints parameter modify the behavior of
            the function.
            </para>
            <para>
            These flag bits are defined in the Ws2def.h header file on the Microsoft Windows Software Development Kit (SDK) for Windows 7.
            These flag bits are defined in the Ws2tcpip.h header file on the Windows SDK for Windows Server 2008 and Windows Vista. These
            flag bits are defined in the Ws2tcpip.h header file on the Platform Software Development Kit (SDK) for Windows Server 2003, and
            Windows XP.
            </para>
            <para>The flag bits can be a combination of the following:</para>
            <list type="table">
            <listheader>
            <term>Flag Bits</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>AI_PASSIVE</term>
            <term>
            Setting the AI_PASSIVE flag indicates the caller intends to use the returned socket address structure in a call to the bind
            function. When the AI_PASSIVE flag is set and pName is a NULL pointer, the IP address portion of the socket address structure is
            set to INADDR_ANY for IPv4 addresses and IN6ADDR_ANY_INIT for IPv6 addresses. When the AI_PASSIVE flag is not set, the returned
            socket address structure is ready for a call to the connect function for a connection-oriented protocol, or ready for a call to
            either the connect, sendto, or send functions for a connectionless protocol. If the pName parameter is a NULL pointer in this
            case, the IP address portion of the socket address structure is set to the loopback address.
            </term>
            </item>
            <item>
            <term>AI_CANONNAME</term>
            <term>
            If neither AI_CANONNAME nor AI_NUMERICHOST is used, the GetAddrInfoEx function attempts resolution. If a literal string is
            passed GetAddrInfoEx attempts to convert the string, and if a host name is passed the GetAddrInfoEx function attempts to resolve
            the name to an address or multiple addresses. When the AI_CANONNAME bit is set, the pName parameter cannot be NULL. Otherwise
            the GetAddrInfoEx function will fail with WSANO_RECOVERY. When the AI_CANONNAME bit is set and the GetAddrInfoEx function
            returns success, the ai_canonname member in the ppResult parameter points to a NULL-terminated string that contains the
            canonical name of the specified node.
            </term>
            </item>
            <item>
            <term>AI_NUMERICHOST</term>
            <term>
            When the AI_NUMERICHOST bit is set, the pName parameter must contain a non-NULL numeric host address string, otherwise the
            EAI_NONAME error is returned. This flag prevents a name resolution service from being called.
            </term>
            </item>
            <item>
            <term>AI_NUMERICSERV</term>
            <term>
            When the AI_NUMERICSERV bit is set, the pServiceName parameter must contain a non-NULL numeric port number, otherwise the
            EAI_NONAME error is returned. This flag prevents a name resolution service from being called. The AI_NUMERICSERV flag is defined
            on Windows SDK for Windows Vista and later. The AI_NUMERICSERV flag is not supported by Microsoft providers.
            </term>
            </item>
            <item>
            <term>AI_ALL</term>
            <term>
            If the AI_ALL bit is set, a request is made for IPv6 addresses and IPv4 addresses with AI_V4MAPPED. The AI_ALL flag is defined
            on the Windows SDK for Windows Vista and later. The AI_ALL flag is supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AI_ADDRCONFIG</term>
            <term>
            If the AI_ADDRCONFIG bit is set, GetAddrInfoEx will resolve only if a global address is configured. If AI_ADDRCONFIG flag is
            specified, IPv4 addresses shall be returned only if an IPv4 address is configured on the local system, and IPv6 addresses shall
            be returned only if an IPv6 address is configured on the local system. The IPv4 or IPv6 loopback address is not considered a
            valid global address. The AI_ADDRCONFIG flag is defined on the Windows SDK for Windows Vista and later. The AI_ADDRCONFIG flag
            is supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AI_V4MAPPED</term>
            <term>
            If the AI_V4MAPPED bit is set and a request for IPv6 addresses fails, a name service request is made for IPv4 addresses and
            these addresses are converted to IPv4-mapped IPv6 address format. The AI_V4MAPPED flag is defined on the Windows SDK for Windows
            Vista and later. The AI_V4MAPPED flag is supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AI_NON_AUTHORITATIVE</term>
            <term>
            If the AI_NON_AUTHORITATIVE bit is set, the NS_EMAIL namespace provider returns both authoritative and non-authoritative
            results. If the AI_NON_AUTHORITATIVE bit is not set, the NS_EMAIL namespace provider returns only authoritative results. The
            AI_NON_AUTHORITATIVE flag is defined on the Windows SDK for Windows Vista and later. The AI_NON_AUTHORITATIVE flag is supported
            on Windows Vista and later and applies only to the NS_EMAIL namespace.
            </term>
            </item>
            <item>
            <term>AI_SECURE</term>
            <term>
            If the AI_SECURE bit is set, the NS_EMAIL namespace provider will return results that were obtained with enhanced security to
            minimize possible spoofing. The AI_SECURE flag is defined on the Windows SDK for Windows Vista and later. The AI_SECURE flag is
            supported on Windows Vista and later and applies only to the NS_EMAIL namespace.
            </term>
            </item>
            <item>
            <term>AI_RETURN_PREFERRED_NAMES</term>
            <term>
            If the AI_RETURN_PREFERRED_NAMES is set, then no name should be provided in the pName parameter. The NS_EMAIL namespace provider
            will return preferred names for publication. The AI_RETURN_PREFERRED_NAMES flag is defined on the Windows SDK for Windows Vista
            and later. The AI_RETURN_PREFERRED_NAMES flag is supported on Windows Vista and later and applies only to the NS_EMAIL namespace.
            </term>
            </item>
            <item>
            <term>AI_FQDN</term>
            <term>
            If the AI_FQDN is set and a flat name (single label) is specified, GetAddrInfoEx will return the fully qualified domain name
            that the name eventually resolved to. The fully qualified domain name is returned in the ai_canonname member in the associated
            addrinfoex structure. This is different than AI_CANONNAME bit flag that returns the canonical name registered in DNS which may
            be different than the fully qualified domain name that the flat name resolved to. When the AI_FQDN bit is set, the pName
            parameter cannot be NULL. Otherwise the GetAddrInfoEx function will fail with WSANO_RECOVERY. On Windows 8 and Windows Server
            2012, both the AI_FQDN and AI_CANONNAME bits can be set. If the GetAddrInfoEx function is called with both the AI_FQDN and
            AI_CANONNAME bits, the ppResult parameter returns a pointer to an addrinfoex2 structure, not an addrinfoex structure. On Windows
            7 and Windows Server 2008 R2, only one of the AI_FQDN and AI_CANONNAME bits can be set. The GetAddrInfoEx function will fail if
            both flags are present with EAI_BADFLAGS. Windows 7: The AI_FQDN flag is defined on the Windows SDK for Windows 7 and later. The
            AI_FQDN flag is supported on Windows 7 and later.
            </term>
            </item>
            <item>
            <term>AI_FILESERVER</term>
            <term>
            If the AI_FILESERVER is set, this is a hint to the namespace provider that the hostname being queried is being used in file
            share scenario. The namespace provider may ignore this hint. Windows 7: The AI_FILESERVER flag is defined on the Windows SDK for
            Windows 7 and later. The AI_FILESERVER flag is supported on Windows 7 and later.
            </term>
            </item>
            <item>
            <term>AI_DISABLE_IDN_ENCODING</term>
            <term>
            If the AI_DISABLE_IDN_ENCODING is set, this disables the automatic International Domain Name encoding using Punycode in the name
            resolution functions called by the GetAddrInfoEx function. Windows 8: The AI_DISABLE_IDN_ENCODING flag is defined on the Windows
            SDK for Windows 8 and later. The AI_DISABLE_IDN_ENCODING flag is supported on Windows 8 and later.
            </term>
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.GetAddrInfoW(System.String,System.String,Vanara.PInvoke.Ws2_32.ADDRINFOW@,Vanara.PInvoke.Ws2_32.SafeADDRINFOWArray@)">
            <summary>The <c>GetAddrInfoW</c> function provides protocol-independent translation from a Unicode host name to an address.</summary>
            <param name="pNodeName">
            A pointer to a <c>NULL</c>-terminated Unicode string that contains a host (node) name or a numeric host address string. For the
            Internet protocol, the numeric host address string is a dotted-decimal IPv4 address or an IPv6 hex address.
            </param>
            <param name="pServiceName">
            <para>
            A pointer to a <c>NULL</c>-terminated Unicode string that contains either a service name or port number represented as a string.
            </para>
            <para>
            A service name is a string alias for a port number. For example, http is an alias for port 80 defined by the Internet
            Engineering Task Force (IETF) as the default port used by web servers for the HTTP protocol. Possible values for the
            pServiceName parameter when a port number is not specified are listed in the following file:
            </para>
            </param>
            <param name="pHints">
            <para>A pointer to an addrinfoW structure that provides hints about the type of socket the caller supports.</para>
            <para>
            The <c>ai_addrlen</c>, <c>ai_canonname</c>, <c>ai_addr</c>, and <c>ai_next</c> members of the addrinfoW structure pointed to by
            the pHints parameter must be zero or <c>NULL</c>. Otherwise the GetAddrInfoEx function will fail with WSANO_RECOVERY.
            </para>
            <para>See the Remarks for more details.</para>
            </param>
            <param name="ppResult">
            A pointer to a linked list of one or more addrinfoW structures that contains response information about the host.
            </param>
            <returns>
            <para>Success returns zero. Failure returns a nonzero Windows Sockets error code, as found in the Windows Sockets Error Codes.</para>
            <para>
            Most nonzero error codes returned by the <c>GetAddrInfoW</c> function map to the set of errors outlined by Internet Engineering
            Task Force (IETF) recommendations. The following table lists these error codes and their WSA equivalents. It is recommended that
            the WSA error codes be used, as they offer familiar and comprehensive error information for Winsock programmers.
            </para>
            <list type="table">
            <listheader>
            <term>Error value</term>
            <term>WSA equivalent</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>EAI_AGAIN</term>
            <term>WSATRY_AGAIN</term>
            <term>A temporary failure in name resolution occurred.</term>
            </item>
            <item>
            <term>EAI_BADFLAGS</term>
            <term>WSAEINVAL</term>
            <term>An invalid value was provided for the ai_flags member of the pHints parameter.</term>
            </item>
            <item>
            <term>EAI_FAIL</term>
            <term>WSANO_RECOVERY</term>
            <term>A nonrecoverable failure in name resolution occurred.</term>
            </item>
            <item>
            <term>EAI_FAMILY</term>
            <term>WSAEAFNOSUPPORT</term>
            <term>The ai_family member of the pHints parameter is not supported.</term>
            </item>
            <item>
            <term>EAI_MEMORY</term>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>A memory allocation failure occurred.</term>
            </item>
            <item>
            <term>EAI_NONAME</term>
            <term>WSAHOST_NOT_FOUND</term>
            <term>The name does not resolve for the supplied parameters or the pNodeName and pServiceName parameters were not provided.</term>
            </item>
            <item>
            <term>EAI_SERVICE</term>
            <term>WSATYPE_NOT_FOUND</term>
            <term>The pServiceName parameter is not supported for the specified ai_socktype member of the pHints parameter.</term>
            </item>
            <item>
            <term>EAI_SOCKTYPE</term>
            <term>WSAESOCKTNOSUPPORT</term>
            <term>The ai_socktype member of the pHints parameter is not supported.</term>
            </item>
            </list>
            <para>
            Use the gai_strerror function to print error messages based on the EAI_* codes returned by the <c>GetAddrInfoW</c> function. The
            <c>gai_strerror</c> function is provided for compliance with IETF recommendations, but it is not thread safe. Therefore, use of
            a traditional Windows Sockets function, such as WSAGetLastError, is recommended.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>There was insufficient memory to perform the operation.</term>
            </item>
            <item>
            <term>WSAEAFNOSUPPORT</term>
            <term>
            An address incompatible with the requested protocol was used. This error is returned if the ai_family member of the
            addrinfoWstructure pointed to by the hints parameter is not supported.
            </term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>
            An invalid argument was supplied. This error is returned if an invalid value was provided for the ai_flags member of the
            addrinfoWstructure pointed to by the hints parameter.
            </term>
            </item>
            <item>
            <term>WSAESOCKTNOSUPPORT</term>
            <term>
            The support for the specified socket type does not exist in this address family. This error is returned if the ai_socktype
            member of the addrinfoWstructure pointed to by the hints parameter is not supported.
            </term>
            </item>
            <item>
            <term>WSAHOST_NOT_FOUND</term>
            <term>
            No such host is known. This error is returned if the name does not resolve for the supplied parameters or the pNodename and
            pServicename parameters were not provided.
            </term>
            </item>
            <item>
            <term>WSANO_DATA</term>
            <term>The requested name is valid, but no data of the requested type was found.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>
            A nonrecoverable error occurred during a database lookup. This error is returned if nonrecoverable error in name resolution occurred.
            </term>
            </item>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSATRY_AGAIN</term>
            <term>
            This is usually a temporary error during hostname resolution and means that the local server did not receive a response from an
            authoritative server. This error is returned when a temporary failure in name resolution occurred.
            </term>
            </item>
            <item>
            <term>WSATYPE_NOT_FOUND</term>
            <term>
            The specified class was not found. The pServiceName parameter is not supported for the specified ai_socktype member of the
            addrinfoWstructure pointed to by the hints parameter.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>GetAddrInfoW</c> function is the Unicode version of a function that provides protocol-independent translation from host
            name to address. The ANSI version of this function is getaddrinfo.
            </para>
            <para>
            The <c>GetAddrInfoW</c> function returns results for the <c>NS_DNS</c> namespace. The <c>GetAddrInfoW</c> function aggregates
            all responses if more than one namespace provider returns information. For use with the IPv6 and IPv4 protocol, name resolution
            can be by the Domain Name System (DNS), a local hosts file, or by other naming mechanisms for the <c>NS_DNS</c> namespace.
            </para>
            <para>
            Macros in the Winsock header file define a mixed-case function name of <c>GetAddrInfo</c> and a <c>ADDRINFOT</c> structure. This
            <c>GetAddrInfo</c> function should be called with the pNodeName and pServiceName parameters of a pointer of type <c>TCHAR</c>
            and the pHints and ppResult parameters of a pointer of type <c>ADDRINFOT</c>. When UNICODE or _UNICODE is defined,
            <c>GetAddrInfo</c> is defined to <c>GetAddrInfoW</c>, the Unicode version of the function, and <c>ADDRINFOT</c> is defined to
            the addrinfoW structure. When UNICODE or _UNICODE is not defined, <c>GetAddrInfo</c> is defined to getaddrinfo, the ANSI version
            of the function, and <c>ADDRINFOT</c> is defined to the addrinfo structure.
            </para>
            <para>
            One or both of the pNodeName or pServiceName parameters must point to a <c>NULL</c>-terminated Unicode string; generally both
            are provided.
            </para>
            <para>
            Upon success, a linked list of addrinfoW structures is returned in the ppResult parameter. The list can be processed by
            following the pointer provided in the <c>ai_next</c> member of each returned <c>addrinfoW</c> structure until a <c>NULL</c>
            pointer is encountered. In each returned <c>addrinfoW</c> structure, the <c>ai_family</c>, <c>ai_socktype</c>, and
            <c>ai_protocol</c> members correspond to respective arguments in a socket or WSASocket function call. Also, the <c>ai_addr</c>
            member in each returned <c>addrinfoW</c> structure points to a filled-in socket address structure, the length of which is
            specified in its <c>ai_addrlen</c> member.
            </para>
            <para>
            If the pNodeName parameter points to a computer name, all permanent addresses for the computer that can be used as a source
            address are returned. On Windows Vista and later, these addresses would include all unicast IP addresses returned by the
            GetUnicastIpAddressTable or GetUnicastIpAddressEntry functions in which the <c>SkipAsSource</c> member is set to false in the
            MIB_UNICASTIPADDRESS_ROW structure.
            </para>
            <para>If the pNodeName parameter points to a string equal to "localhost", all loopback addresses on the local computer are returned.</para>
            <para>If the pNodeName parameter contains an empty string, all registered addresses on the local computer are returned.</para>
            <para>
            On Windows Server 2003 and later if the pNodeName parameter points to a string equal to "..localmachine", all registered
            addresses on the local computer are returned.
            </para>
            <para>
            If the pNodeName parameter refers to a cluster virtual server name, only virtual server addresses are returned. On Windows Vista
            and later, these addresses would include all unicast IP addresses returned by the GetUnicastIpAddressTable or
            GetUnicastIpAddressEntry functions in which the <c>SkipAsSource</c> member is set to true in the MIB_UNICASTIPADDRESS_ROW
            structure. See Windows Clustering for more information about clustering.
            </para>
            <para>
            Windows 7 with Service Pack 1 (SP1) and Windows Server 2008 R2 with Service Pack 1 (SP1) add support to Netsh.exe for setting
            the SkipAsSource attribute on an IP address. This also changes the behavior such that if the <c>SkipAsSource</c> member in the
            MIB_UNICASTIPADDRESS_ROW structure is set to false, the IP address will be registered in DNS. If the <c>SkipAsSource</c> member
            is set to true, the IP address is not registered in DNS.
            </para>
            <para>
            A hotfix is available for Windows 7 and Windows Server 2008 R2 that adds support to Netsh.exe for setting the SkipAsSource
            attribute on an IP address. This hotfix also changes behavior such that if the <c>SkipAsSource</c> member in the
            MIB_UNICASTIPADDRESS_ROW structure is set to false, the IP address will be registered in DNS. If the <c>SkipAsSource</c> member
            is set to true, the IP address is not registered in DNS. For more information, see Knowledge Base (KB) 2386184.
            </para>
            <para>
            A similar hotfix is also available for Windows Vista with Service Pack 2 (SP2) and Windows Server 2008 with Service Pack 2 (SP2)
            that adds support to Netsh.exe for setting the SkipAsSource attribute on an IP address. This hotfix also changes behavior such
            that if the <c>SkipAsSource</c> member in the MIB_UNICASTIPADDRESS_ROW structure is set to false, the IP address will be
            registered in DNS. If the <c>SkipAsSource</c> member is set to true, the IP address is not registered in DNS. For more
            information, see Knowledge Base (KB) 975808.
            </para>
            <para>
            Callers of the <c>GetAddrInfoW</c> function can provide hints about the type of socket supported through an addrinfoW structure
            pointed to by the pHints parameter. When the pHints parameter is used, the following rules apply to its associated
            <c>addrinfoW</c> structure:
            </para>
            <list type="bullet">
            <item>
            <term>
            A value of <c>AF_UNSPEC</c> for <c>ai_family</c> indicates the caller will accept only the <c>AF_INET</c> and <c>AF_INET6</c>
            address families. Note that <c>AF_UNSPEC</c> and <c>PF_UNSPEC</c> are the same.
            </term>
            </item>
            <item>
            <term>A value of zero for <c>ai_socktype</c> indicates the caller will accept any socket type.</term>
            </item>
            <item>
            <term>A value of zero for <c>ai_protocol</c> indicates the caller will accept any protocol.</term>
            </item>
            <item>
            <term>The <c>ai_addrlen</c> member must be set to zero.</term>
            </item>
            <item>
            <term>The <c>ai_canonname</c> member must be set to <c>NULL</c>.</term>
            </item>
            <item>
            <term>The <c>ai_addr</c> member must be set to <c>NULL</c>.</term>
            </item>
            <item>
            <term>The <c>ai_next</c> member must be set to <c>NULL</c>.</term>
            </item>
            </list>
            <para>
            Other values in the addrinfoW structure provided in the pHints parameter indicate specific requirements. For example, if the
            caller handles only IPv4 and does not handle IPv6, the <c>ai_family</c> member should be set to <c>AF_INET</c>. For another
            example, if the caller handles only TCP and does not handle UDP, the <c>ai_socktype</c> member should be set to <c>SOCK_STREAM</c>.
            </para>
            <para>
            If the pHints parameter is a <c>NULL</c> pointer, the <c>GetAddrInfoW</c> function handles it as if the addrinfoW structure in
            pHints were initialized with its <c>ai_family</c> member set to <c>AF_UNSPEC</c> and all other members set to zero.
            </para>
            <para>
            On Windows Vista and later when <c>GetAddrInfoW</c> is called from a service, if the operation is the result of a user process
            calling the service, then the service should impersonate the user. This is to allow security to be properly enforced.
            </para>
            <para>
            The <c>GetAddrInfoW</c> function can be used to convert a text string representation of an IP address to an addrinfoWstructure
            that contains a sockaddr structure for the IP address and other information. To be used in this way, the string pointed to by
            the pNodeName parameter must contain a text representation of an IP address and the <c>addrinfoW</c> structure pointed to by the
            pHints parameter must have the <c>AI_NUMERICHOST</c> flag set in the <c>ai_flags</c> member. The string pointed to by the
            pNodeName parameter may contain a text representation of either an IPv4 or an IPv6 address. The text IP address is converted to
            an <c>addrinfoW</c> structure pointed to by the ppResult parameter. The returned <c>addrinfoW</c> structure contains a
            <c>sockaddr</c> structure for the IP address along with additional information about the IP address. For this method to work
            with an IPv6 address string on Windows Server 2003 and Windows XP, the IPv6 protocol must be installed on the local computer.
            Otherwise, the WSAHOST_NOT_FOUND error is returned.
            </para>
            <para>Freeing Address Information from Dynamic Allocation</para>
            <para>
            All information returned by the <c>GetAddrInfoW</c> function pointed to by the ppResult parameter is dynamically allocated,
            including all addrinfoW structures, socket address structures, and canonical host name strings pointed to by <c>addrinfoW</c>
            structures. Memory allocated by a successful call to this function must be released with a subsequent call to FreeAddrInfoW.
            </para>
            <para>Example Code</para>
            <para>The following code example shows how to use the <c>GetAddrInfoW</c> function.</para>
            <para>
            <c>Note</c> Ensure that the development environment targets the newest version of Ws2tcpip.h which includes structure and
            function definitions for addrinfoW and <c>GetAddrInfoW</c>, respectively.
            </para>
            <para>Internationalized Domain Names</para>
            <para>Internet host names typically consist of a very restricted set of characters:</para>
            <list type="bullet">
            <item>
            <term>Upper and lower case ASCII letters from the English alphabet.</term>
            </item>
            <item>
            <term>Digits from 0 to 9.</term>
            </item>
            <item>
            <term>ASCII hyphen characters.</term>
            </item>
            </list>
            <para>
            With the growth of the Internet, there is a growing need to identify Internet host names for other languages not represented by
            the ASCII character set. Identifiers which facilitate this need and allow non-ASCII characters (Unicode) to be represented as
            special ASCII character strings are known as Internationalized Domain Names (IDNs). A mechanism called Internationalizing Domain
            Names in Applications (IDNA) is used to handle IDNs in a standard fashion. The specifications for IDNs and IDNA are documented
            in RFC 3490, RTF 5890, and RFC 6365 published by the Internet Engineering Task Force (IETF).
            </para>
            <para>
            On Windows 8 and Windows Server 2012, the <c>GetAddrInfoW</c> function provides support for Internationalized Domain Name (IDN)
            parsing applied to the name passed in the pNodeName parameter. Winsock performs Punycode/IDN encoding and conversion. This
            behavior can be disabled using the <c>AI_DISABLE_IDN_ENCODING</c> flag discussed below.
            </para>
            <para>
            On Windows 7 and Windows Server 2008 R2 or earlier, the <c>GetAddrInfoW</c> function does not currently provide support for IDN
            parsing applied to the name passed in the pNodeName parameter. Winsock does not perform any Punycode/IDN conversion. The
            <c>GetAddrInfoW</c> function does not use Punycode to convert an IDN as per RFC 3490. The <c>GetAddrInfoW</c> function when
            querying DNS encodes the Unicode name in UTF-8 format, the format used by Microsoft DNS servers in an enterprise environment.
            </para>
            <para>
            Several functions on Windows Vista and later support conversion between Unicode labels in an IDN to their ASCII equivalents. The
            resulting representation of each Unicode label contains only ASCII characters and starts with the xn-- prefix if the Unicode
            label contained any non-ASCII characters. The reason for this is to support existing DNS servers on the Internet, since some DNS
            tools and servers only support ASCII characters (see RFC 3490).
            </para>
            <para>
            The IdnToAscii function use Punycode to convert an IDN to the ASCII representation of the original Unicode string using the
            standard algorithm defined in RFC 3490. The IdnToUnicode function converts the ASCII form of an IDN to the normal Unicode UTF-16
            encoding syntax. For more information and links to related draft standards, see Handling Internationalized Domain Names (IDNs).
            </para>
            <para>
            The IdnToAscii function can be used to convert an IDN name to the ASCII form. To pass this ASCII form to the <c>GetAddrInfoW</c>
            function, you can use the MultiByteToWideChar function to convert the <c>CHAR</c> string into a <c>WCHAR</c> string that then
            can be passed in the pNodeName parameter to the <c>GetAddrInfoW</c> function.
            </para>
            <para>Use of ai_flags in the hints parameter</para>
            <para>
            Flags in the <c>ai_flags</c> member of the optional addrinfoW structure provided in the pHints parameter modify the behavior of
            the function.
            </para>
            <para>
            These flag bits are defined in the Ws2def.h header file on the Microsoft Windows Software Development Kit (SDK) for Windows 7.
            These flag bits are defined in the Ws2tcpip.h header file on the Windows SDK for Windows Server 2008 and Windows Vista. These
            flag bits are defined in the Ws2tcpip.h header file on the Platform Software Development Kit (SDK) for Windows Server 2003, and
            Windows XP.
            </para>
            <para>The flag bits can be a combination of the following:</para>
            <list type="table">
            <listheader>
            <term>Flag Bits</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>AI_PASSIVE</term>
            <term>
            Setting the AI_PASSIVE flag indicates the caller intends to use the returned socket address structure in a call to the bind
            function. When the AI_PASSIVE flag is set and pNodeName is a NULL pointer, the IP address portion of the socket address
            structure is set to INADDR_ANY for IPv4 addresses and IN6ADDR_ANY_INIT for IPv6 addresses. When the AI_PASSIVE flag is not set,
            the returned socket address structure is ready for a call to the connect function for a connection-oriented protocol, or ready
            for a call to either the connect, sendto, or send functions for a connectionless protocol. If the pNodeName parameter is a NULL
            pointer in this case, the IP address portion of the socket address structure is set to the loopback address.
            </term>
            </item>
            <item>
            <term>AI_CANONNAME</term>
            <term>
            If neither AI_CANONNAME nor AI_NUMERICHOST is used, the GetAddrInfoW function attempts resolution. If a literal string is passed
            GetAddrInfoW attempts to convert the string, and if a host name is passed the GetAddrInfoW function attempts to resolve the name
            to an address or multiple addresses. When the AI_CANONNAME bit is set, the pNodeName parameter cannot be NULL. Otherwise the
            GetAddrInfoEx function will fail with WSANO_RECOVERY. When the AI_CANONNAME bit is set and the GetAddrInfoW function returns
            success, the ai_canonname member in the ppResult parameter points to a NULL-terminated string that contains the canonical name
            of the specified node.
            </term>
            </item>
            <item>
            <term>AI_NUMERICHOST</term>
            <term>
            When the AI_NUMERICHOST bit is set, the pNodeName parameter must contain a non-NULL numeric host address string, otherwise the
            EAI_NONAME error is returned. This flag prevents a name resolution service from being called.
            </term>
            </item>
            <item>
            <term>AI_NUMERICSERV</term>
            <term>
            When the AI_NUMERICSERV bit is set, the pServiceName parameter must contain a non-NULL numeric port number, otherwise the
            EAI_NONAME error is returned. This flag prevents a name resolution service from being called. The AI_NUMERICSERV flag is defined
            on Windows SDK for Windows Vista and later. The AI_NUMERICSERV flag is not supported by Microsoft providers.
            </term>
            </item>
            <item>
            <term>AI_ALL</term>
            <term>
            If the AI_ALL bit is set, a request is made for IPv6 addresses and IPv4 addresses with AI_V4MAPPED. The AI_ALL flag is defined
            on the Windows SDK for Windows Vista and later. The AI_ALL flag is supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AI_ADDRCONFIG</term>
            <term>
            If the AI_ADDRCONFIG bit is set, GetAddrInfoW will resolve only if a global address is configured. If AI_ADDRCONFIG flag is
            specified, IPv4 addresses shall be returned only if an IPv4 address is configured on the local system, and IPv6 addresses shall
            be returned only if an IPv6 address is configured on the local system. The IPv4 or IPv6 loopback address is not considered a
            valid global address. The AI_ADDRCONFIG flag is defined on the Windows SDK for Windows Vista and later. The AI_ADDRCONFIG flag
            is supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AI_V4MAPPED</term>
            <term>
            If the AI_V4MAPPED bit is set and a request for IPv6 addresses fails, a name service request is made for IPv4 addresses and
            these addresses are converted to IPv4-mapped IPv6 address format. The AI_V4MAPPED flag is defined on the Windows SDK for Windows
            Vista and later. The AI_V4MAPPED flag is supported on Windows Vista and later.
            </term>
            </item>
            <item>
            <term>AI_NON_AUTHORITATIVE</term>
            <term>
            If the AI_NON_AUTHORITATIVE bit is set, the NS_EMAIL namespace provider returns both authoritative and non-authoritative
            results. If the AI_NON_AUTHORITATIVE bit is not set, the NS_EMAIL namespace provider returns only authoritative results. The
            AI_NON_AUTHORITATIVE flag is defined on the Windows SDK for Windows Vista and later. The AI_NON_AUTHORITATIVE flag is supported
            on Windows Vista and later and applies only to the NS_EMAIL namespace.
            </term>
            </item>
            <item>
            <term>AI_SECURE</term>
            <term>
            If the AI_SECURE bit is set, the NS_EMAIL namespace provider will return results that were obtained with enhanced security to
            minimize possible spoofing. The AI_SECURE flag is defined on the Windows SDK for Windows Vista and later. The AI_SECURE flag is
            supported on Windows Vista and later and applies only to the NS_EMAIL namespace.
            </term>
            </item>
            <item>
            <term>AI_RETURN_PREFERRED_NAMES</term>
            <term>
            If the AI_RETURN_PREFERRED_NAMES is set, then no name should be provided in the pNodeName parameter. The NS_EMAIL namespace
            provider will return preferred names for publication. The AI_RETURN_PREFERRED_NAMES flag is defined on the Windows SDK for
            Windows Vista and later. The AI_RETURN_PREFERRED_NAMES flag is supported on Windows Vista and later and applies only to the
            NS_EMAIL namespace.
            </term>
            </item>
            <item>
            <term>AI_FQDN</term>
            <term>
            If the AI_FQDN is set and a flat name (single label) is specified, GetAddrInfoW will return the fully qualified domain name that
            the name eventually resolved to. The fully qualified domain name is returned in the ai_canonname member in the associated
            addrinfoW structure. This is different than AI_CANONNAME bit flag that returns the canonical name registered in DNS which may be
            different than the fully qualified domain name that the flat name resolved to. Only one of the AI_FQDN and AI_CANONNAME bits can
            be set. The GetAddrInfoW function will fail if both flags are present with EAI_BADFLAGS. When the AI_FQDN bit is set, the
            pNodeName parameter cannot be NULL. Otherwise the GetAddrInfoEx function will fail with WSANO_RECOVERY. Windows 7: The AI_FQDN
            flag is defined on the Windows SDK for Windows 7 and later. The AI_FQDN flag is supported on Windows 7 and later.
            </term>
            </item>
            <item>
            <term>AI_FILESERVER</term>
            <term>
            If the AI_FILESERVER is set, this is a hint to the namespace provider that the hostname being queried is being used in file
            share scenario. The namespace provider may ignore this hint. Windows 7: The AI_FILESERVER flag is defined on the Windows SDK for
            Windows 7 and later. The AI_FILESERVER flag is supported on Windows 7 and later.
            </term>
            </item>
            <item>
            <term>AI_DISABLE_IDN_ENCODING</term>
            <term>
            If the AI_DISABLE_IDN_ENCODING is set, this disables the automatic International Domain Name encoding using Punycode in the name
            resolution functions called by the GetAddrInfoW function. Windows 8: The AI_DISABLE_IDN_ENCODING flag is defined on the Windows
            SDK for Windows 8 and later. The AI_DISABLE_IDN_ENCODING flag is supported on Windows 8 and later.
            </term>
            </item>
            </list>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.getipv4sourcefilter(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.IN_ADDR,Vanara.PInvoke.Ws2_32.IN_ADDR,Vanara.PInvoke.Ws2_32.MULTICAST_MODE_TYPE@,System.Int32@,Vanara.PInvoke.Ws2_32.IN_ADDR[])">
            <summary>The <c>getipv4sourcefilter</c> inline function retrieves the multicast filter state for an IPv4 socket.</summary>
            <param name="Socket">A descriptor that identifies a multicast socket.</param>
            <param name="Interface">
            <para>The local IPv4 address of the interface or the interface index on which the multicast group should be joined or dropped.</para>
            <para>
            This value is in network byte order. If this member specifies an IPv4 address of 0.0.0.0, the default IPv4 multicast interface
            is used.
            </para>
            <para>
            Any IP address in the 0.x.x.x block (first octet of 0) except IPv4 address 0.0.0.0 is treated as an interface index. An
            interface index is a 24-bit number, and the 0.0.0.0/8 IPv4 address block is not used (this range is reserved).
            </para>
            <para>To use an interface index of 1 would be the same as an IP address of 0.0.0.1.</para>
            </param>
            <param name="Group">The IPv4 address of the multicast group.</param>
            <param name="FilterMode">
            A pointer to a value to receive the multicast filter mode for multicast group address when the function returns.
            </param>
            <param name="SourceCount">
            <para>
            On input, a pointer to a value that indicates the maximum number of source addresses that will fit in the buffer pointed to by
            the SourceList parameter.
            </para>
            <para>On output, a pointer to a value that indicates the total number of source addresses associated with the multicast filter.</para>
            </param>
            <param name="SourceList">
            <para>A pointer to a buffer to receive the list of IP addresses associated with the multicast filter.</para>
            <para>If SourceCount is zero on input, a <c>NULL</c> pointer may be supplied.</para>
            </param>
            <returns>
            <para>
            On success, <c>getipv4sourcefilter</c> returns NO_ERROR (0). Any nonzero return value indicates failure and a specific error
            code can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAENOBUFS</term>
            <term>Insufficient buffer space is available.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>getipv4sourcefilter</c> inline function is used to retrieve the multicast filter state for an IPv4 socket.</para>
            <para>
            If the app does not know the size of the source list beforehand, it can make a guess (zero, for example). If upon completion,
            the SourceCount parameter holds a larger value, the operation can be repeated with a large enough buffer.
            </para>
            <para>
            On return, the SourceCount parameter is always updated to be the total number of sources in the filter, while the buffer pointed
            to by the SourceList parameter will hold as many source addresses as fit, up to the minimum of the array size passed in as the
            original SourceCount value and the total number of sources in the filter.
            </para>
            <para>
            This function is part of socket interface extensions for multicast source filters defined in RFC 3678. An app can use these
            functions to retrieve and set the multicast source address filters associated with a socket.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.GetNameInfoW(Vanara.PInvoke.Ws2_32.SOCKADDR,System.Int32,System.Text.StringBuilder,System.UInt32,System.Text.StringBuilder,System.UInt32,Vanara.PInvoke.Ws2_32.NI)">
            <summary>
            The <c>GetNameInfoW</c> function provides protocol-independent name resolution from an address to a Unicode host name and from a
            port number to the Unicode service name.
            </summary>
            <param name="pSockaddr">
            A pointer to a socket address structure containing the IP address and port number of the socket. For IPv4, the pSockaddr
            parameter points to a sockaddr_in structure. For IPv6, the pSockaddr parameter points to a <c>sockaddr_in6</c> structure.
            </param>
            <param name="SockaddrLength">The length, in bytes, of the structure pointed to by the pSockaddr parameter.</param>
            <param name="pNodeBuffer">
            A pointer to a Unicode string to hold the host name. On success, a pointer to the Unicode host name is returned as a Fully
            Qualified Domain Name (FQDN) by default. If the pNodeBuffer parameter is <c>NULL</c>, this indicates the caller does not want to
            receive a host name string.
            </param>
            <param name="NodeBufferSize">
            The number of <c>WCHAR</c> characters in the buffer pointed to by the pNodeBuffer parameter. The caller must provide a buffer
            large enough to hold the Unicode host name, including the terminating <c>NULL</c> character.
            </param>
            <param name="pServiceBuffer">
            A pointer to a Unicode string to hold the service name. On success, a pointer is returned to a Unicode string representing the
            service name associated with the port number. If the pServiceBuffer parameter is <c>NULL</c>, this indicates the caller does not
            want to receive a service name string.
            </param>
            <param name="ServiceBufferSize">
            The number of <c>WCHAR</c> characters in the buffer pointed to by the pServiceBuffer parameter. The caller must provide a buffer
            large enough to hold the Unicode service name, including the terminating <c>NULL</c> character.
            </param>
            <param name="Flags">A value used to customize processing of the <c>GetNameInfoW</c> function. See the Remarks section.</param>
            <returns>
            <para>
            On success, <c>GetNameInfoW</c> returns zero. Any nonzero return value indicates failure and a specific error code can be
            retrieved by calling WSAGetLastError.
            </para>
            <para>
            Nonzero error codes returned by the <c>GetNameInfoW</c> function also map to the set of errors outlined by Internet Engineering
            Task Force (IETF) recommendations. The following table shows these error codes and their WSA equivalents. It is recommended that
            the WSA error codes be used, as they offer familiar and comprehensive error information for Winsock programmers.
            </para>
            <list type="table">
            <listheader>
            <term>Error value</term>
            <term>WSA equivalent</term>
            <term>Description</term>
            </listheader>
            <item>
            <term>EAI_AGAIN</term>
            <term>WSATRY_AGAIN</term>
            <term>A temporary failure in name resolution occurred.</term>
            </item>
            <item>
            <term>EAI_BADFLAGS</term>
            <term>WSAEINVAL</term>
            <term>
            One or more invalid parameters was passed to the GetNameInfoW function. This error is returned if a host name was requested but
            the NodeBufferSize parameter was zero or if a service name was requested but the ServiceBufferSize parameter was zero.
            </term>
            </item>
            <item>
            <term>EAI_FAIL</term>
            <term>WSANO_RECOVERY</term>
            <term>A nonrecoverable failure in name resolution occurred.</term>
            </item>
            <item>
            <term>EAI_FAMILY</term>
            <term>WSAEAFNOSUPPORT</term>
            <term>The sa_family member of socket address structure pointed to by the pSockaddr parameter is not supported.</term>
            </item>
            <item>
            <term>EAI_MEMORY</term>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>A memory allocation failure occurred.</term>
            </item>
            <item>
            <term>EAI_NONAME</term>
            <term>WSAHOST_NOT_FOUND</term>
            <term>
            A service name was requested, but no port number was found in the structure pointed to by the pSockaddr parameter or no service
            name matching the port number was found. NI_NAMEREQD is set and the host's name cannot be located, or both the pNodeBuffer and
            pServiceBuffer parameters were NULL.
            </term>
            </item>
            </list>
            <para>
            You can use the gai_strerror function to print error messages based on the EAI codes returned by the <c>GetNameInfoW</c>
            function. The <c>gai_strerror</c> function is provided for compliance with IETF recommendations, but it is not thread safe.
            Therefore, use of traditional Windows Sockets functions such as WSAGetLastError is recommended.
            </para>
            <para>In addition, the following error codes can be returned.</para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEFAULT</term>
            <term>
            This error is returned if the pSockaddr parameter is NULL or the SockaddrLength parameter is less than the length needed for the
            size of sockaddr_in structure for IPv4 or the sockaddr_in6 structure for IPv6.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>GetNameInfoW</c> function is the Unicode version of a function that provides protocol-independent name resolution. The
            <c>GetNameInfoW</c> function is used to translate the contents of a socket address structure to a node name and/or a service name.
            </para>
            <para>
            For the IPv6 and IPv4 protocols, name resolution can be by the Domain Name System (DNS), a local hosts file, or by other naming
            mechanisms. This function can be used to determine the host name for an IPv4 or IPv6 address, a reverse DNS lookup, or determine
            the service name for a port number. The <c>GetNameInfoW</c> function can also be used to convert an IP address or a port number
            in a <c>SOCKADDR</c> structure to an Unicode string. This function can also be used to determine the IP address for a host name.
            </para>
            <para>The ANSI version of this function is getnameinfo.</para>
            <para>
            Macros in the Winsock header file define a mixed-case function name of <c>GetNameInfo</c> that can be used when the application
            is targeted for Windows XP with Service Pack 2 (SP2) and later (_WIN32_WINNT &gt;= 0x0502). This <c>GetNameInfo</c> function
            should be called with the pNodeBuffer and pServiceBuffer parameters of a pointer of type <c>TCHAR</c>. When UNICODE or _UNICODE
            is defined, <c>GetNameInfo</c> is defined to the Unicode version and <c>GetNameInfoW</c> is called with the host and serv
            parameters of a pointer of type <c>char</c>. When UNICODE or _UNICODE is not defined, <c>GetNameInfo</c> is defined to the ANSI
            version and getnameinfo is called with the pNodeBuffer and pServiceBuffer parameters of a pointer of type <c>PWCHAR</c>.
            </para>
            <para>
            To simplify determining buffer requirements for the pNodeBuffer and pServiceBuffer parameters, the following values for maximum
            host name length and maximum service name are defined in the Ws2tcpip.h header file:
            </para>
            <para>The Flags parameter can be used to customize processing of the <c>GetNameInfoW</c> function. The following flags are available:</para>
            <list type="bullet">
            <item>
            <term>NI_NOFQDN</term>
            </item>
            <item>
            <term>NI_NUMERICHOST</term>
            </item>
            <item>
            <term>NI_NAMEREQD</term>
            </item>
            <item>
            <term>NI_NUMERICSERV</term>
            </item>
            <item>
            <term>NI_DGRAM</term>
            </item>
            </list>
            <para>When the <c>NI_NAMEREQD</c> flag is set, a host name that cannot be resolved by the DNS results in an error.</para>
            <para>
            Setting the <c>NI_NOFQDN</c> flag results in local hosts having only their Relative Distinguished Name (RDN) returned in the
            pNodeBuffer parameter.
            </para>
            <para>
            Setting the <c>NI_NUMERICHOST</c> flag returns the numeric form of the host name instead of its name. The numeric form of the
            host name is also returned if the host name cannot be resolved by DNS.
            </para>
            <para>
            Setting the <c>NI_NUMERICSERV</c> flag returns the port number of the service instead of its name. Also, if a host name is not
            found for an IP address (127.0.0.2, for example), the hostname is returned as the IP address.
            </para>
            <para>
            On Windows Vista and later, if <c>NI_NUMERICSERV</c> is not specified in the flags parameter, and the port number contained in
            <c>sockaddr</c> structure pointed to by the sa parameter does not resolve to a well known service, the <c>GetNameInfoW</c>
            function returns the numeric form of the service address (the port number) as a numeric string. When <c>NI_NUMERICSERV</c> is
            specified, the port number is returned as a numeric string. This behavior is specified in section 6.2 of RFC 3493. For more
            information, see www.ietf.org/rfc/rfc3493.txt
            </para>
            <para>
            On Windows Server 2003 and earlier, if <c>NI_NUMERICSERV</c> is not specified in the flags parameter and the port number
            contained in sockaddr structure pointed to by the sa parameter does not resolve to a well known service, the <c>GetNameInfoW</c>
            function fails. When <c>NI_NUMERICSERV</c> is specified, the port number is returned as a numeric string.
            </para>
            <para>
            Setting the <c>NI_DGRAM</c> flag indicates that the service is a datagram service. This flag is necessary for the few services
            that provide different port numbers for UDP and TCP service.
            </para>
            <para>
            <c>Note</c> The capability to perform reverse DNS lookups using the <c>GetNameInfoW</c> function is convenient, but such lookups
            are considered inherently unreliable, and should be used only as a hint.
            </para>
            <para><c>Note</c><c>GetNameInfoW</c> cannot be used to resolve alias names.</para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            <para>Example Code</para>
            <para>The following example demonstrates the use of the <c>GetNameInfoW</c> function.</para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.getsourcefilter(Vanara.PInvoke.Ws2_32.SOCKET,System.UInt32,Vanara.PInvoke.Ws2_32.SOCKADDR,System.Int32,Vanara.PInvoke.Ws2_32.MULTICAST_MODE_TYPE@,System.Int32@,Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE[])">
            <summary>The <c>getsourcefilter</c> inline function retrieves the multicast filter state for an IPv4 or IPv6 socket.</summary>
            <param name="Socket">A descriptor that identifies a multicast socket.</param>
            <param name="Interface">The interface index of the multicast interface.</param>
            <param name="Group">A pointer to the socket address of the multicast group.</param>
            <param name="GroupLength">The length, in bytes, of the socket address pointed to by the Group parameter.</param>
            <param name="FilterMode">
            A pointer to a value to receive the multicast filter mode for the multicast group address when the function returns.
            </param>
            <param name="SourceCount">
            <para>
            On input, a pointer to a value that indicates the maximum number of source addresses that will fit in the buffer pointed to by
            the SourceList parameter.
            </para>
            <para>On output, a pointer to a value that indicates the total number of source addresses associated with the multicast filter.</para>
            </param>
            <param name="SourceList">
            <para>A pointer to a buffer to receive the list of IP addresses associated with the multicast filter.</para>
            <para>If SourceCount is zero on input, a <c>NULL</c> pointer may be supplied.</para>
            </param>
            <returns>
            <para>
            On success, <c>getsourcefilter</c> returns NO_ERROR (0). Any nonzero return value indicates failure and a specific error code
            can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAENOBUFS</term>
            <term>Insufficient buffer space is available.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>getsourcefilter</c> inline function is used to retrieve the multicast filter state for an IPv4 or IPv6 socket.</para>
            <para>
            If the app does not know the size of the source list beforehand, it can make a guess (zero, for example). If upon completion,
            the SourceCount parameter holds a larger value, the operation can be repeated with a large enough buffer.
            </para>
            <para>
            On return, the SourceCount parameter is always updated to be the total number of sources in the filter, while the buffer pointed
            to by the SourceList parameter will hold as many source addresses as fit, up to the minimum of the array size passed in as the
            original SourceCount value and the total number of sources in the filter.
            </para>
            <para>
            This function is part of socket interface extensions for multicast source filters defined in RFC 3678. An app can use these
            functions to retrieve and set the multicast source address filters associated with a socket.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.inet_ntop(Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY,Vanara.PInvoke.Ws2_32.IN_ADDR@,System.Text.StringBuilder,Vanara.PInvoke.SizeT)">
            <summary>
            The <c>InetNtop</c> function converts an IPv4 or IPv6 Internet network address into a string in Internet standard format. The
            ANSI version of this function is <c>inet_ntop</c>.
            </summary>
            <param name="Family">
            <para>The address family.</para>
            <para>
            Possible values for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is
            automatically included in Winsock2.h, and should never be used directly. Note that the values for the AF_ address family and PF_
            protocol family constants are identical (for example, <c>AF_INET</c> and <c>PF_INET</c>), so either constant can be used.
            </para>
            <para>The values currently supported are <c>AF_INET</c> and <c>AF_INET6</c>.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AF_INET 2</term>
            <term>
            The Internet Protocol version 4 (IPv4) address family. When this parameter is specified, this function returns an IPv4 address string.
            </term>
            </item>
            <item>
            <term>AF_INET6 23</term>
            <term>
            The Internet Protocol version 6 (IPv6) address family. When this parameter is specified, this function returns an IPv6 address string.
            </term>
            </item>
            </list>
            </param>
            <param name="pAddr">
            <para>A pointer to the IP address in network byte to convert to a string.</para>
            <para>
            When the Family parameter is <c>AF_INET</c>, then the pAddr parameter must point to an IN_ADDR structure with the IPv4 address
            to convert.
            </para>
            <para>
            When the Family parameter is <c>AF_INET6</c>, then the pAddr parameter must point to an IN6_ADDR structure with the IPv6 address
            to convert.
            </para>
            </param>
            <param name="pStringBuf">
            <para>A pointer to a buffer in which to store the <c>NULL</c>-terminated string representation of the IP address.</para>
            <para>For an IPv4 address, this buffer should be large enough to hold at least 16 characters.</para>
            <para>For an IPv6 address, this buffer should be large enough to hold at least 46 characters.</para>
            </param>
            <param name="StringBufSize">On input, the length, in characters, of the buffer pointed to by the pStringBuf parameter.</param>
            <returns>
            <para>
            If no error occurs, <c>InetNtop</c> function returns a pointer to a buffer containing the string representation of IP address in
            standard format.
            </para>
            <para>
            Otherwise, a value of <c>NULL</c> is returned, and a specific error code can be retrieved by calling the WSAGetLastError for
            extended error information.
            </para>
            <para>If the function fails, the extended error code returned by WSAGetLastError can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEAFNOSUPPORT</term>
            <term>
            The address family specified in the Family parameter is not supported. This error is returned if the Family parameter specified
            was not AF_INET or AF_INET6.
            </term>
            </item>
            <item>
            <term>ERROR_INVALID_PARAMETER</term>
            <term>
            An invalid parameter was passed to the function. This error is returned if a NULL pointer is passed in the pStringBuf or the
            StringBufSize parameter is zero. This error is also returned if the length of the buffer pointed to by the pStringBuf parameter
            is not large enough to receive the string representation of the IP address.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>InetNtop</c> function is supported on Windows Vistaand later.</para>
            <para>
            The <c>InetNtop</c> function provides a protocol-independent address-to-string translation. The <c>InetNtop</c> function takes
            an Internet address structure specified by the pAddr parameter and returns a <c>NULL</c>-terminated string that represents the
            IP address. While the inet_ntoa function works only with IPv4 addresses, the <c>InetNtop</c> function works with either IPv4 or
            IPv6 addresses.
            </para>
            <para>
            The ANSI version of this function is <c>inet_ntop</c> as defined in RFC 2553. For more information, see RFC 2553 available at
            the IETF website.
            </para>
            <para>The <c>InetNtop</c> function does not require that the Windows Sockets DLL be loaded to perform IP address to string conversion.</para>
            <para>
            If the Family parameter specified is <c>AF_INET</c>, then the pAddr parameter must point to an IN_ADDR structure with the IPv4
            address to convert. The address string returned in the buffer pointed to by the pStringBuf parameter is in dotted-decimal
            notation as in "192.168.16.0", an example of an IPv4 address in dotted-decimal notation.
            </para>
            <para>
            If the Family parameter specified is <c>AF_INET6</c>, then the pAddr parameter must point to an IN6_ADDR structure with the IPv6
            address to convert. The address string returned in the buffer pointed to by the pStringBuf parameter is in Internet standard
            format. The basic string representation consists of 8 hexadecimal numbers separated by colons. A string of consecutive zero
            numbers is replaced with a double-colon. There can only be one double-colon in the string representation of the IPv6 address.
            The last 32 bits are represented in IPv4-style dotted-octet notation if the address is a IPv4-compatible address.
            </para>
            <para>
            If the length of the buffer pointed to by the pStringBuf parameter is not large enough to receive the string representation of
            the IP address, <c>InetNtop</c> returns ERROR_INVALID_PARAMETER.
            </para>
            <para>
            When UNICODE or _UNICODE is defined, <c>InetNtop</c> is defined to <c>InetNtopW</c>, the Unicode version of this function. The
            pStringBuf parameter is defined to the <c>PSTR</c> data type.
            </para>
            <para>
            When UNICODE or _UNICODE is not defined, <c>InetNtop</c> is defined to <c>InetNtopA</c>, the ANSI version of this function. The
            ANSI version of this function is always defined as <c>inet_ntop</c>. The pStringBuf parameter is defined to the <c>PWSTR</c>
            data type.
            </para>
            <para>The IN_ADDR structure is defined in the Inaddr.h header file.</para>
            <para>The IN6_ADDR structure is defined in the In6addr.h header file.</para>
            <para>
            On Windows Vista and later, the RtlIpv4AddressToString and RtlIpv4AddressToStringEx functions can be used to convert an IPv4
            address represented as an IN_ADDR structure to a string representation of an IPv4 address in Internet standard dotted-decimal
            notation. On Windows Vista and later, the RtlIpv6AddressToString and RtlIpv6AddressToStringEx functions can be used to convert
            an IPv6 address represented as an IN6_ADDR structure to a string representation of an IPv6 address. The
            <c>RtlIpv6AddressToStringEx</c> function is more flexible since it also converts an IPv6 address, scope ID, and port to a IPv6
            string in standard format.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>InetNtopW</c> function is supported for Windows Store apps on
            Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.inet_ntop(Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY,Vanara.PInvoke.Ws2_32.IN6_ADDR@,System.Text.StringBuilder,Vanara.PInvoke.SizeT)">
            <summary>
            The <c>InetNtop</c> function converts an IPv4 or IPv6 Internet network address into a string in Internet standard format. The
            ANSI version of this function is <c>inet_ntop</c>.
            </summary>
            <param name="Family">
            <para>The address family.</para>
            <para>
            Possible values for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is
            automatically included in Winsock2.h, and should never be used directly. Note that the values for the AF_ address family and PF_
            protocol family constants are identical (for example, <c>AF_INET</c> and <c>PF_INET</c>), so either constant can be used.
            </para>
            <para>The values currently supported are <c>AF_INET</c> and <c>AF_INET6</c>.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AF_INET 2</term>
            <term>
            The Internet Protocol version 4 (IPv4) address family. When this parameter is specified, this function returns an IPv4 address string.
            </term>
            </item>
            <item>
            <term>AF_INET6 23</term>
            <term>
            The Internet Protocol version 6 (IPv6) address family. When this parameter is specified, this function returns an IPv6 address string.
            </term>
            </item>
            </list>
            </param>
            <param name="pAddr">
            <para>A pointer to the IP address in network byte to convert to a string.</para>
            <para>
            When the Family parameter is <c>AF_INET</c>, then the pAddr parameter must point to an IN_ADDR structure with the IPv4 address
            to convert.
            </para>
            <para>
            When the Family parameter is <c>AF_INET6</c>, then the pAddr parameter must point to an IN6_ADDR structure with the IPv6 address
            to convert.
            </para>
            </param>
            <param name="pStringBuf">
            <para>A pointer to a buffer in which to store the <c>NULL</c>-terminated string representation of the IP address.</para>
            <para>For an IPv4 address, this buffer should be large enough to hold at least 16 characters.</para>
            <para>For an IPv6 address, this buffer should be large enough to hold at least 46 characters.</para>
            </param>
            <param name="StringBufSize">On input, the length, in characters, of the buffer pointed to by the pStringBuf parameter.</param>
            <returns>
            <para>
            If no error occurs, <c>InetNtop</c> function returns a pointer to a buffer containing the string representation of IP address in
            standard format.
            </para>
            <para>
            Otherwise, a value of <c>NULL</c> is returned, and a specific error code can be retrieved by calling the WSAGetLastError for
            extended error information.
            </para>
            <para>If the function fails, the extended error code returned by WSAGetLastError can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEAFNOSUPPORT</term>
            <term>
            The address family specified in the Family parameter is not supported. This error is returned if the Family parameter specified
            was not AF_INET or AF_INET6.
            </term>
            </item>
            <item>
            <term>ERROR_INVALID_PARAMETER</term>
            <term>
            An invalid parameter was passed to the function. This error is returned if a NULL pointer is passed in the pStringBuf or the
            StringBufSize parameter is zero. This error is also returned if the length of the buffer pointed to by the pStringBuf parameter
            is not large enough to receive the string representation of the IP address.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>InetNtop</c> function is supported on Windows Vistaand later.</para>
            <para>
            The <c>InetNtop</c> function provides a protocol-independent address-to-string translation. The <c>InetNtop</c> function takes
            an Internet address structure specified by the pAddr parameter and returns a <c>NULL</c>-terminated string that represents the
            IP address. While the inet_ntoa function works only with IPv4 addresses, the <c>InetNtop</c> function works with either IPv4 or
            IPv6 addresses.
            </para>
            <para>
            The ANSI version of this function is <c>inet_ntop</c> as defined in RFC 2553. For more information, see RFC 2553 available at
            the IETF website.
            </para>
            <para>The <c>InetNtop</c> function does not require that the Windows Sockets DLL be loaded to perform IP address to string conversion.</para>
            <para>
            If the Family parameter specified is <c>AF_INET</c>, then the pAddr parameter must point to an IN_ADDR structure with the IPv4
            address to convert. The address string returned in the buffer pointed to by the pStringBuf parameter is in dotted-decimal
            notation as in "192.168.16.0", an example of an IPv4 address in dotted-decimal notation.
            </para>
            <para>
            If the Family parameter specified is <c>AF_INET6</c>, then the pAddr parameter must point to an IN6_ADDR structure with the IPv6
            address to convert. The address string returned in the buffer pointed to by the pStringBuf parameter is in Internet standard
            format. The basic string representation consists of 8 hexadecimal numbers separated by colons. A string of consecutive zero
            numbers is replaced with a double-colon. There can only be one double-colon in the string representation of the IPv6 address.
            The last 32 bits are represented in IPv4-style dotted-octet notation if the address is a IPv4-compatible address.
            </para>
            <para>
            If the length of the buffer pointed to by the pStringBuf parameter is not large enough to receive the string representation of
            the IP address, <c>InetNtop</c> returns ERROR_INVALID_PARAMETER.
            </para>
            <para>
            When UNICODE or _UNICODE is defined, <c>InetNtop</c> is defined to <c>InetNtopW</c>, the Unicode version of this function. The
            pStringBuf parameter is defined to the <c>PSTR</c> data type.
            </para>
            <para>
            When UNICODE or _UNICODE is not defined, <c>InetNtop</c> is defined to <c>InetNtopA</c>, the ANSI version of this function. The
            ANSI version of this function is always defined as <c>inet_ntop</c>. The pStringBuf parameter is defined to the <c>PWSTR</c>
            data type.
            </para>
            <para>The IN_ADDR structure is defined in the Inaddr.h header file.</para>
            <para>The IN6_ADDR structure is defined in the In6addr.h header file.</para>
            <para>
            On Windows Vista and later, the RtlIpv4AddressToString and RtlIpv4AddressToStringEx functions can be used to convert an IPv4
            address represented as an IN_ADDR structure to a string representation of an IPv4 address in Internet standard dotted-decimal
            notation. On Windows Vista and later, the RtlIpv6AddressToString and RtlIpv6AddressToStringEx functions can be used to convert
            an IPv6 address represented as an IN6_ADDR structure to a string representation of an IPv6 address. The
            <c>RtlIpv6AddressToStringEx</c> function is more flexible since it also converts an IPv6 address, scope ID, and port to a IPv6
            string in standard format.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>InetNtopW</c> function is supported for Windows Store apps on
            Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.inet_pton(Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY,System.String,Vanara.PInvoke.Ws2_32.IN_ADDR@)">
            <summary>
            The <c>InetPton</c> function converts an IPv4 or IPv6 Internet network address in its standard text presentation form into its
            numeric binary form. The ANSI version of this function is <c>inet_pton</c>.
            </summary>
            <param name="Family">
            <para>The address family.</para>
            <para>
            Possible values for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is
            automatically included in Winsock2.h, and should never be used directly. Note that the values for the AF_ address family and PF_
            protocol family constants are identical (for example, <c>AF_INET</c> and <c>PF_INET</c>), so either constant can be used.
            </para>
            <para>The values currently supported are <c>AF_INET</c> and <c>AF_INET6</c>.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AF_INET 2</term>
            <term>
            The Internet Protocol version 4 (IPv4) address family. When this parameter is specified, the pszAddrString parameter must point
            to a text representation of an IPv4 address and the pAddrBuf parameter returns a pointer to an IN_ADDR structure that represents
            the IPv4 address.
            </term>
            </item>
            <item>
            <term>AF_INET6 23</term>
            <term>
            The Internet Protocol version 6 (IPv6) address family. When this parameter is specified, the pszAddrString parameter must point
            to a text representation of an IPv6 address and the pAddrBuf parameter returns a pointer to an IN6_ADDR structure that
            represents the IPv6 address.
            </term>
            </item>
            </list>
            </param>
            <param name="pszAddrString">
            <para>
            A pointer to the <c>NULL</c>-terminated string that contains the text representation of the IP address to convert to numeric
            binary form.
            </para>
            <para>
            When the Family parameter is <c>AF_INET</c>, then the pszAddrString parameter must point to a text representation of an IPv4
            address in standard dotted-decimal notation.
            </para>
            <para>
            When the Family parameter is <c>AF_INET6</c>, then the pszAddrString parameter must point to a text representation of an IPv6
            address in standard notation.
            </para>
            </param>
            <param name="pAddrBuf">
            <para>
            A pointer to a buffer in which to store the numeric binary representation of the IP address. The IP address is returned in
            network byte order.
            </para>
            <para>When the Family parameter is <c>AF_INET</c>, this buffer should be large enough to hold an IN_ADDR structure.</para>
            <para>When the Family parameter is <c>AF_INET6</c>, this buffer should be large enough to hold an IN6_ADDR structure.</para>
            </param>
            <returns>
            <para>
            If no error occurs, the <c>InetPton</c> function returns a value of 1 and the buffer pointed to by the pAddrBuf parameter
            contains the binary numeric IP address in network byte order.
            </para>
            <para>
            The <c>InetPton</c> function returns a value of 0 if the pAddrBuf parameter points to a string that is not a valid IPv4
            dotted-decimal string or a valid IPv6 address string. Otherwise, a value of -1 is returned, and a specific error code can be
            retrieved by calling the WSAGetLastError for extended error information.
            </para>
            <para>If the function has an error, the extended error code returned by WSAGetLastError can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEAFNOSUPPORT</term>
            <term>
            The address family specified in the Family parameter is not supported. This error is returned if the Family parameter specified
            was not AF_INET or AF_INET6.
            </term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The pszAddrString or pAddrBuf parameters are NULL or are not part of the user address space.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>InetPton</c> function is supported on Windows Vistaand later.</para>
            <para>
            The <c>InetPton</c> function provides a protocol-independent conversion of an Internet network address in its standard text
            presentation form into its numeric binary form. The <c>InetPton</c> function takes a text representation of an Internet address
            pointed to by the pszAddrString parameter and returns a pointer to the numeric binary IP address in the pAddrBuf parameter.
            While the inet_addrfunction works only with IPv4 address strings, the <c>InetPton</c> function works with either IPv4 or IPv6
            address strings.
            </para>
            <para>
            The ANSI version of this function is <c>inet_pton</c> as defined in RFC 2553. For more information, see RFC 2553 available at
            the IETF website.
            </para>
            <para>
            The <c>InetPton</c> function does not require that the Windows Sockets DLL be loaded to perform conversion of a text string that
            represents an IP address to a numeric binary IP address.
            </para>
            <para>
            If the Family parameter specified is <c>AF_INET</c>, then the pszAddrString parameter must point a text string of an IPv4
            address in dotted-decimal notation as in "192.168.16.0", an example of an IPv4 address in dotted-decimal notation.
            </para>
            <para>
            If the Family parameter specified is <c>AF_INET6</c>, then the pszAddrString parameter must point a text string of an IPv6
            address in Internet standard format. The basic string representation consists of 8 hexadecimal numbers separated by colons. A
            string of consecutive zero numbers may be replaced with a double-colon. There can only be one double-colon in the string
            representation of the IPv6 address. The last 32 bits may be represented in IPv4-style dotted-octet notation if the address is a
            IPv4-compatible address.
            </para>
            <para>
            When UNICODE or _UNICODE is defined, <c>InetPton</c> is defined to <c>InetPtonW</c>, the Unicode version of this function. The
            pszAddrString parameter is defined to the <c>PCWSTR</c> data type.
            </para>
            <para>
            When UNICODE or _UNICODE is not defined, <c>InetPton</c> is defined to <c>InetPtonA</c>, the ANSI version of this function. The
            ANSI version of this function is always defined as inet_pton. The pszAddrString parameter is defined to the <c>PCSTR</c> data type.
            </para>
            <para>The IN_ADDR structure is defined in the Inaddr.h header file.</para>
            <para>The IN6_ADDR structure is defined in the In6addr.h header file.</para>
            <para>
            On Windows Vista and later, the RtlIpv4StringToAddress and RtlIpv4StringToAddressEx functions can be used to convert a text
            representation of an IPv4 address in Internet standard dotted-decimal notation to a numeric binary address represented as an
            IN_ADDR structure. On Windows Vista and later, the RtlIpv6StringToAddress and RtlIpv6StringToAddressEx functions can be used to
            convert a string representation of an IPv6 address to a numeric binary IPv6 address represented as an IN6_ADDR structure. The
            <c>RtlIpv6StringToAddressEx</c> function is more flexible since it also converts a string representation of an IPv6 address that
            can include a scope ID and port in standard notation to a numeric binary form.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>InetPtonW</c> function is supported for Windows Store apps on
            Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.inet_pton(Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY,System.String,Vanara.PInvoke.Ws2_32.IN6_ADDR@)">
            <summary>
            The <c>InetPton</c> function converts an IPv4 or IPv6 Internet network address in its standard text presentation form into its
            numeric binary form. The ANSI version of this function is <c>inet_pton</c>.
            </summary>
            <param name="Family">
            <para>The address family.</para>
            <para>
            Possible values for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is
            automatically included in Winsock2.h, and should never be used directly. Note that the values for the AF_ address family and PF_
            protocol family constants are identical (for example, <c>AF_INET</c> and <c>PF_INET</c>), so either constant can be used.
            </para>
            <para>The values currently supported are <c>AF_INET</c> and <c>AF_INET6</c>.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AF_INET 2</term>
            <term>
            The Internet Protocol version 4 (IPv4) address family. When this parameter is specified, the pszAddrString parameter must point
            to a text representation of an IPv4 address and the pAddrBuf parameter returns a pointer to an IN_ADDR structure that represents
            the IPv4 address.
            </term>
            </item>
            <item>
            <term>AF_INET6 23</term>
            <term>
            The Internet Protocol version 6 (IPv6) address family. When this parameter is specified, the pszAddrString parameter must point
            to a text representation of an IPv6 address and the pAddrBuf parameter returns a pointer to an IN6_ADDR structure that
            represents the IPv6 address.
            </term>
            </item>
            </list>
            </param>
            <param name="pszAddrString">
            <para>
            A pointer to the <c>NULL</c>-terminated string that contains the text representation of the IP address to convert to numeric
            binary form.
            </para>
            <para>
            When the Family parameter is <c>AF_INET</c>, then the pszAddrString parameter must point to a text representation of an IPv4
            address in standard dotted-decimal notation.
            </para>
            <para>
            When the Family parameter is <c>AF_INET6</c>, then the pszAddrString parameter must point to a text representation of an IPv6
            address in standard notation.
            </para>
            </param>
            <param name="pAddrBuf">
            <para>
            A pointer to a buffer in which to store the numeric binary representation of the IP address. The IP address is returned in
            network byte order.
            </para>
            <para>When the Family parameter is <c>AF_INET</c>, this buffer should be large enough to hold an IN_ADDR structure.</para>
            <para>When the Family parameter is <c>AF_INET6</c>, this buffer should be large enough to hold an IN6_ADDR structure.</para>
            </param>
            <returns>
            <para>
            If no error occurs, the <c>InetPton</c> function returns a value of 1 and the buffer pointed to by the pAddrBuf parameter
            contains the binary numeric IP address in network byte order.
            </para>
            <para>
            The <c>InetPton</c> function returns a value of 0 if the pAddrBuf parameter points to a string that is not a valid IPv4
            dotted-decimal string or a valid IPv6 address string. Otherwise, a value of -1 is returned, and a specific error code can be
            retrieved by calling the WSAGetLastError for extended error information.
            </para>
            <para>If the function has an error, the extended error code returned by WSAGetLastError can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEAFNOSUPPORT</term>
            <term>
            The address family specified in the Family parameter is not supported. This error is returned if the Family parameter specified
            was not AF_INET or AF_INET6.
            </term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The pszAddrString or pAddrBuf parameters are NULL or are not part of the user address space.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>InetPton</c> function is supported on Windows Vistaand later.</para>
            <para>
            The <c>InetPton</c> function provides a protocol-independent conversion of an Internet network address in its standard text
            presentation form into its numeric binary form. The <c>InetPton</c> function takes a text representation of an Internet address
            pointed to by the pszAddrString parameter and returns a pointer to the numeric binary IP address in the pAddrBuf parameter.
            While the inet_addrfunction works only with IPv4 address strings, the <c>InetPton</c> function works with either IPv4 or IPv6
            address strings.
            </para>
            <para>
            The ANSI version of this function is <c>inet_pton</c> as defined in RFC 2553. For more information, see RFC 2553 available at
            the IETF website.
            </para>
            <para>
            The <c>InetPton</c> function does not require that the Windows Sockets DLL be loaded to perform conversion of a text string that
            represents an IP address to a numeric binary IP address.
            </para>
            <para>
            If the Family parameter specified is <c>AF_INET</c>, then the pszAddrString parameter must point a text string of an IPv4
            address in dotted-decimal notation as in "192.168.16.0", an example of an IPv4 address in dotted-decimal notation.
            </para>
            <para>
            If the Family parameter specified is <c>AF_INET6</c>, then the pszAddrString parameter must point a text string of an IPv6
            address in Internet standard format. The basic string representation consists of 8 hexadecimal numbers separated by colons. A
            string of consecutive zero numbers may be replaced with a double-colon. There can only be one double-colon in the string
            representation of the IPv6 address. The last 32 bits may be represented in IPv4-style dotted-octet notation if the address is a
            IPv4-compatible address.
            </para>
            <para>
            When UNICODE or _UNICODE is defined, <c>InetPton</c> is defined to <c>InetPtonW</c>, the Unicode version of this function. The
            pszAddrString parameter is defined to the <c>PCWSTR</c> data type.
            </para>
            <para>
            When UNICODE or _UNICODE is not defined, <c>InetPton</c> is defined to <c>InetPtonA</c>, the ANSI version of this function. The
            ANSI version of this function is always defined as inet_pton. The pszAddrString parameter is defined to the <c>PCSTR</c> data type.
            </para>
            <para>The IN_ADDR structure is defined in the Inaddr.h header file.</para>
            <para>The IN6_ADDR structure is defined in the In6addr.h header file.</para>
            <para>
            On Windows Vista and later, the RtlIpv4StringToAddress and RtlIpv4StringToAddressEx functions can be used to convert a text
            representation of an IPv4 address in Internet standard dotted-decimal notation to a numeric binary address represented as an
            IN_ADDR structure. On Windows Vista and later, the RtlIpv6StringToAddress and RtlIpv6StringToAddressEx functions can be used to
            convert a string representation of an IPv6 address to a numeric binary IPv6 address represented as an IN6_ADDR structure. The
            <c>RtlIpv6StringToAddressEx</c> function is more flexible since it also converts a string representation of an IPv6 address that
            can include a scope ID and port in standard notation to a numeric binary form.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>InetPtonW</c> function is supported for Windows Store apps on
            Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.InetNtopW(Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY,Vanara.PInvoke.Ws2_32.IN_ADDR@,System.Text.StringBuilder,Vanara.PInvoke.SizeT)">
            <summary>
            The <c>InetNtop</c> function converts an IPv4 or IPv6 Internet network address into a string in Internet standard format. The
            ANSI version of this function is <c>inet_ntop</c>.
            </summary>
            <param name="Family">
            <para>The address family.</para>
            <para>
            Possible values for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is
            automatically included in Winsock2.h, and should never be used directly. Note that the values for the AF_ address family and PF_
            protocol family constants are identical (for example, <c>AF_INET</c> and <c>PF_INET</c>), so either constant can be used.
            </para>
            <para>The values currently supported are <c>AF_INET</c> and <c>AF_INET6</c>.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AF_INET 2</term>
            <term>
            The Internet Protocol version 4 (IPv4) address family. When this parameter is specified, this function returns an IPv4 address string.
            </term>
            </item>
            <item>
            <term>AF_INET6 23</term>
            <term>
            The Internet Protocol version 6 (IPv6) address family. When this parameter is specified, this function returns an IPv6 address string.
            </term>
            </item>
            </list>
            </param>
            <param name="pAddr">
            <para>A pointer to the IP address in network byte to convert to a string.</para>
            <para>
            When the Family parameter is <c>AF_INET</c>, then the pAddr parameter must point to an IN_ADDR structure with the IPv4 address
            to convert.
            </para>
            <para>
            When the Family parameter is <c>AF_INET6</c>, then the pAddr parameter must point to an IN6_ADDR structure with the IPv6 address
            to convert.
            </para>
            </param>
            <param name="pStringBuf">
            <para>A pointer to a buffer in which to store the <c>NULL</c>-terminated string representation of the IP address.</para>
            <para>For an IPv4 address, this buffer should be large enough to hold at least 16 characters.</para>
            <para>For an IPv6 address, this buffer should be large enough to hold at least 46 characters.</para>
            </param>
            <param name="StringBufSize">On input, the length, in characters, of the buffer pointed to by the pStringBuf parameter.</param>
            <returns>
            <para>
            If no error occurs, <c>InetNtop</c> function returns a pointer to a buffer containing the string representation of IP address in
            standard format.
            </para>
            <para>
            Otherwise, a value of <c>NULL</c> is returned, and a specific error code can be retrieved by calling the WSAGetLastError for
            extended error information.
            </para>
            <para>If the function fails, the extended error code returned by WSAGetLastError can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEAFNOSUPPORT</term>
            <term>
            The address family specified in the Family parameter is not supported. This error is returned if the Family parameter specified
            was not AF_INET or AF_INET6.
            </term>
            </item>
            <item>
            <term>ERROR_INVALID_PARAMETER</term>
            <term>
            An invalid parameter was passed to the function. This error is returned if a NULL pointer is passed in the pStringBuf or the
            StringBufSize parameter is zero. This error is also returned if the length of the buffer pointed to by the pStringBuf parameter
            is not large enough to receive the string representation of the IP address.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>InetNtop</c> function is supported on Windows Vista and later.</para>
            <para>
            The <c>InetNtop</c> function provides a protocol-independent address-to-string translation. The <c>InetNtop</c> function takes
            an Internet address structure specified by the pAddr parameter and returns a <c>NULL</c>-terminated string that represents the
            IP address. While the inet_ntoa function works only with IPv4 addresses, the <c>InetNtop</c> function works with either IPv4 or
            IPv6 addresses.
            </para>
            <para>
            The ANSI version of this function is <c>inet_ntop</c> as defined in RFC 2553. For more information, see RFC 2553 available at
            the IETF website.
            </para>
            <para>The <c>InetNtop</c> function does not require that the Windows Sockets DLL be loaded to perform IP address to string conversion.</para>
            <para>
            If the Family parameter specified is <c>AF_INET</c>, then the pAddr parameter must point to an IN_ADDR structure with the IPv4
            address to convert. The address string returned in the buffer pointed to by the pStringBuf parameter is in dotted-decimal
            notation as in "192.168.16.0", an example of an IPv4 address in dotted-decimal notation.
            </para>
            <para>
            If the Family parameter specified is <c>AF_INET6</c>, then the pAddr parameter must point to an IN6_ADDR structure with the IPv6
            address to convert. The address string returned in the buffer pointed to by the pStringBuf parameter is in Internet standard
            format. The basic string representation consists of 8 hexadecimal numbers separated by colons. A string of consecutive zero
            numbers is replaced with a double-colon. There can only be one double-colon in the string representation of the IPv6 address.
            The last 32 bits are represented in IPv4-style dotted-octet notation if the address is a IPv4-compatible address.
            </para>
            <para>
            If the length of the buffer pointed to by the pStringBuf parameter is not large enough to receive the string representation of
            the IP address, <c>InetNtop</c> returns ERROR_INVALID_PARAMETER.
            </para>
            <para>
            When UNICODE or _UNICODE is defined, <c>InetNtop</c> is defined to <c>InetNtopW</c>, the Unicode version of this function. The
            pStringBuf parameter is defined to the <c>PSTR</c> data type.
            </para>
            <para>
            When UNICODE or _UNICODE is not defined, <c>InetNtop</c> is defined to <c>InetNtopA</c>, the ANSI version of this function. The
            ANSI version of this function is always defined as <c>inet_ntop</c>. The pStringBuf parameter is defined to the <c>PWSTR</c>
            data type.
            </para>
            <para>The IN_ADDR structure is defined in the Inaddr.h header file.</para>
            <para>The IN6_ADDR structure is defined in the In6addr.h header file.</para>
            <para>
            On Windows Vista and later, the RtlIpv4AddressToString and RtlIpv4AddressToStringEx functions can be used to convert an IPv4
            address represented as an IN_ADDR structure to a string representation of an IPv4 address in Internet standard dotted-decimal
            notation. On Windows Vista and later, the RtlIpv6AddressToString and RtlIpv6AddressToStringEx functions can be used to convert
            an IPv6 address represented as an IN6_ADDR structure to a string representation of an IPv6 address. The
            <c>RtlIpv6AddressToStringEx</c> function is more flexible since it also converts an IPv6 address, scope ID, and port to a IPv6
            string in standard format.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>InetNtopW</c> function is supported for Windows Store apps on
            Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.InetNtopW(Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY,Vanara.PInvoke.Ws2_32.IN6_ADDR@,System.Text.StringBuilder,Vanara.PInvoke.SizeT)">
            <summary>
            The <c>InetNtop</c> function converts an IPv4 or IPv6 Internet network address into a string in Internet standard format. The
            ANSI version of this function is <c>inet_ntop</c>.
            </summary>
            <param name="Family">
            <para>The address family.</para>
            <para>
            Possible values for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is
            automatically included in Winsock2.h, and should never be used directly. Note that the values for the AF_ address family and PF_
            protocol family constants are identical (for example, <c>AF_INET</c> and <c>PF_INET</c>), so either constant can be used.
            </para>
            <para>The values currently supported are <c>AF_INET</c> and <c>AF_INET6</c>.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AF_INET 2</term>
            <term>
            The Internet Protocol version 4 (IPv4) address family. When this parameter is specified, this function returns an IPv4 address string.
            </term>
            </item>
            <item>
            <term>AF_INET6 23</term>
            <term>
            The Internet Protocol version 6 (IPv6) address family. When this parameter is specified, this function returns an IPv6 address string.
            </term>
            </item>
            </list>
            </param>
            <param name="pAddr">
            <para>A pointer to the IP address in network byte to convert to a string.</para>
            <para>
            When the Family parameter is <c>AF_INET</c>, then the pAddr parameter must point to an IN_ADDR structure with the IPv4 address
            to convert.
            </para>
            <para>
            When the Family parameter is <c>AF_INET6</c>, then the pAddr parameter must point to an IN6_ADDR structure with the IPv6 address
            to convert.
            </para>
            </param>
            <param name="pStringBuf">
            <para>A pointer to a buffer in which to store the <c>NULL</c>-terminated string representation of the IP address.</para>
            <para>For an IPv4 address, this buffer should be large enough to hold at least 16 characters.</para>
            <para>For an IPv6 address, this buffer should be large enough to hold at least 46 characters.</para>
            </param>
            <param name="StringBufSize">On input, the length, in characters, of the buffer pointed to by the pStringBuf parameter.</param>
            <returns>
            <para>
            If no error occurs, <c>InetNtop</c> function returns a pointer to a buffer containing the string representation of IP address in
            standard format.
            </para>
            <para>
            Otherwise, a value of <c>NULL</c> is returned, and a specific error code can be retrieved by calling the WSAGetLastError for
            extended error information.
            </para>
            <para>If the function fails, the extended error code returned by WSAGetLastError can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEAFNOSUPPORT</term>
            <term>
            The address family specified in the Family parameter is not supported. This error is returned if the Family parameter specified
            was not AF_INET or AF_INET6.
            </term>
            </item>
            <item>
            <term>ERROR_INVALID_PARAMETER</term>
            <term>
            An invalid parameter was passed to the function. This error is returned if a NULL pointer is passed in the pStringBuf or the
            StringBufSize parameter is zero. This error is also returned if the length of the buffer pointed to by the pStringBuf parameter
            is not large enough to receive the string representation of the IP address.
            </term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>InetNtop</c> function is supported on Windows Vista and later.</para>
            <para>
            The <c>InetNtop</c> function provides a protocol-independent address-to-string translation. The <c>InetNtop</c> function takes
            an Internet address structure specified by the pAddr parameter and returns a <c>NULL</c>-terminated string that represents the
            IP address. While the inet_ntoa function works only with IPv4 addresses, the <c>InetNtop</c> function works with either IPv4 or
            IPv6 addresses.
            </para>
            <para>
            The ANSI version of this function is <c>inet_ntop</c> as defined in RFC 2553. For more information, see RFC 2553 available at
            the IETF website.
            </para>
            <para>The <c>InetNtop</c> function does not require that the Windows Sockets DLL be loaded to perform IP address to string conversion.</para>
            <para>
            If the Family parameter specified is <c>AF_INET</c>, then the pAddr parameter must point to an IN_ADDR structure with the IPv4
            address to convert. The address string returned in the buffer pointed to by the pStringBuf parameter is in dotted-decimal
            notation as in "192.168.16.0", an example of an IPv4 address in dotted-decimal notation.
            </para>
            <para>
            If the Family parameter specified is <c>AF_INET6</c>, then the pAddr parameter must point to an IN6_ADDR structure with the IPv6
            address to convert. The address string returned in the buffer pointed to by the pStringBuf parameter is in Internet standard
            format. The basic string representation consists of 8 hexadecimal numbers separated by colons. A string of consecutive zero
            numbers is replaced with a double-colon. There can only be one double-colon in the string representation of the IPv6 address.
            The last 32 bits are represented in IPv4-style dotted-octet notation if the address is a IPv4-compatible address.
            </para>
            <para>
            If the length of the buffer pointed to by the pStringBuf parameter is not large enough to receive the string representation of
            the IP address, <c>InetNtop</c> returns ERROR_INVALID_PARAMETER.
            </para>
            <para>
            When UNICODE or _UNICODE is defined, <c>InetNtop</c> is defined to <c>InetNtopW</c>, the Unicode version of this function. The
            pStringBuf parameter is defined to the <c>PSTR</c> data type.
            </para>
            <para>
            When UNICODE or _UNICODE is not defined, <c>InetNtop</c> is defined to <c>InetNtopA</c>, the ANSI version of this function. The
            ANSI version of this function is always defined as <c>inet_ntop</c>. The pStringBuf parameter is defined to the <c>PWSTR</c>
            data type.
            </para>
            <para>The IN_ADDR structure is defined in the Inaddr.h header file.</para>
            <para>The IN6_ADDR structure is defined in the In6addr.h header file.</para>
            <para>
            On Windows Vista and later, the RtlIpv4AddressToString and RtlIpv4AddressToStringEx functions can be used to convert an IPv4
            address represented as an IN_ADDR structure to a string representation of an IPv4 address in Internet standard dotted-decimal
            notation. On Windows Vista and later, the RtlIpv6AddressToString and RtlIpv6AddressToStringEx functions can be used to convert
            an IPv6 address represented as an IN6_ADDR structure to a string representation of an IPv6 address. The
            <c>RtlIpv6AddressToStringEx</c> function is more flexible since it also converts an IPv6 address, scope ID, and port to a IPv6
            string in standard format.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>InetNtopW</c> function is supported for Windows Store apps on
            Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.InetPtonW(Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY,System.String,Vanara.PInvoke.Ws2_32.IN_ADDR@)">
            <summary>
            The <c>InetPton</c> function converts an IPv4 or IPv6 Internet network address in its standard text presentation form into its
            numeric binary form. The ANSI version of this function is <c>inet_pton</c>.
            </summary>
            <param name="Family">
            <para>The address family.</para>
            <para>
            Possible values for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is
            automatically included in Winsock2.h, and should never be used directly. Note that the values for the AF_ address family and PF_
            protocol family constants are identical (for example, <c>AF_INET</c> and <c>PF_INET</c>), so either constant can be used.
            </para>
            <para>The values currently supported are <c>AF_INET</c> and <c>AF_INET6</c>.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AF_INET 2</term>
            <term>
            The Internet Protocol version 4 (IPv4) address family. When this parameter is specified, the pszAddrString parameter must point
            to a text representation of an IPv4 address and the pAddrBuf parameter returns a pointer to an IN_ADDR structure that represents
            the IPv4 address.
            </term>
            </item>
            <item>
            <term>AF_INET6 23</term>
            <term>
            The Internet Protocol version 6 (IPv6) address family. When this parameter is specified, the pszAddrString parameter must point
            to a text representation of an IPv6 address and the pAddrBuf parameter returns a pointer to an IN6_ADDR structure that
            represents the IPv6 address.
            </term>
            </item>
            </list>
            </param>
            <param name="pszAddrString">
            <para>
            A pointer to the <c>NULL</c>-terminated string that contains the text representation of the IP address to convert to numeric
            binary form.
            </para>
            <para>
            When the Family parameter is <c>AF_INET</c>, then the pszAddrString parameter must point to a text representation of an IPv4
            address in standard dotted-decimal notation.
            </para>
            <para>
            When the Family parameter is <c>AF_INET6</c>, then the pszAddrString parameter must point to a text representation of an IPv6
            address in standard notation.
            </para>
            </param>
            <param name="pAddrBuf">
            <para>
            A pointer to a buffer in which to store the numeric binary representation of the IP address. The IP address is returned in
            network byte order.
            </para>
            <para>When the Family parameter is <c>AF_INET</c>, this buffer should be large enough to hold an IN_ADDR structure.</para>
            <para>When the Family parameter is <c>AF_INET6</c>, this buffer should be large enough to hold an IN6_ADDR structure.</para>
            </param>
            <returns>
            <para>
            If no error occurs, the <c>InetPton</c> function returns a value of 1 and the buffer pointed to by the pAddrBuf parameter
            contains the binary numeric IP address in network byte order.
            </para>
            <para>
            The <c>InetPton</c> function returns a value of 0 if the pAddrBuf parameter points to a string that is not a valid IPv4
            dotted-decimal string or a valid IPv6 address string. Otherwise, a value of -1 is returned, and a specific error code can be
            retrieved by calling the WSAGetLastError for extended error information.
            </para>
            <para>If the function has an error, the extended error code returned by WSAGetLastError can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEAFNOSUPPORT</term>
            <term>
            The address family specified in the Family parameter is not supported. This error is returned if the Family parameter specified
            was not AF_INET or AF_INET6.
            </term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The pszAddrString or pAddrBuf parameters are NULL or are not part of the user address space.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>InetPton</c> function is supported on Windows Vistaand later.</para>
            <para>
            The <c>InetPton</c> function provides a protocol-independent conversion of an Internet network address in its standard text
            presentation form into its numeric binary form. The <c>InetPton</c> function takes a text representation of an Internet address
            pointed to by the pszAddrString parameter and returns a pointer to the numeric binary IP address in the pAddrBuf parameter.
            While the inet_addrfunction works only with IPv4 address strings, the <c>InetPton</c> function works with either IPv4 or IPv6
            address strings.
            </para>
            <para>
            The ANSI version of this function is <c>inet_pton</c> as defined in RFC 2553. For more information, see RFC 2553 available at
            the IETF website.
            </para>
            <para>
            The <c>InetPton</c> function does not require that the Windows Sockets DLL be loaded to perform conversion of a text string that
            represents an IP address to a numeric binary IP address.
            </para>
            <para>
            If the Family parameter specified is <c>AF_INET</c>, then the pszAddrString parameter must point a text string of an IPv4
            address in dotted-decimal notation as in "192.168.16.0", an example of an IPv4 address in dotted-decimal notation.
            </para>
            <para>
            If the Family parameter specified is <c>AF_INET6</c>, then the pszAddrString parameter must point a text string of an IPv6
            address in Internet standard format. The basic string representation consists of 8 hexadecimal numbers separated by colons. A
            string of consecutive zero numbers may be replaced with a double-colon. There can only be one double-colon in the string
            representation of the IPv6 address. The last 32 bits may be represented in IPv4-style dotted-octet notation if the address is a
            IPv4-compatible address.
            </para>
            <para>
            When UNICODE or _UNICODE is defined, <c>InetPton</c> is defined to <c>InetPtonW</c>, the Unicode version of this function. The
            pszAddrString parameter is defined to the <c>PCWSTR</c> data type.
            </para>
            <para>
            When UNICODE or _UNICODE is not defined, <c>InetPton</c> is defined to <c>InetPtonA</c>, the ANSI version of this function. The
            ANSI version of this function is always defined as inet_pton. The pszAddrString parameter is defined to the <c>PCSTR</c> data type.
            </para>
            <para>The IN_ADDR structure is defined in the Inaddr.h header file.</para>
            <para>The IN6_ADDR structure is defined in the In6addr.h header file.</para>
            <para>
            On Windows Vista and later, the RtlIpv4StringToAddress and RtlIpv4StringToAddressEx functions can be used to convert a text
            representation of an IPv4 address in Internet standard dotted-decimal notation to a numeric binary address represented as an
            IN_ADDR structure. On Windows Vista and later, the RtlIpv6StringToAddress and RtlIpv6StringToAddressEx functions can be used to
            convert a string representation of an IPv6 address to a numeric binary IPv6 address represented as an IN6_ADDR structure. The
            <c>RtlIpv6StringToAddressEx</c> function is more flexible since it also converts a string representation of an IPv6 address that
            can include a scope ID and port in standard notation to a numeric binary form.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>InetPtonW</c> function is supported for Windows Store apps on
            Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.InetPtonW(Vanara.PInvoke.Ws2_32.ADDRESS_FAMILY,System.String,Vanara.PInvoke.Ws2_32.IN6_ADDR@)">
            <summary>
            The <c>InetPton</c> function converts an IPv4 or IPv6 Internet network address in its standard text presentation form into its
            numeric binary form. The ANSI version of this function is <c>inet_pton</c>.
            </summary>
            <param name="Family">
            <para>The address family.</para>
            <para>
            Possible values for the address family are defined in the Ws2def.h header file. Note that the Ws2def.h header file is
            automatically included in Winsock2.h, and should never be used directly. Note that the values for the AF_ address family and PF_
            protocol family constants are identical (for example, <c>AF_INET</c> and <c>PF_INET</c>), so either constant can be used.
            </para>
            <para>The values currently supported are <c>AF_INET</c> and <c>AF_INET6</c>.</para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>AF_INET 2</term>
            <term>
            The Internet Protocol version 4 (IPv4) address family. When this parameter is specified, the pszAddrString parameter must point
            to a text representation of an IPv4 address and the pAddrBuf parameter returns a pointer to an IN_ADDR structure that represents
            the IPv4 address.
            </term>
            </item>
            <item>
            <term>AF_INET6 23</term>
            <term>
            The Internet Protocol version 6 (IPv6) address family. When this parameter is specified, the pszAddrString parameter must point
            to a text representation of an IPv6 address and the pAddrBuf parameter returns a pointer to an IN6_ADDR structure that
            represents the IPv6 address.
            </term>
            </item>
            </list>
            </param>
            <param name="pszAddrString">
            <para>
            A pointer to the <c>NULL</c>-terminated string that contains the text representation of the IP address to convert to numeric
            binary form.
            </para>
            <para>
            When the Family parameter is <c>AF_INET</c>, then the pszAddrString parameter must point to a text representation of an IPv4
            address in standard dotted-decimal notation.
            </para>
            <para>
            When the Family parameter is <c>AF_INET6</c>, then the pszAddrString parameter must point to a text representation of an IPv6
            address in standard notation.
            </para>
            </param>
            <param name="pAddrBuf">
            <para>
            A pointer to a buffer in which to store the numeric binary representation of the IP address. The IP address is returned in
            network byte order.
            </para>
            <para>When the Family parameter is <c>AF_INET</c>, this buffer should be large enough to hold an IN_ADDR structure.</para>
            <para>When the Family parameter is <c>AF_INET6</c>, this buffer should be large enough to hold an IN6_ADDR structure.</para>
            </param>
            <returns>
            <para>
            If no error occurs, the <c>InetPton</c> function returns a value of 1 and the buffer pointed to by the pAddrBuf parameter
            contains the binary numeric IP address in network byte order.
            </para>
            <para>
            The <c>InetPton</c> function returns a value of 0 if the pAddrBuf parameter points to a string that is not a valid IPv4
            dotted-decimal string or a valid IPv6 address string. Otherwise, a value of -1 is returned, and a specific error code can be
            retrieved by calling the WSAGetLastError for extended error information.
            </para>
            <para>If the function has an error, the extended error code returned by WSAGetLastError can be one of the following values.</para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAEAFNOSUPPORT</term>
            <term>
            The address family specified in the Family parameter is not supported. This error is returned if the Family parameter specified
            was not AF_INET or AF_INET6.
            </term>
            </item>
            <item>
            <term>WSAEFAULT</term>
            <term>The pszAddrString or pAddrBuf parameters are NULL or are not part of the user address space.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>InetPton</c> function is supported on Windows Vistaand later.</para>
            <para>
            The <c>InetPton</c> function provides a protocol-independent conversion of an Internet network address in its standard text
            presentation form into its numeric binary form. The <c>InetPton</c> function takes a text representation of an Internet address
            pointed to by the pszAddrString parameter and returns a pointer to the numeric binary IP address in the pAddrBuf parameter.
            While the inet_addrfunction works only with IPv4 address strings, the <c>InetPton</c> function works with either IPv4 or IPv6
            address strings.
            </para>
            <para>
            The ANSI version of this function is <c>inet_pton</c> as defined in RFC 2553. For more information, see RFC 2553 available at
            the IETF website.
            </para>
            <para>
            The <c>InetPton</c> function does not require that the Windows Sockets DLL be loaded to perform conversion of a text string that
            represents an IP address to a numeric binary IP address.
            </para>
            <para>
            If the Family parameter specified is <c>AF_INET</c>, then the pszAddrString parameter must point a text string of an IPv4
            address in dotted-decimal notation as in "192.168.16.0", an example of an IPv4 address in dotted-decimal notation.
            </para>
            <para>
            If the Family parameter specified is <c>AF_INET6</c>, then the pszAddrString parameter must point a text string of an IPv6
            address in Internet standard format. The basic string representation consists of 8 hexadecimal numbers separated by colons. A
            string of consecutive zero numbers may be replaced with a double-colon. There can only be one double-colon in the string
            representation of the IPv6 address. The last 32 bits may be represented in IPv4-style dotted-octet notation if the address is a
            IPv4-compatible address.
            </para>
            <para>
            When UNICODE or _UNICODE is defined, <c>InetPton</c> is defined to <c>InetPtonW</c>, the Unicode version of this function. The
            pszAddrString parameter is defined to the <c>PCWSTR</c> data type.
            </para>
            <para>
            When UNICODE or _UNICODE is not defined, <c>InetPton</c> is defined to <c>InetPtonA</c>, the ANSI version of this function. The
            ANSI version of this function is always defined as inet_pton. The pszAddrString parameter is defined to the <c>PCSTR</c> data type.
            </para>
            <para>The IN_ADDR structure is defined in the Inaddr.h header file.</para>
            <para>The IN6_ADDR structure is defined in the In6addr.h header file.</para>
            <para>
            On Windows Vista and later, the RtlIpv4StringToAddress and RtlIpv4StringToAddressEx functions can be used to convert a text
            representation of an IPv4 address in Internet standard dotted-decimal notation to a numeric binary address represented as an
            IN_ADDR structure. On Windows Vista and later, the RtlIpv6StringToAddress and RtlIpv6StringToAddressEx functions can be used to
            convert a string representation of an IPv6 address to a numeric binary IPv6 address represented as an IN6_ADDR structure. The
            <c>RtlIpv6StringToAddressEx</c> function is more flexible since it also converts a string representation of an IPv6 address that
            can include a scope ID and port in standard notation to a numeric binary form.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>InetPtonW</c> function is supported for Windows Store apps on
            Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SetAddrInfoEx(System.String,System.String,Vanara.PInvoke.Ws2_32.SOCKET_ADDRESS[],System.UInt32,System.IntPtr,System.UInt32,Vanara.PInvoke.Ws2_32.NS,System.Guid@,Vanara.PInvoke.Ws2_32.TIMEVAL@,System.IntPtr,Vanara.PInvoke.Ws2_32.LPLOOKUPSERVICE_COMPLETION_ROUTINE,Vanara.PInvoke.HANDLE@)">
            <summary>
            The <c>SetAddrInfoEx</c> function registers or deregisters a name, a service name, and associated addresses with a specific
            namespace provider.
            </summary>
            <param name="pName">
            A pointer to a <c>NULL</c>-terminated string containing a name under which addresses are to be registered or deregistered. The
            interpretation of this parameter specific to the namespace provider.
            </param>
            <param name="pServiceName">
            A pointer to an optional <c>NULL</c>-terminated string that contains the service name associated with the name being registered.
            The interpretation of this parameter is specific to the namespace provider.
            </param>
            <param name="pAddresses">A pointer to an optional list of addresses to register with the namespace provider.</param>
            <param name="dwAddressCount">
            The number of addresses passed in pAddresses parameter. If this parameter is zero, the pName parameter is deregistered from the
            namespace provider.
            </param>
            <param name="lpBlob">
            An optional pointer to data that is used to set provider-specific namespace information that is associated with the pName
            parameter beyond a list of addresses. Any information that cannot be passed in the pAddresses parameter can be passed in the
            lpBlob parameter. The format of this information is specific to the namespace provider.
            </param>
            <param name="dwFlags">
            A set of flags controlling how the pName and pServiceName parameters are to be registered with the namespace provider. The
            interpretation of this information is specific to the namespace provider.
            </param>
            <param name="dwNameSpace">
            <para>
            A namespace identifier that determines which namespace provider to register this information with. Passing a specific namespace
            identifier will result in registering this information only with the namespace providers that support the specified namespace.
            Specifying NS_ALL will result in registering the information with all installed and active namespace providers.
            </para>
            <para>
            Options for the dwNameSpace parameter are listed in the Winsock2.h include file. Several namespace providers are included with
            Windows Vista and later. Other namespace providers can be installed, so the following possible values are only those commonly
            available. Many others are possible.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>NS_ALL</term>
            <term>All installed and active namespaces.</term>
            </item>
            <item>
            <term>NS_BTH</term>
            <term>The Bluetooth namespace. This namespace identifier is supported on Windows Vista and later.</term>
            </item>
            <item>
            <term>NS_DNS</term>
            <term>The domain name system (DNS) namespace.</term>
            </item>
            <item>
            <term>NS_EMAIL</term>
            <term>The email namespace. This namespace identifier is supported on Windows Vista and later.</term>
            </item>
            <item>
            <term>NS_NLA</term>
            <term>The network location awareness (NLA) namespace. This namespace identifier is supported on Windows XP and later.</term>
            </item>
            <item>
            <term>NS_PNRPNAME</term>
            <term>The peer-to-peer namespace for a specific peer name. This namespace identifier is supported on Windows Vista and later.</term>
            </item>
            <item>
            <term>NS_PNRPCLOUD</term>
            <term>
            The peer-to-peer namespace for a collection of peer names. This namespace identifier is supported on Windows Vista and later.
            </term>
            </item>
            </list>
            </param>
            <param name="lpNspId">
            A pointer to an optional GUID of a specific namespace provider to register this information with in the case where multiple
            namespace providers are registered under a single namespace such as NS_DNS. Passing the GUID for a specific namespace provider
            will result in the information being registered with only the specified namespace provider. The WSAEnumNameSpaceProviders
            function can be called to retrieve the GUID for a namespace provider.
            </param>
            <param name="timeout">
            An optional parameter indicating the time, in milliseconds, to wait for a response from the namespace provider before aborting
            the call. This parameter is currently reserved and must be set to <c>NULL</c> since a timeout option is not supported.
            </param>
            <param name="lpOverlapped">
            An optional pointer to an overlapped structure used for asynchronous operation. This parameter is currently reserved and must be
            set to <c>NULL</c> since asynchronous operations are not supported.
            </param>
            <param name="lpCompletionRoutine">
            An optional pointer to a function to be invoked upon successful completion for asynchronous operations. This parameter is
            currently reserved and must be set to <c>NULL</c> since asynchronous operations are not supported.
            </param>
            <param name="lpNameHandle">
            An optional pointer used only for asynchronous operations. This parameter is currently reserved and must be set to <c>NULL</c>
            since asynchronous operations are not supported.
            </param>
            <returns>
            <para>
            On success, <c>SetAddrInfoEx</c> returns NO_ERROR (0). Failure returns a nonzero Windows Sockets error code, as found in the
            Windows Sockets Error Codes.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSATRY_AGAIN</term>
            <term>A temporary failure in name resolution occurred.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>An invalid parameter was provided. This error is returned if any of the reserved parameters are not NULL.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>Insufficient buffer space is available.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>A nonrecoverable failure in name resolution occurred.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>A memory allocation failure occurred.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>SetAddrInfoEx</c> function provides a protocol-independent method to register or deregister a name and one or more
            addresses with a namespace provider. The NS_EMAIL namespace provider in Windows Vista and later supports registration and
            deregistration of addresses. The default NS_DNS, NS_PNRPNAME, and NS_PNRPNAME namespace providers do not currently support name registration.
            </para>
            <para>
            If the <c>SetAddrInfoEx</c> function is called with NS_ALL set as the dwNameSpace parameter and the lpNspId parameter
            unspecified, then <c>SetAddrInfoEx</c> will attempt to register or deregister the name and associated addresses with all
            installed and active namespaces. The <c>SetAddrInfoEx</c> function will return success if any of the namespace providers
            successfully registered or deregistered the name, but there will not be any indication of which namespace provider succeeded or
            which ones failed the request.
            </para>
            <para>
            When <c>UNICODE</c> or <c>_UNICODE</c> is defined, <c>SetAddrInfoEx</c> is defined to SetAddrInfoExW, the Unicode version of
            this function. The string parameters are defined to the <c>PWSTR</c> data type.
            </para>
            <para>
            When <c>UNICODE</c> or <c>_UNICODE</c> is not defined, <c>SetAddrInfoEx</c> is defined to SetAddrInfoExA, the ANSI version of
            this function. The string parameters are of the <c>PCSTR</c> data type.
            </para>
            <para>
            Information that is registered with a namespace provider can be returned by calling the GetAddrInfoEx, getaddrinfo, or
            GetAddrInfoWfunctions. The <c>GetAddrInfoEx</c> function is an enhanced version of the <c>getaddrinfo</c> and
            <c>GetAddrInfoW</c> functions.
            </para>
            <para>
            On Windows Vista and later, when <c>SetAddrInfoEx</c> is called from a service, if the operation is the result of a user process
            calling the service, then the service should impersonate the user. This is to allow security and routing compartments to be
            properly enforced.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>SetAddrInfoExW</c> function is supported for Windows Store apps on
            Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SetAddrInfoEx(System.String,System.String,Vanara.PInvoke.Ws2_32.SOCKET_ADDRESS[],System.UInt32,System.IntPtr,System.UInt32,Vanara.PInvoke.Ws2_32.NS,System.Guid*,Vanara.PInvoke.Ws2_32.TIMEVAL*,System.Threading.NativeOverlapped*,Vanara.PInvoke.Ws2_32.LPLOOKUPSERVICE_COMPLETION_ROUTINE,Vanara.PInvoke.HANDLE*)">
            <summary>
            The <c>SetAddrInfoEx</c> function registers or deregisters a name, a service name, and associated addresses with a specific
            namespace provider.
            </summary>
            <param name="pName">
            A pointer to a <c>NULL</c>-terminated string containing a name under which addresses are to be registered or deregistered. The
            interpretation of this parameter specific to the namespace provider.
            </param>
            <param name="pServiceName">
            A pointer to an optional <c>NULL</c>-terminated string that contains the service name associated with the name being registered.
            The interpretation of this parameter is specific to the namespace provider.
            </param>
            <param name="pAddresses">A pointer to an optional list of addresses to register with the namespace provider.</param>
            <param name="dwAddressCount">
            The number of addresses passed in pAddresses parameter. If this parameter is zero, the pName parameter is deregistered from the
            namespace provider.
            </param>
            <param name="lpBlob">
            An optional pointer to data that is used to set provider-specific namespace information that is associated with the pName
            parameter beyond a list of addresses. Any information that cannot be passed in the pAddresses parameter can be passed in the
            lpBlob parameter. The format of this information is specific to the namespace provider.
            </param>
            <param name="dwFlags">
            A set of flags controlling how the pName and pServiceName parameters are to be registered with the namespace provider. The
            interpretation of this information is specific to the namespace provider.
            </param>
            <param name="dwNameSpace">
            <para>
            A namespace identifier that determines which namespace provider to register this information with. Passing a specific namespace
            identifier will result in registering this information only with the namespace providers that support the specified namespace.
            Specifying NS_ALL will result in registering the information with all installed and active namespace providers.
            </para>
            <para>
            Options for the dwNameSpace parameter are listed in the Winsock2.h include file. Several namespace providers are included with
            Windows Vista and later. Other namespace providers can be installed, so the following possible values are only those commonly
            available. Many others are possible.
            </para>
            <list type="table">
            <listheader>
            <term>Value</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>NS_ALL</term>
            <term>All installed and active namespaces.</term>
            </item>
            <item>
            <term>NS_BTH</term>
            <term>The Bluetooth namespace. This namespace identifier is supported on Windows Vista and later.</term>
            </item>
            <item>
            <term>NS_DNS</term>
            <term>The domain name system (DNS) namespace.</term>
            </item>
            <item>
            <term>NS_EMAIL</term>
            <term>The email namespace. This namespace identifier is supported on Windows Vista and later.</term>
            </item>
            <item>
            <term>NS_NLA</term>
            <term>The network location awareness (NLA) namespace. This namespace identifier is supported on Windows XP and later.</term>
            </item>
            <item>
            <term>NS_PNRPNAME</term>
            <term>The peer-to-peer namespace for a specific peer name. This namespace identifier is supported on Windows Vista and later.</term>
            </item>
            <item>
            <term>NS_PNRPCLOUD</term>
            <term>
            The peer-to-peer namespace for a collection of peer names. This namespace identifier is supported on Windows Vista and later.
            </term>
            </item>
            </list>
            </param>
            <param name="lpNspId">
            A pointer to an optional GUID of a specific namespace provider to register this information with in the case where multiple
            namespace providers are registered under a single namespace such as NS_DNS. Passing the GUID for a specific namespace provider
            will result in the information being registered with only the specified namespace provider. The WSAEnumNameSpaceProviders
            function can be called to retrieve the GUID for a namespace provider.
            </param>
            <param name="timeout">
            An optional parameter indicating the time, in milliseconds, to wait for a response from the namespace provider before aborting
            the call. This parameter is currently reserved and must be set to <c>NULL</c> since a timeout option is not supported.
            </param>
            <param name="lpOverlapped">
            An optional pointer to an overlapped structure used for asynchronous operation. This parameter is currently reserved and must be
            set to <c>NULL</c> since asynchronous operations are not supported.
            </param>
            <param name="lpCompletionRoutine">
            An optional pointer to a function to be invoked upon successful completion for asynchronous operations. This parameter is
            currently reserved and must be set to <c>NULL</c> since asynchronous operations are not supported.
            </param>
            <param name="lpNameHandle">
            An optional pointer used only for asynchronous operations. This parameter is currently reserved and must be set to <c>NULL</c>
            since asynchronous operations are not supported.
            </param>
            <returns>
            <para>
            On success, <c>SetAddrInfoEx</c> returns NO_ERROR (0). Failure returns a nonzero Windows Sockets error code, as found in the
            Windows Sockets Error Codes.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSANOTINITIALISED</term>
            <term>A successful WSAStartup call must occur before using this function.</term>
            </item>
            <item>
            <term>WSATRY_AGAIN</term>
            <term>A temporary failure in name resolution occurred.</term>
            </item>
            <item>
            <term>WSAEINVAL</term>
            <term>An invalid parameter was provided. This error is returned if any of the reserved parameters are not NULL.</term>
            </item>
            <item>
            <term>WSAENOBUFS</term>
            <term>Insufficient buffer space is available.</term>
            </item>
            <item>
            <term>WSANO_RECOVERY</term>
            <term>A nonrecoverable failure in name resolution occurred.</term>
            </item>
            <item>
            <term>WSA_NOT_ENOUGH_MEMORY</term>
            <term>A memory allocation failure occurred.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>
            The <c>SetAddrInfoEx</c> function provides a protocol-independent method to register or deregister a name and one or more
            addresses with a namespace provider. The NS_EMAIL namespace provider in Windows Vista and later supports registration and
            deregistration of addresses. The default NS_DNS, NS_PNRPNAME, and NS_PNRPNAME namespace providers do not currently support name registration.
            </para>
            <para>
            If the <c>SetAddrInfoEx</c> function is called with NS_ALL set as the dwNameSpace parameter and the lpNspId parameter
            unspecified, then <c>SetAddrInfoEx</c> will attempt to register or deregister the name and associated addresses with all
            installed and active namespaces. The <c>SetAddrInfoEx</c> function will return success if any of the namespace providers
            successfully registered or deregistered the name, but there will not be any indication of which namespace provider succeeded or
            which ones failed the request.
            </para>
            <para>
            When <c>UNICODE</c> or <c>_UNICODE</c> is defined, <c>SetAddrInfoEx</c> is defined to SetAddrInfoExW, the Unicode version of
            this function. The string parameters are defined to the <c>PWSTR</c> data type.
            </para>
            <para>
            When <c>UNICODE</c> or <c>_UNICODE</c> is not defined, <c>SetAddrInfoEx</c> is defined to SetAddrInfoExA, the ANSI version of
            this function. The string parameters are of the <c>PCSTR</c> data type.
            </para>
            <para>
            Information that is registered with a namespace provider can be returned by calling the GetAddrInfoEx, getaddrinfo, or
            GetAddrInfoWfunctions. The <c>GetAddrInfoEx</c> function is an enhanced version of the <c>getaddrinfo</c> and
            <c>GetAddrInfoW</c> functions.
            </para>
            <para>
            On Windows Vista and later, when <c>SetAddrInfoEx</c> is called from a service, if the operation is the result of a user process
            calling the service, then the service should impersonate the user. This is to allow security and routing compartments to be
            properly enforced.
            </para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: The <c>SetAddrInfoExW</c> function is supported for Windows Store apps on
            Windows 8.1, Windows Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.setipv4sourcefilter(Vanara.PInvoke.Ws2_32.SOCKET,Vanara.PInvoke.Ws2_32.IN_ADDR,Vanara.PInvoke.Ws2_32.IN_ADDR,Vanara.PInvoke.Ws2_32.MULTICAST_MODE_TYPE,System.UInt32,Vanara.PInvoke.Ws2_32.IN_ADDR[])">
            <summary>The <c>setipv4sourcefilter</c> inline function sets the multicast filter state for an IPv4 socket.</summary>
            <param name="Socket">A descriptor that identifies a multicast socket.</param>
            <param name="Interface">
            <para>The local IPv4 address of the interface or the interface index on which the multicast group should be joined or dropped.</para>
            <para>
            This value is in network byte order. If this member specifies an IPv4 address of 0.0.0.0, the default IPv4 multicast interface
            is used.
            </para>
            <para>
            Any IP address in the 0.x.x.x block (first octet of 0) except IPv4 address 0.0.0.0 is treated as an interface index. An
            interface index is a 24-bit number, and the 0.0.0.0/8 IPv4 address block is not used (this range is reserved).
            </para>
            <para>To use an interface index of 1 would be the same as an IP address of 0.0.0.1.</para>
            </param>
            <param name="Group">The IPv4 address of the multicast group.</param>
            <param name="FilterMode">The multicast filter mode for multicast group address.</param>
            <param name="SourceCount">The number of source addresses in the buffer pointed to by the SourceList parameter.</param>
            <param name="SourceList">A pointer to a buffer with the IP addresses to associate with the multicast filter.</param>
            <returns>
            <para>
            On success, <c>setipv4sourcefilter</c> returns NO_ERROR (0). Any nonzero return value indicates failure and a specific error
            code can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAENOBUFS</term>
            <term>Insufficient buffer space is available.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>setipv4sourcefilter</c> inline function is used to set the multicast filter state for an IPv4 socket.</para>
            <para>
            This function is part of socket interface extensions for multicast source filters defined in RFC 3678. An app can use these
            functions to retrieve and set the multicast source address filters associated with a socket.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.setsourcefilter(Vanara.PInvoke.Ws2_32.SOCKET,System.UInt32,Vanara.PInvoke.Ws2_32.SOCKADDR,System.Int32,Vanara.PInvoke.Ws2_32.MULTICAST_MODE_TYPE,System.UInt32,Vanara.PInvoke.Ws2_32.SOCKADDR_STORAGE[])">
            <summary>The <c>setsourcefilter</c> inline function sets the multicast filter state for an IPv4 or IPv6 socket.</summary>
            <param name="Socket">A descriptor that identifies a multicast socket.</param>
            <param name="Interface">The interface index of the multicast interface.</param>
            <param name="Group">A pointer to the socket address of the multicast group.</param>
            <param name="GroupLength">The length, in bytes, of the socket address pointed to by the Group parameter.</param>
            <param name="FilterMode">The multicast filter mode for the multicast group address.</param>
            <param name="SourceCount">The number of source addresses in the buffer pointed to by the SourceList parameter.</param>
            <param name="SourceList">A pointer to a buffer with the IP addresses to associate with the multicast filter.</param>
            <returns>
            <para>
            On success, <c>setsourcefilter</c> returns NO_ERROR (0). Any nonzero return value indicates failure and a specific error code
            can be retrieved by calling WSAGetLastError.
            </para>
            <list type="table">
            <listheader>
            <term>Error code</term>
            <term>Meaning</term>
            </listheader>
            <item>
            <term>WSAENOBUFS</term>
            <term>Insufficient buffer space is available.</term>
            </item>
            <item>
            <term>WSAENOTSOCK</term>
            <term>The descriptor is not a socket.</term>
            </item>
            </list>
            </returns>
            <remarks>
            <para>The <c>setsourcefilter</c> inline function is used to set the multicast filter state for an IPv4 or IPv6 socket.</para>
            <para>
            This function is part of socket interface extensions for multicast source filters defined in RFC 3678. An app can use these
            functions to retrieve and set the multicast source address filters associated with a socket.
            </para>
            <para><c>Windows Phone 8:</c> This function is supported for Windows Phone Store apps on Windows Phone 8 and later.</para>
            <para>
            <c>Windows 8.1</c> and <c>Windows Server 2012 R2</c>: This function is supported for Windows Store apps on Windows 8.1, Windows
            Server 2012 R2, and later.
            </para>
            </remarks>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SafeADDRINFOWArray">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> for an array of <see cref="T:Vanara.PInvoke.Ws2_32.ADDRINFOW"/> that is disposed using <see cref="M:Vanara.PInvoke.Ws2_32.FreeAddrInfoW(System.IntPtr)"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SafeADDRINFOWArray.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.SafeADDRINFOWArray"/> class.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.SafeADDRINFOWArray.Length">
            <summary>Gets the number of elements contained in the <see cref="T:Vanara.PInvoke.Ws2_32.SafeADDRINFOWArray"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.SafeADDRINFOWArray.Items">
            <summary>Enumerates the elements.</summary>
            <returns>An enumeration of values from the pointer.</returns>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.SafeADDRINFOWArray.Item(System.Int32)">
            <summary>Gets or sets the <see cref="T:Vanara.PInvoke.Ws2_32.ADDRINFOW"/> value at the specified index.</summary>
            <param name="index">The index of the info within the array.</param>
            <returns>The <see cref="T:Vanara.PInvoke.Ws2_32.ADDRINFOW"/> value.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index or index</exception>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SafeADDRINFOWArray.Contains(Vanara.PInvoke.Ws2_32.ADDRINFOW)">
            <summary>Determines whether this instance contains the object.</summary>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
            <returns>
            <see langword="true"/> if <paramref name="item"/> is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SafeADDRINFOWArray.GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary>
            <returns>A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SafeADDRINFOWArray.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SafeADDRINFOWArray.InternalReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:Vanara.PInvoke.Ws2_32.SafeADDRINFOEXWArray">
            <summary>Provides a <see cref="T:System.Runtime.InteropServices.SafeHandle"/> for an array of <see cref="T:Vanara.PInvoke.Ws2_32.ADDRINFOEXW"/> that is disposed using <see cref="M:Vanara.PInvoke.Ws2_32.FreeAddrInfoW(System.IntPtr)"/>.</summary>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SafeADDRINFOEXWArray.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Vanara.PInvoke.Ws2_32.SafeADDRINFOEXWArray"/> class.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.SafeADDRINFOEXWArray.Length">
            <summary>Gets the number of elements contained in the <see cref="T:Vanara.PInvoke.Ws2_32.SafeADDRINFOEXWArray"/>.</summary>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.SafeADDRINFOEXWArray.Items">
            <summary>Enumerates the elements.</summary>
            <returns>An enumeration of values from the pointer.</returns>
        </member>
        <member name="P:Vanara.PInvoke.Ws2_32.SafeADDRINFOEXWArray.Item(System.Int32)">
            <summary>Gets or sets the <see cref="T:Vanara.PInvoke.Ws2_32.ADDRINFOEXW"/> value at the specified index.</summary>
            <param name="index">The index of the info within the array.</param>
            <returns>The <see cref="T:Vanara.PInvoke.Ws2_32.ADDRINFOEXW"/> value.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index or index</exception>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SafeADDRINFOEXWArray.Contains(Vanara.PInvoke.Ws2_32.ADDRINFOEXW)">
            <summary>Determines whether this instance contains the object.</summary>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
            <returns>
            <see langword="true"/> if <paramref name="item"/> is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SafeADDRINFOEXWArray.GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary>
            <returns>A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SafeADDRINFOEXWArray.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Vanara.PInvoke.Ws2_32.SafeADDRINFOEXWArray.InternalReleaseHandle">
            <inheritdoc/>
        </member>
    </members>
</doc>
